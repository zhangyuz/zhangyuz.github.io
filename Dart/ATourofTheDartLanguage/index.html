<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.zhangyuzheng.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="原文见：A Tour of the Dart Language  本文将为你展示Dart语言的主要特性，包括从变量、操作符到类、库等一系列内容。本文默认你已经有了其他编程语言基础。 学习更多关于Dart核心库的内容可以参考A Tour of the Dart Libraries。关于Dart语言更多的详细内容可以参考Dart Language Specification。 Dart基本程序 下面">
<meta property="og:type" content="article">
<meta property="og:title" content="A Tour of the Dart Language">
<meta property="og:url" content="https://www.zhangyuzheng.com/Dart/ATourofTheDartLanguage/index.html">
<meta property="og:site_name" content="memorandums">
<meta property="og:description" content="原文见：A Tour of the Dart Language  本文将为你展示Dart语言的主要特性，包括从变量、操作符到类、库等一系列内容。本文默认你已经有了其他编程语言基础。 学习更多关于Dart核心库的内容可以参考A Tour of the Dart Libraries。关于Dart语言更多的详细内容可以参考Dart Language Specification。 Dart基本程序 下面">
<meta property="og:locale">
<meta property="article:published_time" content="2018-06-01T06:15:00.000Z">
<meta property="article:modified_time" content="2020-01-09T11:30:00.000Z">
<meta property="article:author" content="Zhang Yuzheng">
<meta property="article:tag" content="Dart">
<meta property="article:tag" content="Flutter">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.zhangyuzheng.com/Dart/ATourofTheDartLanguage/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh'
  };
</script>

  <title>A Tour of the Dart Language | memorandums</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="memorandums" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">memorandums</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">life notes</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://www.zhangyuzheng.com/Dart/ATourofTheDartLanguage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhang Yuzheng">
      <meta itemprop="description" content="码农日常">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="memorandums">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          A Tour of the Dart Language
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-06-01 14:15:00" itemprop="dateCreated datePublished" datetime="2018-06-01T14:15:00+08:00">2018-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-09 19:30:00" itemprop="dateModified" datetime="2020-01-09T19:30:00+08:00">2020-01-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Dart/" itemprop="url" rel="index"><span itemprop="name">Dart</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>原文见：<a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/language-tour">A Tour of the Dart Language</a></p>
</blockquote>
<p>本文将为你展示Dart语言的主要特性，包括从变量、操作符到类、库等一系列内容。本文默认你已经有了其他编程语言基础。</p>
<p>学习更多关于Dart核心库的内容可以参考<a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/libraries/library-tour">A Tour of the Dart Libraries</a>。关于Dart语言更多的详细内容可以参考<a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/spec">Dart Language Specification</a>。</p>
<h2 id="dart基本程序">Dart基本程序</h2>
<p>下面的代码展示了很多Dart语言最基础的特性：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define a function</span></span><br><span class="line">printInteger(<span class="built_in">int</span> aNumber) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;The number is <span class="subst">$aNumber</span>.&#x27;</span>); <span class="comment">// Print to console.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is where the app starts executing.</span></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> number = <span class="number">42</span>; <span class="comment">// Declare and initialize a variable.</span></span><br><span class="line">  printInteger(number); <span class="comment">// Call a function.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面解释下上方代码展示的特性（适用几乎所有的Dart 应用程序）：</p>
<p><code>// 注释</code></p>
<p>单行注释，Dart也支持多行注释和文档注释，参考<a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/language-tour#comments">Comments</a>。</p>
<p><code>int</code></p>
<p>一种数据类型，其他<a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/language-tour#built-in-types">内置数据类型</a>还有<code>String</code>，<code>List</code>和<code>bool</code>。</p>
<p><code>print()</code></p>
<p>显示输出的一种简单方式。</p>
<p><code>'...'</code>和<code>"..."</code></p>
<p>字符串常量。</p>
<p><code>$variableName</code>或<code>$&#123;expression&#125;</code></p>
<p>字符串插值：字符串常量内包含一个变量或表达式的字符串形式，参考 <a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/language-tour#strings">Strings</a>。</p>
<p><code>main()</code></p>
<p>可执行APP的入口，必需。参考 <a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/language-tour#the-main-function">The main() function</a>。</p>
<p><code>var</code></p>
<p>不指定类型声明变量的一种方式。</p>
<blockquote>
<p>本文代码风格遵守 <a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/effective-dart/style">Dart style guide</a>。</p>
</blockquote>
<h2 id="重要概念">重要概念</h2>
<p>学习 Dart 语言，要时刻牢记以下事实与概念：</p>
<ul>
<li>所有变量可以保存的内容都是<em>object</em>。所有的 object 都是 <em>class</em> 的实例。数字、函数、<code>null</code> 都是 object。所有的 object 都继承自 <a target="_blank" rel="noopener" href="https://api.dartlang.org/dev/dart-core/Object-class.html">Object</a> 。</li>
<li>虽然 Dart 是强类型语言，但是类型声明是可选的，因为 Dart 可以推断类型。在上边的代码中，<code>number</code> 被推断为 <code>int</code> 类型。如果需要明确说明任何类型都不需要，可以使用特殊的类型 <a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/effective-dart/design#do-annotate-with-object-instead-of-dynamic-to-indicate-any-object-is-allowed">dynamic</a> 。</li>
<li>Dart 支持泛型，比如 <code>List&lt;int&gt;</code> 表示整数列表， <code>List&lt;Dynamic&gt;</code> 表示任何类型对象的列表。</li>
<li>Dart 支持顶层函数，比如 <code>main()</code> ，还支持与 类 、对象关联的函数（即static函数和实例方法）。还支持在函数中创建函数（嵌套函数或者本地函数）。</li>
<li>类似的，Dart 支持顶层变量，也支持类、对象关联变量（static 或实例变量）。实例变量也称为域或者属性。</li>
<li>与 Java 不同，Dart 没有 <code>public</code> 、<code>protected</code> 和 <code>private</code> 这些关键字，如果某个标识符以下杠 <code>_</code> 开头，那么那就是库私有的，详细信息参考<a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/language-tour#libraries-and-visibility">Libraries and visibility</a> 。</li>
<li><em>标识符</em> 可以以字母或者下杠开头，后边跟热议字符和数字。</li>
<li>有时候，某些东西究竟是 <em>expression</em> 还是 <em>statement</em> 很重要，他可以帮助精确的区分这两个单词。</li>
<li>Dart 工具可以报告两类问题：警告与错误。警告仅仅警示代码可能无法工作，但是不会妨碍你运行程序。错误包括编译时错误和运行时错误。编译错误倒是代码完全无法运行。运行时错误会在运行时抛出<a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/language-tour#exceptions">异常</a>。</li>
</ul>
<h2 id="关键字">关键字</h2>
<p>下面是 Dart 会特殊处理的关键字列表。</p>
<table>
<thead>
<tr class="header">
<th>abstract 1</th>
<th>do</th>
<th>import 1</th>
<th>super</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>as 1</td>
<td>dynamic 1</td>
<td>in</td>
<td>switch</td>
</tr>
<tr class="even">
<td>assert</td>
<td>else</td>
<td>interface 1</td>
<td>sync* 2</td>
</tr>
<tr class="odd">
<td>async 2</td>
<td>enum</td>
<td>is</td>
<td>this</td>
</tr>
<tr class="even">
<td>async* 2</td>
<td>export 1</td>
<td>library 1</td>
<td>throw</td>
</tr>
<tr class="odd">
<td>await 2</td>
<td>external 1</td>
<td>mixin 1</td>
<td>true</td>
</tr>
<tr class="even">
<td>break</td>
<td>extends</td>
<td>new</td>
<td>try</td>
</tr>
<tr class="odd">
<td>case</td>
<td>factory 1</td>
<td>null</td>
<td>typedef 1</td>
</tr>
<tr class="even">
<td>catch</td>
<td>false</td>
<td>operator 1</td>
<td>var</td>
</tr>
<tr class="odd">
<td>class</td>
<td>final</td>
<td>part 1</td>
<td>void</td>
</tr>
<tr class="even">
<td>const</td>
<td>finally</td>
<td>rethrow</td>
<td>while</td>
</tr>
<tr class="odd">
<td>continue</td>
<td>for</td>
<td>return</td>
<td>with</td>
</tr>
<tr class="even">
<td>covariant 1</td>
<td>get 1</td>
<td>set 1</td>
<td>yield 2</td>
</tr>
<tr class="odd">
<td>default</td>
<td>if</td>
<td>static 1</td>
<td>yield* 2</td>
</tr>
<tr class="even">
<td>deferred 1</td>
<td>implements 1</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>上标为 <sup>1</sup> 的关键字是内置标识符，不要使用内置标识符作为标识符使用。如果使用内置标识符作为类名或类型名会造成编译时错误。</p>
<p>上标为 <sup>2</sup> 的关键字是 Dart1.0 之后增加的仅仅同步相关保留字。在任何被 <code>async</code> 、<code>async*</code>或 <code>sync*</code> 标记的函数中无法使用 <code>async</code> 、<code>await</code> 或者 <code>yield</code> 作为标识符。参考 <a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/language-tour#asynchrony-support">Asynchrony support</a> 。</p>
<p>上表中的其他关键字都是保留字，禁止把它们作为标识符使用。</p>
<h2 id="变量">变量</h2>
<p>下面的例子创建并初始化了一个变量：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Bob&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>变量存储的是引用。名字为 <code>name</code> 的变量包含了一个值为"Bob" 的 <code>String</code> 对象的引用。</p>
<p><code>name</code> 的类型被推断为<code>String</code> 。不能通过指定类型类改变他的类型。如果对象的类型不限制为某一类型，那么根据<a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/effective-dart/design#do-annotate-with-object-instead-of-dynamic-to-indicate-any-object-is-allowed">设计指南</a>，可以将它的类型指定为 <code>Object</code> 或 <code>dynamic</code> 。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> name = <span class="string">&#x27;Bob&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>另一种方式是显示的声明它可以被推断出的类型：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> name = <span class="string">&#x27;Bob&#x27;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，本文遵守<a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/effective-dart/design#types">style guide recommendation</a> 对本地变量使用 var 而不指定类型的建议。</p>
</blockquote>
<h3 id="默认值">默认值</h3>
<p>未经初始化的变量的默认值是 <code>null</code> 。即使数字类型也初始化为空，因为数字在 Dart 中也是对象。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> lineCount;</span><br><span class="line"><span class="keyword">assert</span>(lineCount == <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在生产代码中，<code>assert()</code> 调用会被忽略掉。在开发中，<code>assert(condition)</code> 在<em>condition</em> 为非 <code>true</code> 时抛出异常。参考 <a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/language-tour#assert">Assert</a>。</p>
</blockquote>
<h3 id="final-与-const">final 与 const</h3>
<p>对于一个你永远都不会改变的变量，使用 <code>final</code> 或 <code>const</code> 来标识，可以用来它们来代替关键字 <code>var</code> 或者在指定的类型之前。一个 final 限定的变量只可以被赋值一次；使用const限定的变量是编译时常量（const限定的变量默认就是final的）。final限定的顶层或类变量在第一次被使用时初始化。</p>
<blockquote>
<p>注意：实例变量可以用final但是不能用const限定。</p>
</blockquote>
<p>下面的例子创建并设置 final 的变量：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> name = <span class="string">&#x27;Bob&#x27;</span>； <span class="comment">// 无变量类型标识</span></span><br><span class="line"><span class="comment">// name = &#x27;Alice&#x27;;	 // 去掉注释，本行会引起错误</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> nickname = <span class="string">&#x27;Bobby&#x27;</span>；</span><br></pre></td></tr></table></figure>
<p>使用 <code>const</code> 来限定你需要的编译时常量（compile-time constants）。如果 const 变量是类级别的，将它标记为 <code>static const</code> 。在你声明变量并赋值为编译时常量比如数字、字符串或者数字运算的结果时，声明为 const 变量：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="number">10000000</span>; <span class="comment">// 压力单元(dynes/cm2)</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">double</span> atm - <span class="number">1.01325</span> * bar; <span class="comment">//标准气压</span></span><br></pre></td></tr></table></figure>
<p><code>const</code> 关键字不仅仅能声明常量，你还可以用来创建常量值，也可以用来声明构造函数。任何变量都可以包含一个常量值。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意: []创建空列表</span></span><br><span class="line"><span class="comment">// const [] 创建一个空、不可变的列表(empty,immutable list, EIL)</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">const</span> []; <span class="comment">// foo是一个 EIL</span></span><br><span class="line"><span class="keyword">final</span> bar = <span class="keyword">const</span> []; <span class="comment">// bar永远都是一个 EIL</span></span><br><span class="line"><span class="keyword">const</span> baz = <span class="keyword">const</span> []; <span class="comment">// baz是编译时的常量 EIL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以修改 非final、非const变量，即使它曾经被赋值一个const值；</span></span><br><span class="line">foo = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是无法修改final或const变量的值。</span></span><br><span class="line"><span class="comment">// bar = []; // Unhandled exception</span></span><br><span class="line"><span class="comment">// baz = []; // Unhandled exception</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>const</code> 来创建常量值，参考 <a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/language-tour#lists">Lists</a> 、<a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/language-tour#maps">Maps</a> 和 <a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/language-tour#classes">Classes</a> 。</p>
<h2 id="内置类型">内置类型</h2>
<p>Dart 语言对以下类型有特别支持：</p>
<ul>
<li>numbers</li>
<li>strings</li>
<li>booleans</li>
<li>lists(也就是 arrays)</li>
<li>maps</li>
<li>runes(在字符串中展示 Unicode 字符)</li>
<li>symbols</li>
</ul>
<p>你可以用常量初始化以上任意类型的对象。比如 <code>this is a string</code> 是字符串常量， <code>true</code> 是布尔型常量。</p>
<p>由于 Dart 中任何的变量都引用一个对象，你可以使用构造函数来时初始化变量。一些内置类型也有它们自己的构造函数。比如你可以用 <code>Map()</code> 来创建一个map，代码可能是 <code>new Map()</code> 。</p>
<h3 id="数字">数字</h3>
<p>Dart 只有两种类型的数字：</p>
<p><a target="_blank" rel="noopener" href="https://api.dartlang.org/dev/dart-core/int-class.html">int</a></p>
<p>依赖平台，不大于64 bit 长度 。在Dart VM上，数值范围：-2<sup>63</sup> - 2<sup>63</sup> - 1。</p>
<p><a target="_blank" rel="noopener" href="https://api.dartlang.org/dev/dart-core/double-class.html">double</a>。</p>
<p>64位浮点数，符合IEEE754标准。</p>
<p><code>int</code> 和 <code>double</code> 都是<a target="_blank" rel="noopener" href="https://api.dartlang.org/dev/dart-core/num-class.html">num</a> 的子类，基本的数学运算符+、-、*、/ 都适用这些数字类型，还包括 <code>abs()</code> 、<code>ceil()</code> 和 <code>floor()</code>方法（位操作运算符都定义在 <code>int</code> 类型中）。如果 num 及其子类不包含你需要的操作，可以看下 <code>dart:math</code> 库，可能会包含你需要的函数。</p>
<p>整数就是没有小数点的数字：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> hex = <span class="number">0xDEADBEEF</span>;</span><br></pre></td></tr></table></figure>
<p>double类型就是包含小数点的数字：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> y = <span class="number">1.1</span>;</span><br><span class="line"><span class="built_in">double</span> exponents = <span class="number">1.42e5</span>;</span><br></pre></td></tr></table></figure>
<p>下面的例子展示了如何在数字与字符串之间数据类型转换：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String -&gt; int</span></span><br><span class="line"><span class="keyword">var</span> one = <span class="built_in">int</span>.parse(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">assert</span>(one == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// String -&gt; double</span></span><br><span class="line"><span class="keyword">var</span> onePointOne = <span class="built_in">double</span>.parse(<span class="string">&#x27;1.1&#x27;</span>);</span><br><span class="line"><span class="keyword">assert</span>(ontPointOne == <span class="number">1.1</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// int -&gt; String</span></span><br><span class="line"><span class="built_in">String</span> oneAsString = <span class="number">1.</span>toString();</span><br><span class="line"><span class="keyword">assert</span>(oneAsString == <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// double -&gt; String</span></span><br><span class="line"><span class="built_in">String</span> piAsString = <span class="number">3.14159</span>.toStringAsFixed(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">assert</span>(piAsString == <span class="string">&#x27;3.14&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>整型制定了传统的位位移操作（&lt;&lt;, &gt;&gt;），与 (&amp;) 和或 (|)：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>((<span class="number">3</span> &lt;&lt; <span class="number">1</span>) == <span class="number">6</span>);  <span class="comment">// 0011 &lt;&lt; 1 = 0110</span></span><br><span class="line"><span class="keyword">assert</span>((<span class="number">3</span> &gt;&gt; <span class="number">1</span>) == <span class="number">1</span>);  <span class="comment">// 0011 &gt;&gt; 1 == 0001</span></span><br><span class="line"><span class="keyword">assert</span>((<span class="number">3</span> | <span class="number">4</span>) == <span class="number">7</span>);   <span class="comment">// 0011 | 0100 = 0111</span></span><br></pre></td></tr></table></figure>
<p>原始数字就是编译时常量。很多数学表达式只要他操作数都是编译时常量，那么它也是编译时常量：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> msPerSecond = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> secondsUtilRetry = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> msUntilRetry = secondsUtilRetry * secondsUtilRetry;</span><br></pre></td></tr></table></figure>
<h3 id="strings">Strings</h3>
<p>Dart 语言中的字符串就是 UTF-16 编码的序列。可以使用单引号或双引号创建字符串：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&#x27;Single quotes work well for string literals.&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">&quot;Double quotes work just as well.&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s3 = <span class="string">&#x27;It\&#x27;s easy to escape the string delimiter.&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> s4 = <span class="string">&quot;It&#x27;s even easier to use the other delimiter.&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>可以利用 <code>$&#123;expression&#125;</code> 将表达式的值放到字符串中。如果表达式是变量，可以省略 <code>&#123;&#125;</code> 符号。Dart 调用对象的 <code>toString()</code> 方法来获取对象的字符串表示。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;string interpolation&#x27;</span>;</span><br><span class="line"><span class="keyword">assert</span>(<span class="string">&#x27;Dart has <span class="subst">$s</span>, which is very handy.&#x27;</span> ==</span><br><span class="line">      <span class="string">&#x27;Dart has string interpolation,&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;which is very handy.&#x27;</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="string">&#x27;That deserves all caps. &#x27;</span> +</span><br><span class="line">       <span class="string">&#x27;<span class="subst">$&#123;s.toUpperCase()&#125;</span> is very handy!&#x27;</span> ==</span><br><span class="line">       <span class="string">&#x27;That deserves all caps. &#x27;</span> +</span><br><span class="line">       <span class="string">&#x27;STRING INTERPOLATION is very handy!&#x27;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>== 操作符用来比较两个对象是否相等。包含相同 UTF-16 码的序列的字符创是相等的。</p>
</blockquote>
<p>两个相邻的字符串会自动合并成一个字符串，也可以用 <code>+</code> 来合并字符串：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&#x27;String &#x27;</span></span><br><span class="line">  <span class="string">&#x27;concatenation&#x27;</span></span><br><span class="line">  <span class="string">&#x27; works event over line breaks.&#x27;</span>;</span><br><span class="line"><span class="keyword">assert</span> (s1 ==</span><br><span class="line">        <span class="string">&#x27;String concatenation works even over &#x27;</span></span><br><span class="line">        <span class="string">&#x27;line breaks.&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">&#x27;The + operator &#x27;</span> + <span class="string">&quot;works, as well.&quot;</span>;</span><br><span class="line"><span class="keyword">assert</span>(s2 == <span class="string">&#x27;The + operator works, as well.&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>使用三引号创建多行字符串：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">You can creat multi-line strings like this one.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">&quot;&quot;&quot; This is also a </span></span><br><span class="line"><span class="string">multi-line string.&quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>你可以使用 <code>r</code> 作为前缀生成 'raw'字符串（译注：指的是所见即所得的字符串，没有任何转义）：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">r&quot;In a raw string, event \n isn&#x27;t special.&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>关于如何在字符串中显示 Unicode ，参考 <a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/language-tour#runes">Runes</a> 。</p>
<p>Literal strings are compile-time constants, as long as any interpolated expression is a compile-time constant that evaluates to null or a numeric, string, or boolean value.</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Theses work in a const string.</span></span><br><span class="line"><span class="keyword">const</span> aConstNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> aConstBool = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">const</span> aConstStrng = <span class="string">&#x27;a constant string&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// These do NOT work in a const string</span></span><br><span class="line"><span class="keyword">var</span> aNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> aBool = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">var</span> sString = <span class="string">&#x27;a string&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> aConstList = <span class="keyword">const</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> validConstString = <span class="string">&#x27;<span class="subst">$aConstNum</span> <span class="subst">$aConstBool</span> <span class="subst">$aConstString</span>&#x27;</span>;</span><br><span class="line"><span class="comment">// const invalidConstString = &#x27;$aNum $aBool $aString $aConstList&#x27;;</span></span><br></pre></td></tr></table></figure>
<p>对String的更多用法，参考 <a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/libraries/library-tour#strings-and-regular-expressions">Strings and regular expressions</a>。</p>
<h3 id="booleans">Booleans</h3>
<p>为了表示布尔型，Dart 定义了数据类型 <code>bool</code> 。bool 类型只有两个常量对象 <code>true</code> 和 <code>false</code> ，都是编译时常量。</p>
<p>Dart 语言的类型安全指的是 你不能写这样的代码，比如 <code>if (nonbooleanValue)</code> 或者 <code>assert(nonbooleanValue)</code> 。相反，显示的检查变量的值：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check for an empty string.</span></span><br><span class="line"><span class="keyword">var</span> fullName = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">assert</span>(fullName.isEmpty);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for zero.</span></span><br><span class="line"><span class="keyword">var</span> hitPoints = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">assert</span>(hitPoints &lt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for null.</span></span><br><span class="line"><span class="keyword">var</span> unicorn;</span><br><span class="line"><span class="keyword">assert</span>(unicorn == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for NaN.</span></span><br><span class="line"><span class="keyword">var</span> iMeantToDoThis = <span class="number">0</span> / <span class="number">0</span>;</span><br><span class="line"><span class="keyword">assert</span>(iMeantToDoThis.isNaN);</span><br></pre></td></tr></table></figure>
<h3 id="lists">Lists</h3>
<p>几乎所有编程语言都包含的集合类型就是数组了。在Dart中，数组就是 <a target="_blank" rel="noopener" href="https://api.dartlang.org/dev/dart-core/List-class.html">List</a> 对象，多数人称其为列表。</p>
<p>Dart 列表的字符表示与JavaScript的数组表示类似：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Dart 分析器会将上边的 list 类型推断为 List<int> 。如果尝试向其中添加非int类型数据，分析器或运行时会抛出错误。详细信息参考 <a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/sound-dart#type-inference">typr inference</a> 。</p>
</blockquote>
<p>List 的下标从0开始，下标为0的元素就是第一个元素，下标为 <code>list.length - 1</code> 的元素就最后一个。你可以与JavaScript语言一样获取列表的长度和获取列表中的元素：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">assert</span>(list.length == <span class="number">3</span>);</span><br><span class="line"><span class="keyword">assert</span>(list[<span class="number">1</span>] == <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">list[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">assert</span>(list[<span class="number">1</span>] == <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>在 list 的字符表示前增加 <code>const</code> 来创建编译时常量 list：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constantList = <span class="keyword">const</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// constantList[1] = 1;  // Uncommenting this cause an error</span></span><br></pre></td></tr></table></figure>
<p>List 类型有很多操作list的使用方法。更多用法参考 <a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/language-tour#generics">Generics</a> 和 <a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/libraries/library-tour#collections">Collections</a> 。</p>
<h3 id="maps">Maps</h3>
<p>通常，一个的映射就是一个相关联的键值的对象。key 和 value 可以是任意类型的对象。在一个映射中，每个key只能出现一次，但是value可以重复。Dart 对映射的支持是由 <a target="_blank" rel="noopener" href="https://api.dartlang.org/dev/dart-core/Map-class.html">Map</a> 类型和 map 的字符形式提供的：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;</span><br><span class="line">    <span class="comment">// Key:    Value</span></span><br><span class="line">    <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;partridge&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;second&#x27;</span>: <span class="string">&#x27;turtleedoves&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;fifth&#x27;</span>: <span class="string">&#x27;golden rings&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nobleGases = &#123;</span><br><span class="line">    <span class="number">2</span>: <span class="string">&#x27;helium&#x27;</span>,</span><br><span class="line">    <span class="number">10</span>: <span class="string">&#x27;neon&#x27;</span>,</span><br><span class="line">    <span class="number">18</span>: <span class="string">&#x27;argon&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上边代码中，分析器会将 <code>gifts</code> 被推断为 <code>Map&lt;String, String&gt;</code> 类型。<code>bobleGases</code> 的类型被推断为 <code>Map&lt;int, String&gt;</code> 。如果你想向其中增加错误类型的数据，分析器或运行时会抛出错误。更多信息，参考 <a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/sound-dart#type-inference">type inference</a> 。</p>
</blockquote>
<p>你可以用Map的构造函数创建相同对象：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">gifts[<span class="string">&#x27;first&#x27;</span>] = <span class="string">&#x27;partridge&#x27;</span>;</span><br><span class="line">gifts[<span class="string">&#x27;second&#x27;</span>] = <span class="string">&#x27;turtledoves&#x27;</span>;</span><br><span class="line">gifts[<span class="string">&#x27;fifth&#x27;</span>] = <span class="string">&#x27;golden rings&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nobleGases = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">nobleGases[<span class="number">2</span>] = <span class="string">&#x27;helium&#x27;</span>;</span><br><span class="line">nobleGases[<span class="number">10</span>] = <span class="string">&#x27;neom&#x27;</span>;</span><br><span class="line">nobleGases[<span class="number">18</span>] = <span class="string">&#x27;argon&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>向已有map中添加新的键值对：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;<span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;partridges&#x27;</span>&#125;;</span><br><span class="line">gifts[<span class="string">&#x27;forth&#x27;</span>] = <span class="string">&#x27;calling birds&#x27;</span>;  <span class="comment">// Add a key-value pair</span></span><br></pre></td></tr></table></figure>
<p>从 map 中获取值：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;<span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;partridge&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">assert</span>(gifts[<span class="string">&#x27;first&#x27;</span>] == <span class="string">&#x27;partridge&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>如果从map中获取不存在的key的值，反馈 <code>null</code> ：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;<span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;partridge&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">assert</span>(gifts[<span class="string">&#x27;fifth&#x27;</span>] == <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>使用 <code>.length</code> 获取map中键值对的数量：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;<span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;partridge&#x27;</span>&#125;;</span><br><span class="line">gifts[<span class="string">&#x27;fourth&#x27;</span>] = <span class="string">&#x27;calling birds&#x27;</span>;</span><br><span class="line"><span class="keyword">assert</span>(gifts.length == <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>创建编译时常量：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> constantMap = <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;helium&#x27;</span>,</span><br><span class="line">  <span class="number">10</span>: <span class="string">&#x27;neon&#x27;</span>,</span><br><span class="line">  <span class="number">18</span>: <span class="string">&#x27;argon&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constantMap[2] = &#x27;Helium&#x27;; // Uncommenting this causes an error.</span></span><br></pre></td></tr></table></figure>
<p>关于 map 的更多信息，参考 <a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/language-tour#generics">Generics</a> 和 <a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/libraries/library-tour#maps">Maps</a> 。</p>
<h3 id="runes">Runes</h3>
<blockquote>
<p>译注：此处的runes和符号指的是各类特殊符号，emoji等。</p>
</blockquote>
<p>Dart 中，各种符号都是字符串的 UTF-32 码。</p>
<p>Unicode 为全世界所有书写系统的字母、数字、符号都定义了唯一的数字值。由于 Dart 中使用 UTF-16 表示字符串，为了表示 UTF-32 的符号，需要使用特别的语法。</p>
<p>表示 Unicode 编码的常用方法是这样的：<code>\uXXXX</code> ， XXXX表示4个16进制数字。比如心形符号♥ 的Unicode是 <code>\u2665</code> 。为了表示多或少于4位16进制数字，把Unicode 放在大括号中，😆 是 <code>\u&#123;1f600&#125;</code> 。</p>
<p><code>String</code> 类的某些属性可以帮你获取关于符号的信息。<code>codeUnitAt</code> 和 <code>codeUnit</code> 这两个属性获取16位的unicode 码。使用 <code>runes</code> 属性获取字符串中的符号。</p>
<p>下面的代码展示了符号、16位码、32位码的关系：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> clapping = <span class="string">&#x27;\u&#123;1f44f&#125;&#x27;</span>;</span><br><span class="line">  <span class="built_in">print</span>(clapping);</span><br><span class="line">  <span class="built_in">print</span>(clapping.codeUnits);</span><br><span class="line">  <span class="built_in">print</span>(clapping.runes.toList());</span><br><span class="line"></span><br><span class="line">  Runes input = <span class="keyword">new</span> Runes(</span><br><span class="line">      <span class="string">&#x27;\u2665  \u&#123;1f605&#125;  \u&#123;1f60e&#125;  \u&#123;1f47b&#125;  \u&#123;1f596&#125;  \u&#123;1f44d&#125;&#x27;</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="keyword">new</span> <span class="built_in">String</span>.fromCharCodes(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用list运算符操作符号的时候要特别注意。这种处理方式很容易失败，它依赖于语言、字符集和具体的运算符。更多信息参考 <a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/21521729/how-do-i-reverse-a-string-in-dart">Hwo do I reverse a String in Dart?</a> 。</p>
</blockquote>
<h3 id="symbols">Symbols</h3>
<p><a target="_blank" rel="noopener" href="https://api.dartlang.org/dev/dart-core/Symbol-class.html">Sumbol</a> 对象表示Dart中的一个操作符和标识符。你可能永远都不会用到 Symbol，因为对于使用名字应用的标识符来说，Symbol是没有值的。'because minification changes identifier names but not identifier symbols ' （译注：没懂什么意思）。</p>
<p>使用 <code>#</code> 来获取标识符的 symbol：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#radix</span><br><span class="line">#bar</span><br></pre></td></tr></table></figure>
<p>Symbol 的字面标识是编译时常量。</p>
<h2 id="functions">Functions</h2>
<p>Dart 是真正面向对象的语言，所以即使函数也是对象，并且属于 <a target="_blank" rel="noopener" href="https://api.dartlang.org/dev/dart-core/Function-class.html">Function</a> 类型。这意味着函数可以用来赋值给变量或者作为参数传递给其他函数。对于函数类的对象，你可以直接调用这个对象，详细信息参考<a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/language-tour#callable-classes">Callable classes</a> 。</p>
<p>函数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble(<span class="built_in">int</span> atomicNumber) &#123;</span><br><span class="line">    <span class="keyword">return</span> _nobleGases[atomicNumber] == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然Dart建议显示的标明函数的返回值类型，但是如果你省略返回值类型它依然可用：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isNoble(atomicNumber) &#123;</span><br><span class="line">  <span class="keyword">return</span> _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于只有一个表达式的函数，可用使用一种简短的语法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble(<span class="built_in">int</span> atomicNumber) =&gt; _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p><code>=&gt;expr</code> 是 <code>return expr</code> 的简短写法。<code>=&gt;</code> 有事被称为胖箭头（<em>fat arrow</em>）语法。</p>
<blockquote>
<p>注意：只有表达式可以出现在胖箭头语句中，其他语句不可以。比如你不可以在其中编写 <a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/language-tour#if-and-else">if</a> 语句，但是可以使用<a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/language-tour#conditional-expressions">条件表达式</a>。</p>
</blockquote>
<h3 id="optional-parameters">Optional parameters</h3>
<p>可选参数可以通过位置或名字确定，但不能同时通过两者确定。</p>
<p>Optional named parameters</p>
<p>调用函数的的时候可以用 <code>paramName:value</code> 指定参数值：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enableFlags(bold: <span class="keyword">true</span>, hiden: <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p>定义函数时。使用 <code>&#123;param1, param2&#125;</code> 来指定参数名字：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sets the [bold] and [hiden] flags ...</span></span><br><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold, <span class="built_in">bool</span> hiden&#125;) &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="optional-positional-parameters">Optional positional parameters</h4>
<p>使用 <code>[]</code> 包含的参数列表来标识 positional 参数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg, [<span class="built_in">String</span> device]) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="string">&#x27;<span class="subst">$from</span> says <span class="subst">$msg</span>&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (device != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = <span class="string">&#x27;<span class="subst">$result</span> with a <span class="subst">$device</span>&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用上面的函数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Without the optional parameter</span></span><br><span class="line"><span class="keyword">assert</span>(say(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Howdy&#x27;</span>) == <span class="string">&#x27;Bob says Howdy&#x27;</span>);</span><br><span class="line"><span class="comment">// With the optional parameter</span></span><br><span class="line"><span class="keyword">assert</span>(say(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Howdy&#x27;</span>, <span class="string">&#x27;smoke signal&#x27;</span>) == <span class="string">&#x27;Bob says Howdy with a smoke signal&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="default-parameter-values">Default parameter values</h4>
<p>使用 <code>=</code> 来为可选参数设置默认值。默认值必须是编译时常量。默认的默认值是 <code>null</code> ：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">Sets the [bold] and [hidden] flags ...</span></span></span><br><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold = <span class="keyword">false</span>, <span class="built_in">bool</span> hidden = <span class="keyword">false</span>&#125;) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bold will be true; hidden will be false.</span></span><br><span class="line">enableFlags(bold: <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>可选参数的默认值可以如下设置：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg,</span><br><span class="line">    [<span class="built_in">String</span> device = <span class="string">&#x27;carrier pigeon&#x27;</span>, <span class="built_in">String</span> mood]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">&#x27;<span class="subst">$from</span> says <span class="subst">$msg</span>&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (device != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">&#x27;<span class="subst">$result</span> with a <span class="subst">$device</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mood != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">&#x27;<span class="subst">$result</span> (in a <span class="subst">$mood</span> mood)&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(say(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Howdy&#x27;</span>) ==</span><br><span class="line">    <span class="string">&#x27;Bob says Howdy with a carrier pigeon&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>也可以使用 list 和 map 作为参数默认值：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> doStuff(</span><br><span class="line">    &#123;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">const</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; gifts = <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;paper&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;second&#x27;</span>: <span class="string">&#x27;cotton&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;third&#x27;</span>: <span class="string">&#x27;leather&#x27;</span></span><br><span class="line">    &#125;&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;list:  <span class="subst">$list</span>&#x27;</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;gifts: <span class="subst">$gifts</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="the-main-function">The main() function</h3>
<p>每个APP都必须有个顶层的 <code>main()</code> 函数作为APP的入口。<code>main()</code> 函数默认返回 <code>void</code> , 参数为可选的 <code>List&lt;String&gt;</code> 类型。</p>
<p>下面是一个 web 应用的 <code>main()</code> 函数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">querySelector</span>(<span class="string">&#x27;#sample_text_id&#x27;</span>)</span><br><span class="line">    ..text = <span class="string">&#x27;Click me&#x27;</span></span><br><span class="line">    ..onClick.listen(reverseText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面代码中的 <code>..</code> 语法称为 <a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/language-tour#cascade-notation-">cascade</a> （级联）。使用 cascade 你可以对某个对象的多个成员进行多个操作。</p>
</blockquote>
<p>下面是一个包含命令行参数的命令行程序：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run the app like this: dart args.dart 1 test</span></span><br><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; arguments) &#123;</span><br><span class="line">  <span class="built_in">print</span>(arguments);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assert</span>(arguments.length == <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">assert</span>(<span class="built_in">int</span>.parse(arguments[<span class="number">0</span>]) == <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">assert</span>(arguments[<span class="number">1</span>] == <span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以使用 <a target="_blank" rel="noopener" href="https://pub.dartlang.org/packages/args">args library</a> 来定义和解析命令行参数。</p>
<h4 id="functions-as-first-class-objects">Functions as first-class objects</h4>
<p>函数可以作为参数传递给另一个函数，比如：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> printElement(<span class="built_in">int</span> element) &#123;</span><br><span class="line">    <span class="built_in">print</span>(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 printElement 作为参数传递</span></span><br><span class="line">list.forEach(printElement);</span><br></pre></td></tr></table></figure>
<p>函数可以作为值分配给变量：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> louldify = (msg) =&gt; <span class="string">&#x27;!!! <span class="subst">$&#123;msg&#125;</span>.toUpperCase() !!!&#x27;</span>;</span><br><span class="line">louldify(<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="anonymous-functions-匿名函数">Anonymous functions 匿名函数</h4>
<p>匿名函数也可以称为 <em>lambda</em> 或 <em>closure</em>。定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">([[Type] param1[, …]]) &#123; </span><br><span class="line">  codeBlock; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>与普通函数定义相似，0个或多个参数，可选的参数累心。如果函数只有一个语句，可以简写成 <code>([[Type] param1[, …]]) =&gt; oneLineCodeBlock;</code> 。</p>
<h4 id="lexical-scope-词法范围">Lexical Scope 词法范围</h4>
<p>Dart 语言变量的作用域是静态确定的，简单的说就是由你的代码结构决定的。花括号表示变量的作用域。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> topLevel = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> insideMain = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> myFunction() &#123;</span><br><span class="line">    <span class="keyword">var</span> insideFunction = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> nestedFunction() &#123;</span><br><span class="line">      <span class="keyword">var</span> insideNestedFunction = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">assert</span>(topLevel);</span><br><span class="line">      <span class="keyword">assert</span>(insideMain);</span><br><span class="line">      <span class="keyword">assert</span>(insideFunction);</span><br><span class="line">      <span class="keyword">assert</span>(insideNestedFunction);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：最内层嵌套的函数可以访问外层的所有变量。</p>
</blockquote>
<h4 id="lexical-closure">Lexical Closure</h4>
<p>闭包可以访问他的词法范围内的变量，即使闭包在他原始访问范围外访问也可以。</p>
<h4 id="test-functions-for-equality-函数比较">Test functions for equality 函数比较</h4>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> foo() &#123;&#125;  <span class="comment">// 顶层函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> bar() &#123;&#125;    <span class="comment">// 类静态函数</span></span><br><span class="line">    <span class="keyword">void</span> baz() &#123;&#125;           <span class="comment">// 实例函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    <span class="comment">// 顶层函数比较</span></span><br><span class="line">    <span class="keyword">var</span> x = foo;</span><br><span class="line">    <span class="comment">// 同一个顶层函数，相等</span></span><br><span class="line">    <span class="keyword">assert</span>(x == foo);</span><br><span class="line">    <span class="comment">// 静态函数比较</span></span><br><span class="line">    <span class="comment">// 同一个静态函数，相等</span></span><br><span class="line">    x = A.bar;</span><br><span class="line">    <span class="keyword">assert</span>(x == A.bar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例函数比较</span></span><br><span class="line">    <span class="keyword">var</span> v = A();</span><br><span class="line">    <span class="keyword">var</span> w = A();</span><br><span class="line">    <span class="keyword">var</span> y = w;</span><br><span class="line">    x = w.baz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 都是实例w的函数，所以相等</span></span><br><span class="line">    <span class="keyword">assert</span>(y.bzd == x)</span><br><span class="line">    <span class="comment">// 非同一个实例的函数，不相等</span></span><br><span class="line">    <span class="keyword">assert</span>(v.baz != w.baz)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="return-values-返回值">Return values 返回值</h4>
<p>所有的函数都是返回值，如果代码不指定返回值，默认的 <code>return null;</code> 会被增加到函数的结尾。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo() &#123;&#125;</span><br><span class="line"><span class="keyword">assert</span>(foo() == <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<h2 id="operators-操作符">Operators 操作符</h2>
<p>Dart 的多数运算符都可以<a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/language-tour#overridable-operators">覆写</a>。</p>
<table>
<thead>
<tr class="header">
<th>描述</th>
<th style="text-align: left;">运算符</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>后缀一元运算符</td>
<td style="text-align: left;"><code>expr++ expr-- () [] . ?.</code></td>
</tr>
<tr class="even">
<td>前缀一元运算符</td>
<td style="text-align: left;"><code>-expr !expr ~expr ++expr --expr</code></td>
</tr>
<tr class="odd">
<td>乘法</td>
<td style="text-align: left;"><code>* / % ~/</code></td>
</tr>
<tr class="even">
<td>加法</td>
<td style="text-align: left;"><code>+ -</code></td>
</tr>
<tr class="odd">
<td>移位操作</td>
<td style="text-align: left;"><code>&lt;&lt; &gt;&gt;</code></td>
</tr>
<tr class="even">
<td>按位与</td>
<td style="text-align: left;"><code>&amp;</code></td>
</tr>
<tr class="odd">
<td>按位异或</td>
<td style="text-align: left;"><code>^</code></td>
</tr>
<tr class="even">
<td>按位或</td>
<td style="text-align: left;"><code>|</code></td>
</tr>
<tr class="odd">
<td>关系与类型比较</td>
<td style="text-align: left;"><code>&gt; &gt;= &lt;= &lt; as is is!</code></td>
</tr>
<tr class="even">
<td>相等性比较</td>
<td style="text-align: left;"><code>== ！=</code></td>
</tr>
<tr class="odd">
<td>逻辑与</td>
<td style="text-align: left;"><code>&amp;&amp;</code></td>
</tr>
<tr class="even">
<td>逻辑或</td>
<td style="text-align: left;"><code>||</code></td>
</tr>
<tr class="odd">
<td>if null</td>
<td style="text-align: left;"><code>??</code></td>
</tr>
<tr class="even">
<td>条件运算符</td>
<td style="text-align: left;"><code>expr1?expr2:expr3</code></td>
</tr>
<tr class="odd">
<td>cascade级联操作</td>
<td style="text-align: left;"><code>..</code></td>
</tr>
<tr class="even">
<td>赋值</td>
<td style="text-align: left;"><code>=  *=  /=  ~/=  %=  +=  -=  &lt;&lt;=  &gt;&gt;=  &amp;=  ^=</code></td>
</tr>
<tr class="odd">
<td></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<blockquote>
<p>表中上方操作符的优先级都高于下方操作符的优先级。如果运算符适用于两侧不同类型的数据，那么使用左侧数据类型的方式进行运算。</p>
</blockquote>
<h3 id="arithmetic-operators-算数运算符">Arithmetic operators 算数运算符</h3>
<table>
<thead>
<tr class="header">
<th>运算符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>+</code></td>
<td>加法</td>
</tr>
<tr class="even">
<td><code>-</code></td>
<td>减法</td>
</tr>
<tr class="odd">
<td><code>-expr</code></td>
<td>负数</td>
</tr>
<tr class="even">
<td><code>*</code></td>
<td>乘法</td>
</tr>
<tr class="odd">
<td><code>/</code></td>
<td>除法</td>
</tr>
<tr class="even">
<td><code>~/</code></td>
<td>除法，去整数结果</td>
</tr>
<tr class="odd">
<td><code>%</code></td>
<td>取模</td>
</tr>
<tr class="even">
<td><code>++var</code></td>
<td>var = var +1, 表达式的值是var+1</td>
</tr>
<tr class="odd">
<td><code>var++</code></td>
<td>var = var + 1，表达式的值是var</td>
</tr>
<tr class="even">
<td><code>--var</code></td>
<td>var = var - 1，表达式的值是var - 1</td>
</tr>
<tr class="odd">
<td><code>var--</code></td>
<td>var = var - 1, 表达式的值是var</td>
</tr>
</tbody>
</table>
<h3 id="equality-and-relational-operators-相等与关系运算符">Equality and relational operators 相等与关系运算符</h3>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>运算符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>==</code></td>
<td>用来判断两个对象是否表示同一个事物（如果操作符两边的对象都是null，返回true，其中一个是null，返回false；如果都不是null，调用x.==(y)）</td>
</tr>
<tr class="even">
<td><code>!=</code></td>
<td>不相等</td>
</tr>
<tr class="odd">
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr class="even">
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr class="odd">
<td><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr class="even">
<td><code>&lt;=</code></td>
<td>小于等于</td>
</tr>
</tbody>
</table>
<blockquote>
<p>如果判断x、y是否是同一个对象，使用 <code>identical()</code> 函数。</p>
</blockquote>
<h3 id="type-test-operators-类型检测运算符">Type test operators 类型检测运算符</h3>
<p><code>as</code>、 <code>is</code>、 <code>is!</code> 用来在运行时检查对象类型。</p>
<table>
<thead>
<tr class="header">
<th>运算符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>as</code></td>
<td>类型转换（<code>(emp as Person).firstName = 'Bob'</code>）</td>
</tr>
<tr class="even">
<td><code>as</code></td>
<td>True 如果对象是指定类型</td>
</tr>
<tr class="odd">
<td><code>is!</code></td>
<td>False如果对象是指定类型</td>
</tr>
</tbody>
</table>
<h3 id="assignment-operators-赋值运算符">Assignment operators 赋值运算符</h3>
<blockquote>
<p><code>??=</code> 是一特殊的赋值符号，只有当被赋值的变量为null的时候 才会赋值。</p>
</blockquote>
<h3 id="logical-operators">Logical operators</h3>
<table>
<thead>
<tr class="header">
<th>运算符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>!expr</code></td>
<td>非，取反</td>
</tr>
<tr class="even">
<td><code>||</code></td>
<td>逻辑或</td>
</tr>
<tr class="odd">
<td><code>&amp;&amp;</code></td>
<td>逻辑与</td>
</tr>
</tbody>
</table>
<h3 id="bitwise-and-shift-operators-位与移位操作符">Bitwise and shift operators 位与移位操作符</h3>
<table>
<thead>
<tr class="header">
<th>运算符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>&amp;</code></td>
<td>按位与</td>
</tr>
<tr class="even">
<td><code>|</code></td>
<td>按位或</td>
</tr>
<tr class="odd">
<td><code>^</code></td>
<td>按位异或</td>
</tr>
<tr class="even">
<td><code>~expr</code></td>
<td>按位取反</td>
</tr>
<tr class="odd">
<td><code>&lt;&lt;</code></td>
<td>左移，右边用0补充</td>
</tr>
<tr class="even">
<td><code>&gt;&gt;</code></td>
<td>右移，左边用0补充</td>
</tr>
</tbody>
</table>
<h3 id="conditional-expressions-条件表达式">Conditional Expressions 条件表达式</h3>
<p><code>condition ? expr1 : expr2</code>： 如果 condition 为 Ture，返回 expr1，否则返回 expr2。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> visibility = isPublic ? <span class="string">&#x27;public&#x27;</span>: private;</span><br></pre></td></tr></table></figure>
<p><code>expr1 ?? expr2</code>： 如果 expr1 非null，返回 expr1，否则返回 expr2 。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> playerName(<span class="built_in">String</span> name) =&gt; name ?? <span class="string">&#x27;Guest&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="cascade-notation-级联操作">Cascade notation (级联操作)</h3>
<p><code>..</code> 级联操作符允许开发者对同一个对象进项一系列操作，不仅仅可以调用对象的函数，还可以直接访问对象的数据成员。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> addressBook = (AddressBookBuilder()</span><br><span class="line">      ..name = <span class="string">&#x27;jenny&#x27;</span></span><br><span class="line">      ..email = <span class="string">&#x27;jenny@example.com&#x27;</span></span><br><span class="line">      ..phone = (PhoneNumberBuilder()</span><br><span class="line">            ..number = <span class="string">&#x27;415-555-0100&#x27;</span></span><br><span class="line">            ..label = <span class="string">&#x27;home&#x27;</span>)</span><br><span class="line">          .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<h3 id="other-operators-其他运算符">Other Operators 其他运算符</h3>
<table>
<thead>
<tr class="header">
<th>运算符</th>
<th>名字</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>()</code></td>
<td>函数调用</td>
<td>表示一个函数调用</td>
</tr>
<tr class="even">
<td><code>[]</code></td>
<td>列表访问</td>
<td>列表中指定下标的元素的值</td>
</tr>
<tr class="odd">
<td><code>.</code></td>
<td>成员访问</td>
<td>访问表达试的属性</td>
</tr>
<tr class="even">
<td><code>?.</code></td>
<td>条件成员访问</td>
<td>与 <code>.</code> 类似，当时左边的表达式可以为null</td>
</tr>
</tbody>
</table>
<h2 id="control-flow-statements-控制流语句">Control flow statements 控制流语句</h2>
<h3 id="if-and-else">If and else</h3>
<p>略。</p>
<h3 id="for-loops-for-循环">For loops For 循环</h3>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>Iterable</code> 类型的对象，可以使用 <code>forEach()</code> 函数遍历。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condidates.forEach((candidate) =&gt; candidate.interview())</span><br></pre></td></tr></table></figure>
<p>Iterable 类也支持 <code>for-in</code> 循环。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> collection = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">in</span> collection) &#123;</span><br><span class="line">    <span class="built_in">print</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="while-and-do-while-while-循环">While and do-while while 循环</h3>
<p><code>while</code>循环在循环开始前评估循环的条件。 <code>do-while</code> 循环在一次循环结束后评估循环的条件。</p>
<h3 id="break-and-continue-语句">Break and continue 语句</h3>
<p>使用 <code>break</code> 来停止循环，使用 <code>continue</code> 来跳过循环之后的语句，继续下一个循环。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">candidates</span><br><span class="line">    .where((c) =&gt; c.yearsExperience &gt;= 5)</span><br><span class="line">        .forEach((c) =&gt; c.interview());</span><br></pre></td></tr></table></figure></p>
<h3 id="switch-and-case-语句">Switch and case 语句</h3>
<p>Dart 中的 switch 语句可以应用于整数、字符创、或对象编译时常量（使用 == 来比较，类不能覆写 == 函数）。每个非空的 case 语句都必须包含 break 结尾，或者用contine、return、throw 来结束case，否则编译报错。 对于空 case，执行其下边的case代码（译注：类似java）。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> command = <span class="string">&#x27;CLOSED&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span> (command) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;CLOSED&#x27;</span>:</span><br><span class="line">      executeClosed();</span><br><span class="line">      <span class="keyword">continue</span> nowClosed;</span><br><span class="line">        <span class="comment">// Continues executing at the nowClosed label.</span></span><br><span class="line"></span><br><span class="line">  nowClosed:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;NOW_CLOSED&#x27;</span>:</span><br><span class="line">    <span class="comment">// Runs for both CLOSED and NOW_CLOSED.</span></span><br><span class="line">    executeNowClosed();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure> ### Assert 断言 使用 <code>assert(condition)</code> 来中断正常执行的代码流程，在 <code>condition</code> 为 False 的时候中断正常流程，抛出 <code>AssertionError</code> 异常。 &gt; assert 语句在生产代码中是无效的,在 dart 和 dart2js 命令中增加 <code>--enable-asserts</code> 来启用 assert 。</p>
<h2 id="exceptions-异常">Exceptions 异常</h2>
<p>Dart 可以抛出和捕获异常，如果异常不被捕获，抛出异常的代码会被暂停，通常它所在的进程会被终止。 与 Java 不同，Dart 不要求函数声明抛出异常，也不要求调用者捕获函数可能抛出的异常。Dart 提供了 <code>Exception</code> 和 <code>Error</code> 两种异常类型，同时也支持抛出任意非null对象作为异常。</p>
<h3 id="throw">Throw</h3>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> FormatException(<span class="string">&#x27;Expected at least 1 section&#x27;</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&#x27;Out of llamas&#x27;</span>;</span><br><span class="line"><span class="keyword">void</span> distanceTo(Point other) =&gt; <span class="keyword">throw</span> UnimplementedError();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>通常代码都将 <code>Exception</code> 或 <code>Error</code> 的子类作为异常抛出。</p>
</blockquote>
<h3 id="catch">Catch</h3>
<p>捕获异常可以阻止异常继续传播，给开发者一个处理异常的机会。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breeMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">on</span> OutOfLlamasException&#123;</span><br><span class="line">  buyMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">on</span> Exception <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Exception details:\n<span class="subst">$e</span>&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e, s) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Exception details:\n<span class="subst">$e</span>&#x27;</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;StackTrace:\n<span class="subst">$s</span>&#x27;</span>);</span><br><span class="line">  <span class="comment">// 抛出异常给调用者</span></span><br><span class="line">  <span class="keyword">rethrow</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="finally">Finally</h3>
<p>保证无论是否抛出异常，<code>finally</code> 中的代码的代码都会执行。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Error: <span class="subst">$e</span>&#x27;</span>); <span class="comment">// Handle the exception first.</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  cleanLlamaStalls(); <span class="comment">// Then clean up.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="classes-类">Classes 类</h2>
<p>Dart 是面向对象的语言，同时支持混合继承。所有的对象都是某个类的实例，所有的类都继承自 <code>Object</code> 。混合继承的意思是虽然每个类都只有一个直接的父类，但是一个类可以在多个继承中使用。</p>
<h3 id="using-class-memebers-使用类成员">Using class memebers 使用类成员</h3>
<p>对象包含数据和函数成员，使用 <code>.</code> 来访问对象成员，使用 <code>?.</code> 来避免对象空指针的问题。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">p.y = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">assert</span>(p.y == <span class="number">3</span>);</span><br><span class="line"><span class="built_in">num</span> distance = p.distanceTo(Point(<span class="number">4</span>, <span class="number">4</span>));</span><br><span class="line">p.y? = <span class="number">4</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="using-constructors-构造函数">Using constructors 构造函数</h3>
<p>构造函数的名称可以是 <code>ClassName</code> 也可以是其他函数。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new 关键字是可选的</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point.fromJson(&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure> 为了创建编译时常量，有些类提供了常量构造函数，在调用构造函数之前增加 <code>const</code> 关键字就可以创建编译时常量了。</p>
<p>构造两个相同的编译时常量，编译器只会生成一个实例，两个常量引用这同一个实例。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> c = ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">assert</span>(identical(a, b)); <span class="comment">// a b 是同一个实例</span></span><br><span class="line"><span class="keyword">assert</span>(!identical(<span class="number">1</span>, c)); <span class="comment">// a c不是同一个实例</span></span><br></pre></td></tr></table></figure></p>
<p>在同一个 <code>const</code> 作用域范围内所有变量都是 <code>const</code> 的，不需要挨个指定。</p>
<h3 id="getting-an-objects-type-获取对象类型">Getting an object's type 获取对象类型</h3>
<p>使用对象的 <code>runtimeType</code> 属性在获取运行时获取对象的类型， 它返回一个 <code>Type</code> 类型的对象。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The type of a is <span class="subst">$&#123;a.runtimeType&#125;</span>&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="instance-variables-实例变量">Instance variables 实例变量</h3>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;    <span class="comment">// 声明实例变量，默认初始未 null</span></span><br><span class="line">  <span class="built_in">num</span> y;    <span class="comment">// 声明y，初始为 null</span></span><br><span class="line">  <span class="built_in">num</span> z = <span class="number">0</span>; <span class="comment">// 声明z，初始为 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有未初始化的数据成员为null。所有非 final 的数据成员会被默认创建 getter/setter函数。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> point = Point();</span><br><span class="line">  point.x = <span class="number">4</span>;              <span class="comment">// 使用setter函数设置x的值</span></span><br><span class="line">  <span class="keyword">assert</span>(point.x == <span class="number">4</span>);     <span class="comment">// 使用getter函数获取x的值</span></span><br><span class="line">  <span class="keyword">assert</span>(point.y == <span class="keyword">null</span>);  <span class="comment">// 默认值为 null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="constructors-构造函数">Constructors 构造函数</h3>
<p>默认使用与类型名字相同的函数作为构造函数，Dart 中构造函数是不被继承的，如果子类没有生命构造函数，它只有一个无参的默认构造函数，所有成员都是默认值。</p>
<h4 id="named-constructors-命名构造函数">Named constructors 命名构造函数</h4>
<p>使用命名的构造函数来实现多个构造函数，使代码更清晰： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 命名构造函数</span></span><br><span class="line">  Point.origin() &#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 子类如果想用父类的命名构造函数，也必须实现它。</p>
<h4 id="involing-a-non-default-superclass-constructor-调用父类非默认构造函数">Involing a non-default superclass constructor 调用父类非默认构造函数</h4>
<p>默认子类调用父类非命名无参构造函数。子类也可以在构造函数的开始调用父类的构造函数。如果指定初始化列表，初始化列表会在父类构造函数之前执行，构造函数的执行顺序如下： 1. 初始化列表 2. 父类的无参数构造函数 3. 主类的无参构造函数</p>
<p>如果父类没有无参非命名构造函数，开发者必须手动调用父类的构造函数，使用 <code>:</code> 在构造函数体之前指定父类构造函数。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> firstName;</span><br><span class="line"></span><br><span class="line">  Person.fromJson(<span class="built_in">Map</span> data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;in Person&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用父类指定构造函数</span></span><br><span class="line">  Employee.formJson(<span class="built_in">Map</span> data): <span class="keyword">super</span>.fromJson(data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;in Employee&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> emp = <span class="keyword">new</span> Employee.fromJson(&#123;&#125;);</span><br><span class="line">  <span class="keyword">if</span> (emp <span class="keyword">is</span> Person) &#123;</span><br><span class="line">    emp.firstName = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  (emp <span class="keyword">as</span> Person).firstName = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="initializer-list-初始化列表">Initializer list 初始化列表</h4>
<p>可以在初始化列表中初始化成员变量，在运行构造函数前初始化实例初始化成员，使用逗号分隔列表。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">num</span>&gt; json) : x = json[<span class="string">&#x27;x&#x27;</span>], y = json[<span class="string">&#x27;y&#x27;</span>] &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;In Point.fromJson(): (<span class="subst">$x</span>, <span class="subst">$y</span>)&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在初始化 <code>final</code> 数据成员的时候初始化列表格外有用。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:math&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> y;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> distanceFromOrigin;</span><br><span class="line"></span><br><span class="line">  Point(x, y) : x = x, y = y, distanceFromOrigin = sqrt(x * x + y * y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">print</span>(p.distanceFromOrigin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="redirecting-constructors-重定向构造函数">Redirecting constructors 重定向构造函数</h5>
<p>有时某些构造函数的作用就是调用其他构造函数。重定向构造函数的函数体是空的，使用 <code>:</code> 分隔。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"> <span class="built_in">num</span> x, y;</span><br><span class="line"> <span class="comment">// the main constructor</span></span><br><span class="line"> Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line"> Point.alongXAxis(<span class="built_in">num</span> x): <span class="keyword">this</span>(x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="constant-constructors-常量构造函数">Constant constructors 常量构造函数</h4>
<p>使用 <code>const</code> 构造函数来创建编译时常量，并且其中所有成员变量都是 <code>final</code> 类型的。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutablePoint</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ImmutablePoint origin = </span><br><span class="line">    <span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ImmutablePoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> &gt; 常量构造函数并非每次都创建常量。</p>
<h4 id="factory-constructors-工厂构造函数">Factory constructors 工厂构造函数</h4>
<p>使用 <code>factory</code> 关键字来实现工厂构造函数，工厂构造函数不需要每次都创建新的对象，比如它可以从cache中返回一个重用的对象或者返回一个子类的对象。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line"> <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line"> <span class="built_in">bool</span> mute = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 使用 _ 使成员变量编程私有成员</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>(<span class="built_in">String</span>, Logger) _cache =</span><br><span class="line">    &lt;<span class="built_in">String</span>, Logger&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Logger(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_cache.containsKey(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> _cache[name];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> logger = Logger._internal(name) &#123;</span><br><span class="line">        _cache[name] = logger;</span><br><span class="line">        <span class="keyword">return</span> logger;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Logger._internal(<span class="keyword">this</span>.name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> log(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mute) <span class="built_in">print</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> &gt; 工厂构造函数没有权限访问 <code>this</code> 。 工厂构造函数的使用与普通构造函数的使用一致。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = Logger(<span class="string">&#x27;UI&#x27;</span>);</span><br><span class="line">logger.log(<span class="string">&#x27;Button clicked&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="methonds-函数">Methonds 函数</h3>
<h4 id="instance-methods-实例函数">Instance methods 实例函数</h4>
<p>实例函数可以访问类的成员变量和 <code>this</code> 。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:math&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="built_in">num</span> x, y;</span><br><span class="line">    Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">num</span> distanceTo(Point other) &#123;</span><br><span class="line">        <span class="keyword">var</span> dx = x - other.x;</span><br><span class="line">        <span class="keyword">var</span> dy = y - other.y;</span><br><span class="line">        <span class="keyword">return</span> sqrt(dx * dx + dy * dy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="getters-and-setters">Getters and setters</h4>
<p>Getter 和 Setter 提供了对类成员读写的方式，你也可以使用 <code>get</code> 和 <code>set</code> 关键词实现自定义的 <code>getter</code> 和 <code>setter</code> 。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> left, top, width, height;</span><br><span class="line"></span><br><span class="line">  Rectangle(<span class="keyword">this</span>.lest, <span class="keyword">this</span>.top, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> right =&gt; left + width;</span><br><span class="line">  <span class="keyword">set</span> right(<span class="built_in">num</span> value) =&gt; left = value - width;</span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> bottom =&gt; top + height;</span><br><span class="line">  <span class="keyword">set</span> bottom(<span class="built_in">num</span> value) =&gt; top = value - height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> rec = Rectangle(<span class="number">3</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">15</span>);</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">3</span>);</span><br><span class="line">  rect.right = <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 你可以在初始的时候使用实例变量，如果之后改成函数的实现方式，你就不需要修改客户端的代码而直接使用了。 &gt; 无论是否明确定义了 <code>getter</code> 函数，运算符都可以按照预期工作。为了避免任何非预期的副作用，运算符都只调用 <code>getter</code> 一次，然后把值存在临时变量中。</p>
<h4 id="abstract-methods">Abstract methods</h4>
<p>Instance、getter 和 setter 方法都可以是抽象方法，定义好接口，然后把接口的实现留给其他类来做。只有抽象类才能包含抽象方法。</p>
<p>只要在函数体除使用分号（;）就可以定义抽象方法了。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// abstract method</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> doSomething();  <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EffectiveDoer</span> <span class="keyword">extends</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">    <span class="comment">// 在此具体实现此函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="abstract-classes">Abstract classes</h4>
<p>使用 <code>abstract</code> 来定义不能实例化的抽象类。抽象类主要用来定义接口，通常会包含某些实现。如果你希望抽象类可以被实例化，那么你可以定义一个工厂构造函数(<a target="_blank" rel="noopener" href="https://dart.dev/guides/language/language-tour#factory-constructors">FactoryConstructor</a>)。</p>
<p>抽闲类通常包含抽象方法，例如： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明为抽象类，无法实例化的类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractContainer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="implicit-interface">Implicit Interface</h4>
<p>每个类都是一个包含了它所有实例成员和它实现的接口的隐式接口（译注：每个class都是一个interface，都可以被其他类implement）。如果你想创建一个类A，并让类A支持类B的 API，但又不想让A继承B，那么A应该实现（implement）B。</p>
<p>类可以通过 <code>implements</code> 语句来实现一个或多个接口，然后实现接口的方法，比如： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person 的类定义，隐含了接口 greet()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 包含在接口中，但是只对此类可见</span></span><br><span class="line">  <span class="keyword">final</span> _name;</span><br><span class="line">  <span class="comment">// 不包含在接口中，因为这是构造方法</span></span><br><span class="line">  Person(<span class="keyword">this</span>._name);</span><br><span class="line">  <span class="comment">// 包含在接口中</span></span><br><span class="line">  <span class="built_in">String</span> greet(<span class="built_in">String</span> who) =&gt; <span class="string">&#x27;Hello <span class="subst">$who</span>. I am <span class="subst">$_name</span>&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现了 Person 接口的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Impostor</span> <span class="keyword">implements</span> <span class="title">Persion</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> _name =&gt; <span class="string">&#x27;&#x27;</span>; <span class="comment">// 注意这，实现了 _name 接口</span></span><br><span class="line">  <span class="built_in">String</span> greet(<span class="built_in">String</span> who) =&gt; <span class="string">&#x27;Hi, <span class="subst">$who</span>. Do you know who I am?&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> greetBob(Person person) =&gt; person.greet(<span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(greetBob(Persion(<span class="string">&#x27;Kathy&#x27;</span>)));</span><br><span class="line">  <span class="built_in">print</span>(greetBob(Impostor()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> &gt; 译注： 上边代码输出如下： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, Bob. I am Kathy</span><br><span class="line">Hello, Bob. Do you know who I am ?</span><br></pre></td></tr></table></figure> 下边是实现多个接口的例子： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">implements</span> <span class="title">Comparable</span>, <span class="title">Location</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="extending-a-class">Extending a class</h4>
<p>使用 <code>extends</code> 关键字来实现类的继承， <code>super</code> 来引用父类。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    _illuminateDisplay();</span><br><span class="line">    _activateIrSensor();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartTelevision</span> <span class="keyword">extends</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    <span class="keyword">super</span>.turnOn();</span><br><span class="line">    _bootNetworkInterface();</span><br><span class="line">    _initializeMemory();</span><br><span class="line">    _upgradeApps();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="overriding-members">Overriding members</h4>
<p>子类可以覆写实例方法、getter 和 setter。使用 <code>@override</code> 标注来标识你是故意覆写一个成员方法： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartTelevision</span> <span class="keyword">extends</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;...&#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> To narrow the type of a method parameter or instance variable in code that is type safe, you can use the covariant keyword.（译注：暂时没看懂啥意思，明白了再来翻译）</p>
<h4 id="overridable-operators">Overridable operators</h4>
<p>以下运算符可以覆写： | &lt; | + | ^ | [] | |----|----|----|----| | &gt; | / | | | []=| | &lt;= | ~/ | &amp; | ~ | | &gt;= | * | &lt;&lt; | == | | - | % | &gt;&gt; | | &gt; 注意：<code>!=</code> 不是可覆写的运算符，因为 <code>e1 != e2</code> 只是 <code>!(e1 == e2)</code> 的语法糖。</p>
<p>下边的例子覆写了 <code>+ -</code> 两个运算符： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> x, y;</span><br><span class="line">  Vector(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">  Vector <span class="keyword">operator</span> +(Vector v) =&gt; Vector(x + v.x, y + v.y);</span><br><span class="line">  Vector <span class="keyword">operator</span> -(Vector v) =&gt; Vector(x - v.x, y - v.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> v = Vector(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">final</span> w = Vector(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assert</span>(v + w == Vector(<span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">  <span class="keyword">assert</span>(v - w == Vector(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 如果你覆写了 <code>==</code>，你需要同时覆写它的 <code>hashCode</code> getter，参考<a target="_blank" rel="noopener" href="https://dart.dev/guides/libraries/library-tour#implementing-map-keys">Implementing map keys</a> 和 <a target="_blank" rel="noopener" href="https://dart.dev/guides/language/language-tour#extending-a-class">Extending a class</a></p>
<h4 id="nosuchmethod">noSuchMethod()</h4>
<p>问了检测和响应代码对不存在的方法和数据成员的调用，你可以覆写 <code>noSuhMethod()</code> 方法： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果不覆写 noSuchMethod 方法，调用不存在的类成员会导致 NoSuchMethodError。</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> noSuchMethod(Invocation invocation) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;You tried to use a non-existing member:&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;<span class="subst">$&#123;invoation.memberName&#125;</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 除下列情况外，你是无法调用不存在的方法的： - 调用 <code>dynamic</code> 类型实例的方法 - 调用确定类型实例的未实现方法（比如抽象类的方法），并且实例的动态类型自己实现了 <code>noSuchMethod</code> 方法（译注：这句话有点绕，个人理解，比如你继承了一个抽象类，被继承的抽象类实现了 <code>noSuchMethod</code> 方法）。</p>
<p>更多信息参考 <a target="_blank" rel="noopener" href="https://github.com/dart-lang/sdk/blob/master/docs/language/informal/nosuchmethod-forwarding.md">noSuchMethod forwarding specification</a>。</p>
<h4 id="extension-methods">Extension methods</h4>
<p>扩展方法是 Dart2.7 引入的新特性，是向已有库中增加功能的一种方法。在不知情的情况下，你看能已经使用了扩展方法。比如在你使用IDE编写代码的时候，它会不区分常规方法和扩展方法给你代码提示。</p>
<p>下边的例子，使用了 <code>string_api.dart</code> 中扩展的 <code>String</code> 类的 <code>parseInt</code> 方法。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;string_api.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;42&#x27;</span>.padLeft(<span class="number">5</span>));</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;42&#x27;</span>.parseInt());</span><br></pre></td></tr></table></figure> 关于扩展方法的使用与实现方式，参考 <a target="_blank" rel="noopener" href="https://dart.dev/guides/language/extension-methods">extension methods page</a>。</p>
<h4 id="enumerated-types">Enumerated types</h4>
<p>枚举类型是特别的类，是用来表示一组固定常量。</p>
<h5 id="using-enums">Using enums</h5>
<p>使用 <code>enum</code> 关键字来声明枚举类型： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;red, green, blue&#125;</span><br></pre></td></tr></table></figure> &gt; 译注：注意上边Color的定义，必须在代码的顶层，并且代码没有以分号结束。</p>
<p>枚举中的每个值都包含一个叫 <code>index</code> 的 getter，它会返回枚举中定义的的这个值的下标（从0开始）： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(Color.red.index == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">assert</span>(Color.green.index == <span class="number">1</span>);</span><br><span class="line"><span class="keyword">assert</span>(Color.blue.index == <span class="number">2</span>);</span><br></pre></td></tr></table></figure> 使用枚举的 <code>values</code> 常量来获取枚举中定义的所有值： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;Color&gt; colors = Color.values;</span><br><span class="line"><span class="keyword">assert</span>(colors[<span class="number">2</span>] == Color.blue);</span><br></pre></td></tr></table></figure> 枚举值可以用作 switch 语句的 case 值，你必须处理枚举中的所有值，否则会产生一个警告： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aColor = Color.blue;</span><br><span class="line"><span class="keyword">switch</span> (aColor) &#123;</span><br><span class="line">  <span class="keyword">case</span> Color.red:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Red as roses&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Color.green:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Green as grass&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 没有此语句会产生警告</span></span><br><span class="line">    <span class="built_in">print</span>(aColor); <span class="comment">// 打印 Color.blue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 枚举值有以下限制： - 不能继承、实现、mix in 枚举类型 - 不能显示的实例化枚举类型</p>
<p>详细信息参考 <a target="_blank" rel="noopener" href="https://dart.dev/guides/language/spec">Dart language specification</a>。</p>
<h4 id="adding-features-to-a-class-mixins">Adding features to a class: mixins</h4>
<p>Mixin是在多继承中复用代码的一种方式。 使用 <code>with</code> 关键字后面跟一个或多个 mixin 类型： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Musician</span> <span class="keyword">extends</span> <span class="title">Performer</span> <span class="title">with</span> <span class="title">Musical</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Maestro</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="title">with</span> <span class="title">Musical</span>, <span class="title">Aggressive</span>, <span class="title">Demented</span> </span>&#123;</span><br><span class="line">  Maestro(<span class="built_in">String</span> maestroName) &#123;</span><br><span class="line">    name = meastroName;</span><br><span class="line">    canConduct = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 为了实现一个 <em>mixin</em> 类型，你只要创建一个继承字 <code>Object</code> 的类并且不要声明构造方法即可。除非你希望 <em>mixin</em> 可以被当做普通的类来使用，否则都用 <code>mixin</code> 关键字代替 <code>class</code> 关键字既可: <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> Musical &#123;</span><br><span class="line">  <span class="built_in">bool</span> canPlayPiano = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canCompose = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canConduct = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">void</span> entertainMe() &#123;</span><br><span class="line">    <span class="keyword">if</span> (canPlayPiano) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;Playing piano&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (canConduct) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;Waving hands&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(Humming to self<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure> 为了限制mixin的使用范围，你可以使用 <code>on</code> 关键字来指定可以使用它的类，这样这个mixin就可以调用它没有定义的方法了。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> MusicalPerformer <span class="keyword">on</span> Musican &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="class-variables-and-methods">Class variables and methods</h4>
<p>使用 <code>static</code> 关键字来定义类变量和方法。</p>
<h5 id="static-variables">Static variables</h5>
<p>静态变量（类变量）适用于类型级别的状态和常量： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> initialCapacity = <span class="number">16</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(Queue.initialCapacity == <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 静态变量只有在使用的时候才会初始化。</p>
<h5 id="static-methods">Static methods</h5>
<p>静态方法（类方法）不能使用 <code>this</code> ，所以不能操作自己的实例成员。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:math&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">num</span> distanceBetween(Point a, Point b) &#123;</span><br><span class="line">    <span class="keyword">var</span> dx = a.x - b.x;</span><br><span class="line">    <span class="keyword">var</span> dy = a.y - b.y;</span><br><span class="line">    <span class="keyword">return</span> sqrt(dx * dx + dy * dy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> a = Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> b = Point(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">var</span> distance = Point.distanceBetween(a, b);</span><br><span class="line">  <span class="keyword">assert</span>(<span class="number">2.8</span> &lt; distance &amp;&amp; distance &lt; <span class="number">2.9</span>);</span><br><span class="line">  <span class="built_in">print</span>(distance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 你可以使用静态方法作为编译时常量。比如可以把静态方法作为常量构造函数的参数。</p>
<h2 id="generics">Generics</h2>
<p>如果你看过API文档中基本类型的定义，<code>List</code> 的定义是 <code>List&lt;E&gt;</code> , &lt;&gt; 符号将 List 标记为泛型，也就是包含类型参数的类型。根据惯例，多数的泛型使用单个字母作为类型名字，比如 E、T、S、K、V。</p>
<h3 id="why-use-generics">Why use generics？</h3>
<p>通常使用泛型是为了保证类型安全，除此外，还有以下益处： - 恰当明确的泛型有益于更好的代码质量 - 减少代码的重复</p>
<p>如果你只项想创建包含字符串类型的列表,那么你应该声明一个 <code>List&lt;String&gt;</code> 类型的列表。这样，你自己、你的同事和代码工具在你尝试分配非字符串类型给列表的时候可以发现这可能是一个错误： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([<span class="string">&#x27;Seth&#x27;</span>, <span class="string">&#x27;Kathy&#x27;</span>, <span class="string">&#x27;Lars&#x27;</span>]);</span><br><span class="line">names.add(<span class="number">42</span>);  <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure> 使用泛型的另一个原因是减少代码的重复。泛型可以让你在不影响使用代码静态分析工具的情况下，在多种不同类型之间共享同样的接口和接口实现，比如下边这个缓存的工具： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectCache</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span> getByKey(<span class="built_in">String</span> key);</span><br><span class="line">  <span class="keyword">void</span> setByKey(<span class="built_in">String</span> key, <span class="built_in">Object</span> value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 后来你发现需要上边接口的字符串版本，你可以创建另一个接口： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StringCache</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> getByKey(<span class="built_in">String</span> key);</span><br><span class="line">  <span class="keyword">void</span> setByKey(<span class="built_in">String</span> key, <span class="built_in">String</span> value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 过了一段时间，你发现你需要个数字类型的缓存版本。。。 使用泛型可以帮你省去每个需求都重新写代码的麻烦了。你只要创建同一个接口，并且接受类型参数即可： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  T getByKey(<span class="built_in">String</span> key);</span><br><span class="line">  <span class="keyword">void</span> setByKey(<span class="built_in">String</span> key, T value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在上边的代码中，T 只是一个类型的占位符。你可以认为他是你以后使用到的任何类型。</p>
<h3 id="using-collection-literals">Using collection literals</h3>
<p>列表、集合、映射类型的都可以使用泛型。类型参数化的常量就和和见过的其他常量一样，除了增加了 <code>&lt;type&gt;</code>(list、set) 、 <code>&lt;keyType, valueType&gt;</code> (map) 以外: <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;Seth&#x27;</span>, <span class="string">&#x27;Kathy&#x27;</span>, <span class="string">&#x27;Lars&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> uniqueNames = &lt;<span class="built_in">String</span>&gt;&#123;<span class="string">&#x27;Seth&#x27;</span>, <span class="string">&#x27;Kathy&#x27;</span>, <span class="string">&#x27;Lars&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> pages = &lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&#123;</span><br><span class="line">  <span class="string">&#x27;index.html&#x27;</span>:<span class="string">&#x27;HomePage&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;robots.txt&#x27;</span>:<span class="string">&#x27;Hits for web robots&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;humans.txt&#x27;</span>:<span class="string">&#x27;We are people, not machines&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### Using parameterized types with constructors To specify one or more types when using a constructor, put the types in angle brackets (&lt;...&gt;) just after the class name. For example: <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nameSet = <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt;.from(names);</span><br><span class="line"><span class="keyword">var</span> views = <span class="built_in">Map</span>&lt;<span class="built_in">int</span>, View&gt;();</span><br></pre></td></tr></table></figure></p>
<h3 id="generic-collections-and-the-types-they-contain">Generic collections and the types they contain</h3>
<p>Dart 的泛型是<em>具体的</em>(<em>reified</em>)，这意味着在运行时保存着它的类型信息。比如，你可以检测集合的类型： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([<span class="string">&#x27;Seth&#x27;</span>, <span class="string">&#x27;Kathy&#x27;</span>, <span class="string">&#x27;Lars&#x27;</span>]);</span><br><span class="line"><span class="built_in">print</span>(names <span class="keyword">is</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;); <span class="comment">// true</span></span><br></pre></td></tr></table></figure> &gt; 相反的，Java 中使用类型擦除，泛型的类型参数在运行时是不存在的。在 Java 中你可以确定一个对象是不是 List，但不能检测他是不是 <code>List&lt;String&gt;</code>。</p>
<h3 id="restricting-the-parameterized-type">Restricting the parameterized type</h3>
<p>在实现泛型类的时，你看能需要限制类型，你可以用 <code>extends</code> 来实现： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SomeBaseClass</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> toString() =&gt; <span class="string">&quot;Instace of &#x27;Foo&lt;<span class="subst">$T</span>&gt;&#x27;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extender</span> <span class="keyword">extends</span> <span class="title">SomeBaseClass</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 可以这样使用</span></span><br><span class="line"><span class="keyword">var</span> someBaseClassFoo = Foo&lt;SomeBaseClass&gt;();</span><br><span class="line"><span class="keyword">var</span> extenderFoo = Foo&lt;Extender&gt;();</span><br><span class="line"><span class="comment">// 你也可以不指定类型参数，使用默认类型</span></span><br><span class="line"><span class="keyword">var</span> foo = Foo();</span><br><span class="line"><span class="built_in">print</span>(foo);  <span class="comment">// Foo&lt;SomeBaseClass&gt; 的实例</span></span><br><span class="line"><span class="keyword">var</span> foo = Foo&lt;<span class="built_in">Object</span>&gt;();  <span class="comment">// 指定非 SomeBaseClass 的类型参数会引起错误</span></span><br></pre></td></tr></table></figure></p>
<h3 id="using-generic-methods">Using generic methods</h3>
<p>最开始，Dart 对泛型的支持仅限于泛型类。之后才加入了泛型方法，允许类型参数的方法和函数： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T first&lt;T&gt;(<span class="built_in">List</span>&lt;T&gt; ts) &#123;</span><br><span class="line">  T tmp = ts[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>泛型参数你可以用在多个地方： - 函数的返回类型（<code>T</code>） - 参数的类型(<code>List&lt;T&gt;</code>) - 局部变量的类型(<code>T tmp</code>)</p>
<h2 id="libraries-and-visibility">Libraries and visibility</h2>
<p><code>import</code> 和 <code>library</code> 指令可以帮你创建模块化可共享的代码。库不仅仅可以提供 API，而且还是一个隐私单元（a unit of privacy）:以下杠开头的标识符都只在库内可见。及时没有使用 <code>library</code> 指令，每个 Dart 应用程序也都是一个库。</p>
<p>库（Library） 可是通过 <a target="_blank" rel="noopener" href="https://dart.dev/guides/packages">package</a> 分发出去。</p>
<h3 id="using-libraries">Using libraries</h3>
<p>使用 <code>import</code> 来在一个库中指定如果使用另一个库中的命名空间。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:html&#x27;</span>;</span><br></pre></td></tr></table></figure> <code>import</code> 只需要一个地址来确定使用的库。对于 Dart 内置的库，库地址的 scheme 是 <code>dart:</code>。对于其他库，你可以使用文件系统中路径或 <code>package:</code> 来指定。<code>package:</code> 用来指定包管理器（比如 pub 工具）提供的库： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> package:test/test.dart;</span><br></pre></td></tr></table></figure></p>
<h4 id="specifying-a-library-prefix">Specifying a library prefix</h4>
<p>如果你引入的两个包命名有冲突，那么你可以未其中一个或两个库都指定前缀。比如，library1 和 library2 都包含名为 Element 的类，那么你可以这样写代码： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib1/lib1.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib2/lib2.darr&#x27;</span> <span class="keyword">as</span> lib2;</span><br><span class="line"><span class="comment">// 使用 lib1 中的 Element</span></span><br><span class="line"><span class="built_in">Element</span> element1 = <span class="built_in">Element</span>();</span><br><span class="line"><span class="comment">// 使用 lib2 中的 Element</span></span><br><span class="line">lib2.<span class="built_in">Element</span> element2 = lib2.<span class="built_in">Element</span>();</span><br></pre></td></tr></table></figure></p>
<h4 id="importing-only-part-of-a-library">Importing only part of a library</h4>
<p>如果你只想使用某个库的一部分，你可以有选择性的导入库： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只导入 foo。</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib1/lib1.dart&#x27;</span> <span class="keyword">show</span> foo;</span><br><span class="line"><span class="comment">// 导出 foo 以外的其他所有内容</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib2/lib2.dart&#x27;</span> <span class="keyword">hide</span> foo;</span><br></pre></td></tr></table></figure></p>
<h4 id="lazily-loading-library">Lazily loading library</h4>
<p>延迟加载（懒加载） 使网页应用在需要的时候按需加载库。你可能在以下情况下使用延迟加载： - 降低网页初始的启动时间 - 执行 A/B 测试，比如测试对比同一个算法的不同实现方式 - 载入极少使用的功能，比如设置页面和对话框</p>
<blockquote>
<p>注意，只有 dart2js 支持延迟加载</p>
</blockquote>
<p>使用 <code>deferred as</code> 来指定延迟加载的库，然后在需要使用这个库的时候，调用他的 <code>loadLibrary()</code>方法： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> `package:greetings/hello.dart` deffered <span class="keyword">as</span> hello;</span><br><span class="line"></span><br><span class="line">Future greet)() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> hello.loadLibrary();</span><br><span class="line">  hello.printGreeting();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 上边的代码中， <code>await</code> 关键字暂停了代码的执行，直到库加载完毕。关于 <code>await</code> 和 <code>async</code> 的更多信息，参考 <a target="_blank" rel="noopener" href="https://dart.dev/guides/language/language-tour#asynchrony-support">asynchrony</a> 。 你可以多次调用同一个库 <code>loadLibrary()</code>,这个库只会载入一次。 记住以下几条： - 延迟加载的库中的常量在导入的文件中不是常量，只有库载入了之后才会存在这些常量 - 在导入文件中，不能使用延迟加载的库中的数据类型。你可以把接口类型定义放到两个库都需要导入的第三个库中。 - Dart 会隐式的向你使用 <code>deferrred as namespace</code> 的namespace 中插入 <code>loadLibrary()</code> 方法。<code>loadLibrary()</code> 方法返回 <a target="_blank" rel="noopener" href="https://dart.dev/guides/libraries/library-tour#future">Future</a> 对象。</p>
<h3 id="implementing-libraries">Implementing libraries</h3>
<p>关于如何创建库，参考<a target="_blank" rel="noopener" href="https://dart.dev/guides/libraries/create-library-packages">Create Library Packages</a>,内容包括： - 库中源码的组织结构 - 如何使用 <code>export</code> 指令 - 何时使用 <code>part</code> 指令 - 何时使用 <code>library</code> 指令 - 如何使用条件导出和导入从而实现跨平台的库</p>
<h2 id="asynchrony-support">Asynchrony support</h2>
<p>Dart 的库中有无数的函数返回 <a target="_blank" rel="noopener" href="https://api.dart.dev/stable/dart-async/Future-class.html">Future</a> 或 <a target="_blank" rel="noopener" href="https://api.dart.dev/stable/dart-async/Stream-class.html">Stream</a> 类型的对象。这些函数都是 <em>异步的</em>。这些函数可能执行一些消耗时间的操作（比如 I/O 操作），但不用等到操作结束才返回。</p>
<p><code>async</code> 和 <code>await</code> 关键词支持异步编程，让你编写的异步代码看起来和同步代码很相似。</p>
<h3 id="handling-futures">Handling Futures</h3>
<p>当你需要获取执行完成的 Future 的结果的时候，你有两种做法： - 使用 <code>async</code> 和 <code>await</code> - 使用 Future API，如 <a target="_blank" rel="noopener" href="https://dart.dev/guides/libraries/library-tour#future">这里</a> 所述</p>
<p>使用 <code>async</code> 和 <code>await</code> 的代码是异步的，但是看起来非常像同步代码。下面的代码使用 <code>await</code> 等待异步函数的执行结果： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> lookUpVersion();</span><br></pre></td></tr></table></figure> 如果使用了 <code>await</code> 关键字，它必须在 <code>async</code> 函数中才能使用： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future checkVersion() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> version = <span class="keyword">await</span> lookUpVersion();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在 <code>async</code> 函数中可以多次使用 <code>await</code>。比如下面的代码等待了三次： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entrypoint = <span class="keyword">await</span> findEntrypoint();</span><br><span class="line"><span class="keyword">var</span> exitCode = <span class="keyword">await</span> runExecutable(entrypoint, args);</span><br><span class="line"><span class="keyword">await</span> flushThenExit(exitCode);</span><br></pre></td></tr></table></figure> 在 <code>await</code> <em>expression</em> 中，<em>expression</em>的值通常是一个 Future；如果不是，<em>expression</em>的值会自动被包装成一个 Future。Future 对象表示一个返回对象的承诺。<code>await</code> <em>expression</em> 的值就是返回的对象。<code>await</code> 表达式使代码的执行暂停到返回值可用。</p>
<p>如果在使用 <code>await</code> 的过程中发生编译异常，收线要确定 <code>await</code> 是被包含在 <code>async</code> 函数中。如果在 <code>main()</code> 函数中使用 <code>await</code>,你需要先把 <code>main()</code> 标记成 <code>async</code>: <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future main() <span class="keyword">async</span> &#123;</span><br><span class="line">  checkVersion();</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;In main: version is <span class="subst">$&#123;await lookUpVersion()&#125;</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="declaring-async-functions">Declaring async functions</h4>
<p><code>async</code> 函数指的是函数体被 <code>async</code> 关键字标记的函数。 被 <code>async</code> 标记的函数的返回值类型是 Future 。比如下边的函数返回 String ： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> lookUpVersion() =&gt; <span class="string">&#x27;1.0.0&#x27;</span>;</span><br></pre></td></tr></table></figure> 如果把上边的函数改为 <code>async</code> 函数，由于 future 类型的的实现对时间的消耗较多，它的返回值类型是 Future: <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">String</span>&gt; lookUpVersion() <span class="keyword">async</span> =&gt; <span class="string">&#x27;1.0.0&#x27;</span>;</span><br></pre></td></tr></table></figure> 需要注意的是函数体本身并不需要使用 Future 的 API。Dart 会在必要时创建 Future 对象。如果函数没有返回值，就让他默认返回 <code>Future&lt;void&gt;</code> 类型。 对于 <code>async</code> 和 <code>await</code> 的交互式教程，参考 <a target="_blank" rel="noopener" href="https://dart.dev/codelabs/async-await">asynchronous programming codelab</a>。</p>
<h4 id="handling-streams">Handling Streams</h4>
<p>当你需要从 Stream 中获取数据的时候，你有两种方法： - 使用 <code>async</code> 和异步的 for 循环(<code>await for</code>) - 使用 Stream API，描述见 <a target="_blank" rel="noopener" href="https://dart.dev/guides/libraries/library-tour#stream">library tour</a></p>
<blockquote>
<p>在使用 <code>await for</code> 之前，一定要想清楚，<code>await for</code> 是否可以使你的代码更加整洁，你是否真的需要等待Stream 中的每个结果。比如，对于 UI 事件的监听，不应该使用 <code>await for</code> ,因为 UI 框架的事件流会发生无尽的事件。</p>
</blockquote>
<p>异步 for 循环代码如下： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">for</span> (varOrType identifier <span class="keyword">in</span> expression) &#123;</span><br><span class="line">  <span class="comment">// 流中每发生一次事件就会执行一次这里的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 上边代码中 <code>expression</code> 的值必须是 Stream 类型，代码的执行流程如下： 1. 等待流中发出事件。 2. 执行循环体的代码，事件被赋值给 identifier。 3. 重复以上两步，一直到 Stream 关闭。</p>
<p>可以使用 <code>break</code> 或 <code>return</code> 语句退出循环，来结束对 Stream 的监听。</p>
<p>如果在编写异步 for 循环代码时发生编译错误，你可以检查代码，确保 <code>await for</code> 语句是被包含在 <code>async</code> 函数中。比如为了在 <code>main()</code> 函数中使用异步 for 循环，<code>main()</code> 必须使用 <code>async</code> 标记： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future main() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> request <span class="keyword">in</span> requestServer) &#123;</span><br><span class="line">    handleRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 异步编程的更多信息吗，参考 <a target="_blank" rel="noopener" href="https://dart.dev/guides/libraries/library-tour#dartasync---asynchronous-programming">dart:sync</a> 。</p>
<h2 id="generators">Generators</h2>
<p>在你需要懒生成（lazily produce）一系列的数据的时候，你可以考虑使用 <em>生成器函数</em> 来实现。Dart 内置了两种对生成器函数的支持： - 同步生成器：返回 <a target="_blank" rel="noopener" href="https://api.dart.dev/stable/dart-core/Iterable-class.html">Iterable</a> 对象。 - 异步生成器：返回 <a target="_blank" rel="noopener" href="https://api.dart.dev/stable/dart-async/Stream-class.html">Stream</a> 对象。</p>
<p>使用 <code>sync *</code> 标记函数体，并使用 <code>yield</code> 语句来输出数据，这样就定义了一个同步的生成器函数： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Iterable</span>&lt;<span class="built_in">int</span>&gt; naturalsTo(<span class="built_in">int</span> n) <span class="keyword">sync</span> * &#123;</span><br><span class="line">  <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; n) <span class="keyword">yield</span> k++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 使用 <code>async *</code> 来标记函数体，并用 <code>yield</code> 来输出数据，这样就定义了一个异步生成器： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Strng&lt;<span class="built_in">int</span>&gt; asynchronousNaturalsTo(<span class="built_in">int</span> n) <span class="keyword">async</span>* &#123;</span><br><span class="line">  <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; n) <span class="keyword">yield</span> k++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 如果你的生成器是一个递归函数，可以使用 <code>yield*</code> 来提升他的性能： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Iterable</span>&lt;<span class="built_in">int</span>&gt; naturalsDownFrom(<span class="built_in">int</span> n) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> n;</span><br><span class="line">    <span class="keyword">yield</span>* natutalsDownFrom(n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="callable-classes">Callable classes</h2>
<p>通过实现 <code>call()</code> 方法，可以让实例对象像函数一样被调用。 在下边的例子中，<code>WannableFunnctionn</code> 类定义了 call() 函数，接受3个字符串类型的参数以空格建个把他们连接在一起并增加一个感叹号结尾： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WannableFunction</span> </span>&#123;</span><br><span class="line">  call(<span class="built_in">String</span> a, <span class="built_in">String</span> b, <span class="built_in">String</span> c) =&gt; <span class="string">&#x27;<span class="subst">$a</span> <span class="subst">$b</span> <span class="subst">$c</span>!&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()  &#123;</span><br><span class="line">  <span class="keyword">var</span> wf = <span class="keyword">new</span> WannableFunction();</span><br><span class="line">  <span class="keyword">var</span> out = wf(<span class="string">&quot;Hi&quot;</span>, <span class="string">&quot;there&quot;</span>, <span class="string">&quot;gang&quot;</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$out</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="isolates">Isolates</h2>
<p>多数的计算机系统都有多核CPU。为了充分利用多核优势，开发者通常使用多线程共享内存来并行运行。然而，同步共享状态不仅仅容易发生错误，而且也让代码更加复杂，</p>
<p>与线程不同，Dart 代码运行在 <em>isolates</em> 中。每个 <em>isolate</em> 有它自己的内存栈区，保证从外部无法访问到 <em>isolate</em> 的内部。</p>
<p>更多信息参考： - <a target="_blank" rel="noopener" href="https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a">Dart asynchronous programming: Isolates and event loops</a> - <a target="_blank" rel="noopener" href="https://api.dart.dev/stable/dart-isolate">dart:isolate API reference</a> ，包括 <a target="_blank" rel="noopener" href="https://api.dart.dev/stable/dart-isolate/Isolate/spawn.html">Isolate.spawn()</a> 和 <a target="_blank" rel="noopener" href="https://api.dart.dev/stable/dart-isolate/TransferableTypedData-class.html">Transferable TypedData</a> - <a target="_blank" rel="noopener" href="https://flutter.dev/docs/cookbook/networking/background-parsing">Background parsing</a> 指南 - <a target="_blank" rel="noopener" href="https://github.com/flutter/samples/tree/master/isolate_example">Isolate sample app</a></p>
<h2 id="typedefs">Typedefs</h2>
<p>在 Dart 中，函数也是对象，是和字符串、数字等一样的对象。<em>typedef</em> 或者 <em>function-type alias</em>，给函数类型一个名字，你可以在声明数据、函数返回值时使用这个名字。当函数被赋值给变量时候， typedef 包含了函数类型信息。</p>
<p>看下边不使用 typedef 的代码： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedCollection</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Function</span> compare;</span><br><span class="line"></span><br><span class="line">  SortedCollection(<span class="built_in">int</span> f(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b)) &#123;</span><br><span class="line">    compare = f;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的实现</span></span><br><span class="line"><span class="built_in">int</span> sort(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b) =&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  SortedCollection coll = SortedCollection(sort);</span><br><span class="line">  <span class="comment">//我们只知道 compare 是一个函数，但函数的类型是什么？</span></span><br><span class="line">  <span class="keyword">assert</span>(coll.compare <span class="keyword">is</span> <span class="built_in">Function</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 上边的代码在把 <code>f</code> 赋值给 <code>compare</code> 的时候已经丢失了函数的类型信息。<code>f</code> 的类型是 <code>(Object, Object) → int</code> (→ 表示返回值)， <code>compare</code> 的类型是 Function。如果我们改变代码使用命名来保存类型信息，那么开发者和开发工具就都可以利用这个信息了： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Compare = <span class="built_in">int</span> <span class="built_in">Function</span>(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedCollection</span> </span>&#123;</span><br><span class="line">  Compare compare;</span><br><span class="line">  SortedColloection(<span class="keyword">this</span>.compare);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sort(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b) =&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  SortedCollection coll = SortedCollectionn(sort);</span><br><span class="line">  <span class="keyword">assert</span>(coll.compare <span class="keyword">is</span> <span class="built_in">Function</span>);</span><br><span class="line">  <span class="keyword">assert</span>(coll.compare <span class="keyword">is</span> Compare);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 由于 typedef 仅仅是别名而已，他们只是提供了检查对函数类型的检查： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Compare&lt;T&gt; = <span class="built_in">int</span> Functionn(T a, T b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sort(<span class="built_in">int</span> a, <span class="built_in">int</span> b) =&gt; a - b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(sort <span class="keyword">is</span> Compare&lt;<span class="built_in">int</span>&gt;); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="metadata">Metadata</h2>
<p>通过 metadata 来给出代码的更多信息。 metadata 使用 <code>@</code> 来标注，后面紧跟一个编译时常量（比如 <code>deprecated</code>） 或者调用一个常量构造函数。</p>
<p>有两个标注是适用于所有 Dart 代码的： <code>@deprecated</code> 和 <code>@override</code> 。关于 <code>@override</code> 的使用，参考 <a target="_blank" rel="noopener" href="https://dart.dev/guides/language/language-tour#extending-a-class">Extending a class</a> 。下边是使用 <code>deprecated</code> 的例子： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown"><span class="emphasis">_Deprecated: Use [tuenOn] instead .</span></span></span></span><br><span class="line">  <span class="meta">@deprecated</span></span><br><span class="line">  <span class="keyword">void</span> activate() &#123;</span><br><span class="line">    turnOn();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// <span class="markdown"><span class="emphasis">Turns the TV&#x27;s power on.</span></span></span></span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 你也可以自定义标注，下边定义的 <span class="citation" data-cites="todo">@todo</span> 标注，它有两个参数： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span> todo;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> who;</span><br><span class="line">  finnal <span class="built_in">String</span> what;</span><br><span class="line">  <span class="keyword">const</span> Todo(<span class="keyword">this</span>.who, <span class="keyword">this</span>.what);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> Metadata 可以出现在 library, class, typedef, type parameter, constructor, factory, field, parameter 或 variable declaration 之前，也可以在 import 和 export 指令之前。你可以通过反射在运行时获取 metadata 。</p>
<h2 id="comments">Comments</h2>
<p>Dart 支持单行注释，多行注释和文档注释。</p>
<h3 id="single-line-commennts">Single-line commennts</h3>
<p>单行注释以 <code>//</code> 开头，在 <code>//</code> 到行尾的任何内容都会被 Dart 编译器忽略掉。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> refactor into an AbstractLlamaGreetingFacyoty?</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Welcome to my Llama farm!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="multi-linne-comments">Multi-linne comments</h3>
<p>多行注释以 <code>/*</code> 开头， 以 <code>*/</code> 结尾。Dart 编译器会忽略<code>/* */</code> 之间（文档注释除外，建下文）的所有内容。多行注释内部可能包含多行注释。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * This is a lot of work. Consider raising chikens.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Llama larry = Llama();</span></span><br><span class="line"><span class="comment">   larry.feed();</span></span><br><span class="line"><span class="comment">   larry.exercise();</span></span><br><span class="line"><span class="comment">   larry.clean();</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="documentation-comments">Documentation comments</h3>
<p>文档注释可以是以 <code>///</code> 开头的单行注释或是以 <code>/**</code> 开头的多行注释。连续使用多行 <code>///</code> 与多行文档注释效果相同。</p>
<p>在文档注释中，Dart 编译器会忽略所有文字（在括号中间的除外）。你可以使用引号来引用类、方法、顶层变量、函数和参数。The names in brackets are resolved in the lexical scope of the documented program element. 下边的文档注释引用了其他类和参数： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">A domesticated South Ameracan camelid (Lama glama).</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="markdown">Andean cultures have used llamas as meat and pack</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">animals since pre-Hispanic times.</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Llama</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Feeds yout llama [Food].</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">The typical llama eats one bale of hay per week.</span></span></span><br><span class="line">  <span class="keyword">void</span> feed(Food food) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在生成的文档中， <code>[Food]</code> 就变成了指向Food 类的API 文档的链接。</p>
<p>你可以使用 Dart SDK 中的<a target="_blank" rel="noopener" href="https://github.com/dart-lang/dartdoc#dartdoc">文档工生成具</a>分析 Dart 代码来生成网页格式的文档。关于生成文档的例子，参考<a target="_blank" rel="noopener" href="https://api.dart.dev/stable">Dart API documentation</a>。关于如何编写注释的指南，见 <a target="_blank" rel="noopener" href="https://dart.dev/guides/language/effective-dart/documentation">Guildelines for Dart Doc Comments</a> 。</p>
<h2 id="summary">Summary</h2>
<p>本文简述了 Dart 语言中常用的特性。还有更多的特性正在实现中，我们希望新特性不会破坏与当前特性的兼容性。更多信息参考 <a target="_blank" rel="noopener" href="https://dart.dev/guides/language/spec">Dart language specification</a> 和 <a target="_blank" rel="noopener" href="https://dart.dev/guides/language/effective-dart">Effective Dart</a> 。</p>
<p>关于 Dart 核心库的更多内容，参考 <a target="_blank" rel="noopener" href="https://dart.dev/guides/libraries/library-tour">A Tour of the Dart Libraries</a>。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Dart/" rel="tag"># Dart</a>
              <a href="/tags/Flutter/" rel="tag"># Flutter</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Dart/dart%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%85/" rel="prev" title="dart语言之旅">
      <i class="fa fa-chevron-left"></i> dart语言之旅
    </a></div>
      <div class="post-nav-item">
    <a href="/Hexo/hexo-enable-mathjax/" rel="next" title="启用math支持">
      启用math支持 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#dart%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.</span> <span class="nav-text">Dart基本程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="nav-number">2.</span> <span class="nav-text">重要概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">3.</span> <span class="nav-text">关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">4.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">4.1.</span> <span class="nav-text">默认值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final-%E4%B8%8E-const"><span class="nav-number">4.2.</span> <span class="nav-text">final 与 const</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.</span> <span class="nav-text">内置类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%97"><span class="nav-number">5.1.</span> <span class="nav-text">数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#strings"><span class="nav-number">5.2.</span> <span class="nav-text">Strings</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#booleans"><span class="nav-number">5.3.</span> <span class="nav-text">Booleans</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lists"><span class="nav-number">5.4.</span> <span class="nav-text">Lists</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#maps"><span class="nav-number">5.5.</span> <span class="nav-text">Maps</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#runes"><span class="nav-number">5.6.</span> <span class="nav-text">Runes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#symbols"><span class="nav-number">5.7.</span> <span class="nav-text">Symbols</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#functions"><span class="nav-number">6.</span> <span class="nav-text">Functions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#optional-parameters"><span class="nav-number">6.1.</span> <span class="nav-text">Optional parameters</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#optional-positional-parameters"><span class="nav-number">6.1.1.</span> <span class="nav-text">Optional positional parameters</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#default-parameter-values"><span class="nav-number">6.1.2.</span> <span class="nav-text">Default parameter values</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#the-main-function"><span class="nav-number">6.2.</span> <span class="nav-text">The main() function</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#functions-as-first-class-objects"><span class="nav-number">6.2.1.</span> <span class="nav-text">Functions as first-class objects</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#anonymous-functions-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="nav-number">6.2.2.</span> <span class="nav-text">Anonymous functions 匿名函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lexical-scope-%E8%AF%8D%E6%B3%95%E8%8C%83%E5%9B%B4"><span class="nav-number">6.2.3.</span> <span class="nav-text">Lexical Scope 词法范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lexical-closure"><span class="nav-number">6.2.4.</span> <span class="nav-text">Lexical Closure</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#test-functions-for-equality-%E5%87%BD%E6%95%B0%E6%AF%94%E8%BE%83"><span class="nav-number">6.2.5.</span> <span class="nav-text">Test functions for equality 函数比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#return-values-%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">6.2.6.</span> <span class="nav-text">Return values 返回值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#operators-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">7.</span> <span class="nav-text">Operators 操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#arithmetic-operators-%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">7.1.</span> <span class="nav-text">Arithmetic operators 算数运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#equality-and-relational-operators-%E7%9B%B8%E7%AD%89%E4%B8%8E%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">7.2.</span> <span class="nav-text">Equality and relational operators 相等与关系运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-test-operators-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">7.3.</span> <span class="nav-text">Type test operators 类型检测运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#assignment-operators-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">7.4.</span> <span class="nav-text">Assignment operators 赋值运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#logical-operators"><span class="nav-number">7.5.</span> <span class="nav-text">Logical operators</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bitwise-and-shift-operators-%E4%BD%8D%E4%B8%8E%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">7.6.</span> <span class="nav-text">Bitwise and shift operators 位与移位操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#conditional-expressions-%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">7.7.</span> <span class="nav-text">Conditional Expressions 条件表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cascade-notation-%E7%BA%A7%E8%81%94%E6%93%8D%E4%BD%9C"><span class="nav-number">7.8.</span> <span class="nav-text">Cascade notation (级联操作)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#other-operators-%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">7.9.</span> <span class="nav-text">Other Operators 其他运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#control-flow-statements-%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5"><span class="nav-number">8.</span> <span class="nav-text">Control flow statements 控制流语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#if-and-else"><span class="nav-number">8.1.</span> <span class="nav-text">If and else</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-loops-for-%E5%BE%AA%E7%8E%AF"><span class="nav-number">8.2.</span> <span class="nav-text">For loops For 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#while-and-do-while-while-%E5%BE%AA%E7%8E%AF"><span class="nav-number">8.3.</span> <span class="nav-text">While and do-while while 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#break-and-continue-%E8%AF%AD%E5%8F%A5"><span class="nav-number">8.4.</span> <span class="nav-text">Break and continue 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch-and-case-%E8%AF%AD%E5%8F%A5"><span class="nav-number">8.5.</span> <span class="nav-text">Switch and case 语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exceptions-%E5%BC%82%E5%B8%B8"><span class="nav-number">9.</span> <span class="nav-text">Exceptions 异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#throw"><span class="nav-number">9.1.</span> <span class="nav-text">Throw</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#catch"><span class="nav-number">9.2.</span> <span class="nav-text">Catch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#finally"><span class="nav-number">9.3.</span> <span class="nav-text">Finally</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#classes-%E7%B1%BB"><span class="nav-number">10.</span> <span class="nav-text">Classes 类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#using-class-memebers-%E4%BD%BF%E7%94%A8%E7%B1%BB%E6%88%90%E5%91%98"><span class="nav-number">10.1.</span> <span class="nav-text">Using class memebers 使用类成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#using-constructors-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">10.2.</span> <span class="nav-text">Using constructors 构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getting-an-objects-type-%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="nav-number">10.3.</span> <span class="nav-text">Getting an object&#39;s type 获取对象类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#instance-variables-%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F"><span class="nav-number">10.4.</span> <span class="nav-text">Instance variables 实例变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constructors-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">10.5.</span> <span class="nav-text">Constructors 构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#named-constructors-%E5%91%BD%E5%90%8D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">10.5.1.</span> <span class="nav-text">Named constructors 命名构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#involing-a-non-default-superclass-constructor-%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E9%9D%9E%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">10.5.2.</span> <span class="nav-text">Involing a non-default superclass constructor 调用父类非默认构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#initializer-list-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-number">10.5.3.</span> <span class="nav-text">Initializer list 初始化列表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#redirecting-constructors-%E9%87%8D%E5%AE%9A%E5%90%91%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">10.5.3.1.</span> <span class="nav-text">Redirecting constructors 重定向构造函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#constant-constructors-%E5%B8%B8%E9%87%8F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">10.5.4.</span> <span class="nav-text">Constant constructors 常量构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#factory-constructors-%E5%B7%A5%E5%8E%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">10.5.5.</span> <span class="nav-text">Factory constructors 工厂构造函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#methonds-%E5%87%BD%E6%95%B0"><span class="nav-number">10.6.</span> <span class="nav-text">Methonds 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#instance-methods-%E5%AE%9E%E4%BE%8B%E5%87%BD%E6%95%B0"><span class="nav-number">10.6.1.</span> <span class="nav-text">Instance methods 实例函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getters-and-setters"><span class="nav-number">10.6.2.</span> <span class="nav-text">Getters and setters</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#abstract-methods"><span class="nav-number">10.6.3.</span> <span class="nav-text">Abstract methods</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#abstract-classes"><span class="nav-number">10.6.4.</span> <span class="nav-text">Abstract classes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#implicit-interface"><span class="nav-number">10.6.5.</span> <span class="nav-text">Implicit Interface</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#extending-a-class"><span class="nav-number">10.6.6.</span> <span class="nav-text">Extending a class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#overriding-members"><span class="nav-number">10.6.7.</span> <span class="nav-text">Overriding members</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#overridable-operators"><span class="nav-number">10.6.8.</span> <span class="nav-text">Overridable operators</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nosuchmethod"><span class="nav-number">10.6.9.</span> <span class="nav-text">noSuchMethod()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#extension-methods"><span class="nav-number">10.6.10.</span> <span class="nav-text">Extension methods</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#enumerated-types"><span class="nav-number">10.6.11.</span> <span class="nav-text">Enumerated types</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#using-enums"><span class="nav-number">10.6.11.1.</span> <span class="nav-text">Using enums</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#adding-features-to-a-class-mixins"><span class="nav-number">10.6.12.</span> <span class="nav-text">Adding features to a class: mixins</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#class-variables-and-methods"><span class="nav-number">10.6.13.</span> <span class="nav-text">Class variables and methods</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#static-variables"><span class="nav-number">10.6.13.1.</span> <span class="nav-text">Static variables</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#static-methods"><span class="nav-number">10.6.13.2.</span> <span class="nav-text">Static methods</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#generics"><span class="nav-number">11.</span> <span class="nav-text">Generics</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#why-use-generics"><span class="nav-number">11.1.</span> <span class="nav-text">Why use generics？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#using-collection-literals"><span class="nav-number">11.2.</span> <span class="nav-text">Using collection literals</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#generic-collections-and-the-types-they-contain"><span class="nav-number">11.3.</span> <span class="nav-text">Generic collections and the types they contain</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#restricting-the-parameterized-type"><span class="nav-number">11.4.</span> <span class="nav-text">Restricting the parameterized type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#using-generic-methods"><span class="nav-number">11.5.</span> <span class="nav-text">Using generic methods</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#libraries-and-visibility"><span class="nav-number">12.</span> <span class="nav-text">Libraries and visibility</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#using-libraries"><span class="nav-number">12.1.</span> <span class="nav-text">Using libraries</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#specifying-a-library-prefix"><span class="nav-number">12.1.1.</span> <span class="nav-text">Specifying a library prefix</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#importing-only-part-of-a-library"><span class="nav-number">12.1.2.</span> <span class="nav-text">Importing only part of a library</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lazily-loading-library"><span class="nav-number">12.1.3.</span> <span class="nav-text">Lazily loading library</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#implementing-libraries"><span class="nav-number">12.2.</span> <span class="nav-text">Implementing libraries</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#asynchrony-support"><span class="nav-number">13.</span> <span class="nav-text">Asynchrony support</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#handling-futures"><span class="nav-number">13.1.</span> <span class="nav-text">Handling Futures</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#declaring-async-functions"><span class="nav-number">13.1.1.</span> <span class="nav-text">Declaring async functions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#handling-streams"><span class="nav-number">13.1.2.</span> <span class="nav-text">Handling Streams</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#generators"><span class="nav-number">14.</span> <span class="nav-text">Generators</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#callable-classes"><span class="nav-number">15.</span> <span class="nav-text">Callable classes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#isolates"><span class="nav-number">16.</span> <span class="nav-text">Isolates</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typedefs"><span class="nav-number">17.</span> <span class="nav-text">Typedefs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#metadata"><span class="nav-number">18.</span> <span class="nav-text">Metadata</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#comments"><span class="nav-number">19.</span> <span class="nav-text">Comments</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#single-line-commennts"><span class="nav-number">19.1.</span> <span class="nav-text">Single-line commennts</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#multi-linne-comments"><span class="nav-number">19.2.</span> <span class="nav-text">Multi-linne comments</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#documentation-comments"><span class="nav-number">19.3.</span> <span class="nav-text">Documentation comments</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#summary"><span class="nav-number">20.</span> <span class="nav-text">Summary</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhang Yuzheng</p>
  <div class="site-description" itemprop="description">码农日常</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">[object Object]</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>

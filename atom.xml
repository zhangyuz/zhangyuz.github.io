<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>memorandums</title>
  
  <subtitle>life notes</subtitle>
  <link href="https://www.zhangyuzheng.com/atom.xml" rel="self"/>
  
  <link href="https://www.zhangyuzheng.com/"/>
  <updated>2021-08-14T03:53:53.478Z</updated>
  <id>https://www.zhangyuzheng.com/</id>
  
  <author>
    <name>Zhang Yuzheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://www.zhangyuzheng.com/uncategorized/dart_core_library_tour/"/>
    <id>https://www.zhangyuzheng.com/uncategorized/dart_core_library_tour/</id>
    <published>2021-08-14T03:53:53.478Z</published>
    <updated>2021-08-14T03:53:53.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="a-tour-of-the-core-libraries">A tour of the core libraries</h1><p>原文参见 <a href="https://dart.dev/guides/libraries/library-tour">A tour of the core libraries</a> 。</p><p>本文展示了 Dart 核心库的主要特性。本文只是概览，不保证连贯性。档需要了解某个类的更多信息，参考 <a href="https://api.dart.dev/stable">Dart API reference</a> 。</p><p><a href="https://dart.dev/guides/libraries/library-tour#dartcore---numbers-collections-strings-and-more">dart:core</a></p><p>内置类型、集合和其他核心功能。任何 Dart 程序都会自动导入此库。</p><p><a href="https://dart.dev/guides/libraries/library-tour#dartasync---asynchronous-programming">dart:async</a></p><p>支持异步编程，包含了 Future 和 Stream 等类。</p><p><a href="https://dart.dev/guides/libraries/library-tour#dartmath---math-and-random">dart:math</a></p><p>数学运算功能和常量，再加上一个随机数生成器。</p><p><a href="https://dart.dev/guides/libraries/library-tour#dartconvert---decoding-and-encoding-json-utf-8-and-more">dart:convert</a></p><p>包含了在不同的数据表示之间进行转换的编解码器，包含 JSON 和 UTF-8。</p><p><a href="https://dart.dev/guides/libraries/library-tour#darthtml">dart:html</a></p><p>DOM 和其他基于浏览器 App 的 API 。</p><p><a href="https://dart.dev/guides/libraries/library-tour#dartio">dart:io</a></p><p>使用 Dart 虚拟机的 I/O 程序，包含 Flutter、服务器和命令行脚本。</p><p>本文只是概述，只包含了一些 dart:* 的库，不包含第三方库。</p><p><a href="https://pub.dev/">pub.dev</a> 和 <a href="https://dart.dev/web/libraries">Dart web developer library guild</a> 包含了更多库的信息。 dart:* 库的 API 文档可以在 <a href="https://api.dart.dev/stable">Dart API reference</a> , Flutter 的文档见 <a href="https://api.flutter.dev/">Flutter API reference</a> 。</p><h2 id="dartcore---numbers-collection-strings-and-more">dart:core - numbers, collection, strings, and more</h2><p>dart:core 库体积很小，但是提供了 Dart 关键的内置功能。此库是自动导入每个 Dart 程序的。</p><h3 id="printing-to-the-console">Printing to the console</h3><p>顶层的 <code>print()</code> 方法只有一个参数（任意对象），它把对象的字符串的值（<code>toString()返回的字符串</code>）打印到终端。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(anObject);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;I drink <span class="subst">$tea</span>&#x27;</span>);</span><br></pre></td></tr></table></figure> 关于字符串和 <code>toString()</code> 函数，参考 <a href="https://dart.dev/guides/language/language-tour#strings">Strings</a></p><h3 id="numbers">Numbers</h3><p>dart:core 中定义了 num, int 和 double 类，包含了使用数字类型的一些基本工具。</p><p>你可以调用 int 或 double 的 <code>parse()</code> 方法将字符串类型转换为整数或浮点数： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(<span class="built_in">int</span>.parse(<span class="string">&#x27;42&#x27;</span>) == <span class="number">42</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">int</span>.parse(<span class="string">&#x27;0x42&#x27;</span>) == <span class="number">66</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">double</span>.parse(<span class="string">&#x27;0.50&#x27;</span>) == <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure> 或者你可以使用 num 的 parse() 方法，它会尽可能的返回整数类型，否则会返回 double 类型： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(<span class="built_in">num</span>.parse(<span class="string">&#x27;42&#x27;</span>) <span class="keyword">is</span> <span class="built_in">int</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">num</span>.parse(<span class="string">&#x27;0x42&#x27;</span> <span class="keyword">is</span> <span class="built_in">int</span>));</span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">num</span>.parse(<span class="string">&#x27;0.50&#x27;</span>) <span class="keyword">is</span> <span class="built_in">double</span>);</span><br></pre></td></tr></table></figure> 可以使用 <code>radix</code> 参数指定整数的进制（译注：二进制，十六进制）: <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(<span class="built_in">int</span>.parse(<span class="string">&#x27;42&#x27;</span>, radix: <span class="number">16</span>) == <span class="number">66</span>);</span><br></pre></td></tr></table></figure> 是用 <code>toString()</code> 方法将整数或浮点数转换成字符串。使用 <a href="https://api.dart.dev/stable/dart-core/num/toStringAsFixed.html">toStringAsFixed</a> 来指定小数点后数字的位数，使用 <a href="https://api.dart.dev/stable/dart-core/num/toStringAsPrecision.html">toStringAsPrecision()</a> 来指定科学计数法的有效位数： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 int 转换为字符串</span></span><br><span class="line"><span class="keyword">assert</span>(<span class="number">42.</span>toString() == <span class="string">&#x27;42&#x27;</span>);</span><br><span class="line"><span class="comment">// 将 double 转换为字符串</span></span><br><span class="line"><span class="keyword">assert</span>(<span class="number">123.456</span>.toStringAsFixed(<span class="number">2</span>) == <span class="string">&#x27;123.46&#x27;</span>);</span><br><span class="line"><span class="comment">// 指定有效位数</span></span><br><span class="line"><span class="keyword">assert</span>(<span class="number">123.456</span>.toStringAsPrecision(<span class="number">2</span>) == <span class="string">&#x27;1.2e+2&#x27;</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">double</span>.parse(<span class="string">&#x27;1.2e+2&#x27;</span>) == <span class="number">120.0</span>);</span><br></pre></td></tr></table></figure> 更多信息参考 API 文档， <a href="https://api.dart.dev/stable/dart-core/int-class.html">int</a>，<a href="https://api.dart.dev/stable/dart-core/double-class.html">double</a>, <a href="https://api.dart.dev/stable/dart-core/num-class.html">num</a>, <a href="https://dart.dev/guides/libraries/library-tour#dartmath---math-and-random">dart:math</a> 。</p><h3 id="strings-and-regular-expressions">Strings and regular expressions</h3><p>Dart 中的字符串就是不可修改的 UTF-16 码值序列。Dart 语言教程中有更多关于 <a href="https://dart.dev/guides/language/language-tour#strings">strings</a> 的信息。你可以使用正则表达式（RegExp 对象）搜索字符串、做字符串替换。</p><p>String 类定义了 <code>split()</code>, <code>contains()</code>, <code>startsWith()</code>, <code>endsWith()</code> 等方法。 #### Searching inside string 你可以在字符串中查找特定字符、确定是否以某个特定字符式样开始或结束： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查字符串是否包含另一个字符串。</span></span><br><span class="line"><span class="keyword">assert</span>(<span class="string">&#x27;Never odd or even&#x27;</span>.contains(<span class="string">&#x27;odd&#x27;</span>));</span><br><span class="line"><span class="comment">// 是否以某一个字符串开始</span></span><br><span class="line"><span class="keyword">assert</span>(<span class="string">&#x27;Never odd or even&#x27;</span>.startsWith(<span class="string">&#x27;Never&#x27;</span>));</span><br><span class="line"><span class="comment">// 是否以某个字符串结尾</span></span><br><span class="line"><span class="keyword">assert</span>(<span class="string">&#x27;Never odd or even&#x27;</span>.endsWith(<span class="string">&#x27;odd&#x27;</span>));</span><br><span class="line"><span class="comment">// 查找子串的</span></span><br><span class="line"><span class="keyword">assert</span>(<span class="string">&#x27;Nevenr odd or even&#x27;</span>.indexOf(<span class="string">&#x27;odd&#x27;</span>) = <span class="number">6</span>);</span><br></pre></td></tr></table></figure> #### Extracting data from a string</p><h2 id="dartasync---asynchronous-programming">dart:async - asynchronous programming</h2><p>异步编程经常使用回调函数，但是 Dart 提供了其他备选方案：<a href="https://api.dart.dev/stable/dart-async/Future-class.html">Future</a> 和 <a href="https://api.dart.dev/stable/dart-async/Stream-class.html">Stream</a> 。一个 Future 就像一个在未来某个时间返回数据的一个承诺。 Stream 是获取数据序列的一种方式，比如事件。关于 Future、Stream 等的更多文档参考 <a href="https://api.dart.dev/stable/dart-async/dart-async-library.html">dart:async API reference</a> 。 &gt; 很多时候你不需要自己直接使用 Future 和 Stream 的 API。Dart 语言支持使用 <code>async</code> 和 <code>await</code> 进行异步编程。参考 <a href="https://dart.dev/codelabs/async-await">asynchronous programming codelab</a> 。</p><p>dart:async 库支持 web 和 命令行应用，导入后即可使用： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dart:<span class="keyword">async</span>;</span><br></pre></td></tr></table></figure> ### Future 对 Future 的使用遍布 Dart 的各种多，经常作为异步方法的返回值。当一个 future 运行完成后，它的值就可以使用了。 #### Using await 在直接使用 Future API 之前，要先考虑是否可以使用 <code>await</code> 代替。因为使用 <code>await</code> 表达式比使用 Future 的代码更容易理解。</p><p>看下边的代码。它使用了 Future 的 <code>then()</code> 方法来依次执行3个异步函数，等前一个执行完成后执行下一个。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">runUsinngFuture() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    findEntryPoint().then((entryPoint) &#123;</span><br><span class="line">        <span class="keyword">return</span> runExecutable(entryPoint, args);</span><br><span class="line">    &#125;).then(flushThenExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 等效的 <code>await</code> 代码入下： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">runUsingAsyncAwait() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">var</span> entryPoint = <span class="keyword">await</span> findEntryPoint();</span><br><span class="line">    <span class="keyword">var</span> exitCode = <span class="keyword">await</span> rumExecutable(entryPoint, args);</span><br><span class="line">    <span class="keyword">await</span> flushThenExit(exitCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>async</code> 函数可以处理 Future 的异常： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entryPoint = <span class="keyword">await</span> findEntryPoint();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> exitCode = <span class="keyword">await</span>  runExecutable(entryPoint, args);</span><br><span class="line">    <span class="keyword">await</span> flushThenExit(exitCode);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// Handle the error...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> &gt; 异步方法返回值类型是 Future 。如果不希望函数返回 Future 对象，你必须使用其他解决方案。比如调用 <code>async</code> 函数。</p><p>关于 <code>await</code> 的使用餐你考 <a href="https://dart.dev/codelabs/async-await">asynchronous programming codelab</a> 。 #### Basic usage 使用 <code>then()</code> 来调度</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;a-tour-of-the-core-libraries&quot;&gt;A tour of the core libraries&lt;/h1&gt;
&lt;p&gt;原文参见 &lt;a href=&quot;https://dart.dev/guides/libraries/library-tour&quot;&gt;A t</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GraphQL Schemas and Types</title>
    <link href="https://www.zhangyuzheng.com/Graphql/GraphQlSchemasAndTypes/"/>
    <id>https://www.zhangyuzheng.com/Graphql/GraphQlSchemasAndTypes/</id>
    <published>2020-03-16T14:15:00.000Z</published>
    <updated>2021-08-14T03:53:53.474Z</updated>
    
    <content type="html"><![CDATA[<p>本文将讨论GraphQL的类型系统和如何定义数据类型（由于 GraphQL 是一种规范，你可以用任何编程语言实现它，这里的讨论将不涉及任何特定的编程语言，只讨论规范中的概念定义）。</p><h2 id="type-system">Type system</h2><p>GraphQL 的查询语句基本是从对象中查询数据域。查询语句的数据结构与查询返回的数据结构非常接近，但是我们仍然需要明确的知道服务器端可提供的数据：可供的选择的数据域、可能返回什么类型的对象、数据域子对象包含哪些数据域。为了解决这个问题，GraphQL引入了 Schema。</p><p>每个 GraphQL 的服务端都通过 Schema 定义了所有可用的数据类型集合。</p><h2 id="type-language">Type language</h2><p>GraphQL 规范可以用任何编程语言实现，为了易于讨论 GraphQL Schema 的定义， 我们使用 "GraphQL schema language" 来描述 Schema 的定义。它类似于查询语句。</p><h3 id="object-types-and-fields">Object types and fields</h3><p>GraphQL Schema 最基本的组成是对象的定义，表示你可以从服务器获取的数据类型、对象的数据域： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Character &#123;</span><br><span class="line">    name: String!</span><br><span class="line">    appearIn:[Episode!]!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上边的定义非常易读，解读如下（这样就可以统一我们对GraphQL Schema 的概念了）： - <code>Character</code> 是 <em>GraphQL 的对象类型</em> <em>（GraphQL Object Type）</em> ，表示这个类型包含一些其他数据域。 - <code>name</code> 和 <code>appearsIn</code> 是 <code>Character</code> 类型的数据域。它的意义是在任何对 <code>Character</code> 的查询中最多只能返回这两个数据域。 - <code>String</code> 是 GraphQL 内置的 <em>标量（scalar）</em> 类型。这些类型不再包含子数据域。 - <code>String!</code> 表示这个数据域 <em>不可为空（non-nullable）</em>, 服务端保证在任何请求中如果需要都会保证返回这个数据域。 - <code>[Episode!]!</code> 表述 <code>Episode</code> 数组，不可为空，并且数组中的每个元素也不可为空。</p><h2 id="arguments">Arguments</h2><p>GraphQL 对象的没个数据域都可以包含0到多个参数，比如： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Starship &#123;</span><br><span class="line">    id: ID!</span><br><span class="line">    name: String!</span><br><span class="line">    length(unit: LengthUnit = METER): Float</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 所有的参数必须有名字，并且传递参数时必须指定参数名。参数可以是必选或可选参数，对于可选参数需要定义参数默认值。</p><h2 id="the-query-and-mutation-types">The Query and Mutation types</h2><p>Schema中多数的类型定义都类似于普通对象，但是有两个类型是被特别处理的： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">schema &#123;</span><br><span class="line">    query： Query</span><br><span class="line">    mutation：Mutation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> GraphQL 服务端必须包含 <code>query</code> 类型， <code>matation</code> 类型是可选的。他们与普通类型的定义一样，但是服务器端会特别处理它们，因为他们定义了查询操作的入口。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">  droid(id: <span class="string">&quot;2000&quot;</span>) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;hero&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;R2-D2&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;droid&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;C-3PO&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上边的 query 是可用的，那么就意味着服务器端在 <code>Query</code> 类型中定义了 <code>hero</code> 和 <code>droid</code> 两个数据域： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">    hero(episode: Episode): Character</span><br><span class="line">    droid(id:ID!): Droid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> Mutation 与 Query 类似。你需要定义 <code>Mutation</code> 类型中的数据域。 Mutation 和 Query 类型除了是 schema 的入口外，与其他类型的定义没有区别。</p><h2 id="scalar-types">Scalar types</h2><p>GraphQL 的对象类型至少包含了名字和数据域，优势这些数据域要被解析成一些基础类型。这就是 scalar 类型存在的原因：他们代表了查询的叶子节点（译注：个人理解类似Java中的基本数据类型）： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># query</span><br><span class="line">&#123;</span><br><span class="line">    hero &#123;</span><br><span class="line">        name</span><br><span class="line">        appearIn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;hero&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;R2-Dd2&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;appearIn&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;NEWHOPE&quot;</span>,</span><br><span class="line">                <span class="string">&quot;EMPIRE&quot;</span>,</span><br><span class="line">                <span class="string">&quot;JEDI&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 之所以说 <code>name</code> 和 <code>appearIn</code> 是标量类型（scalar type），是因为 query 中他们就是叶子节点。 GraphQL 内置了默认的标量类型，可以直接使用： - <code>Int</code>: 32位有符号整数。 - <code>Float</code>：有符号双精度浮点值。 - <code>String</code>：UTF-8 字符串。 - <code>Boolean</code>：<code>true</code> 或 <code>false</code>。 - <code>ID</code>：表示唯一的标识符，通常用来做对象缓存的标识使用，本质与字符串一样，not hunman-readable。</p><p>在多数的 GraphQL 服务端支持自定义标量类型。比如 <code>Date</code>： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scalar Date</span><br></pre></td></tr></table></figure> 接下来需要服务端来具体实现 <code>Date</code> 类型的序列化、反序列化和验证的方式。比如你可以指定 <code>Date</code> 类型序列化为整型的时间戳，客户端需要知道如何处理这个类型。</p><h2 id="enumeration-types">Enumeration types</h2><p>枚举类型也称为 <code>Enums</code>，是一类特别的标量，它的值限定在一些特定的值中。这允许你： 1. 验证此类型的参数都是可用的值 2. 在整个类型系统中明确某个数据域必须是某些特定值</p><p>比如： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Episode &#123;</span><br><span class="line">    NEWHOPE</span><br><span class="line">    EMPIre</span><br><span class="line">    JEDI</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这表示任何时候你使用 <code>Episode</code> 类型对象的时候，它的值只能是 <code>NEWHOPE</code>、 <code>EMPIRE</code>、 <code>JEDI</code>中的一个。</p><h2 id="lists-and-non-null">Lists and Non-Null</h2><p>在 GraphQL 中只能定义对象（Object types）、标量（scalar）和枚举（enums）这三类数据类型。同时也定义了类型修饰符来协助你验证数据的值： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Character &#123;</span><br><span class="line">    name: String!</span><br><span class="line">    appearIn: [Episode]!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 上边的例子，使用<code>!</code> 表示那么数据不可为空，如果出现空值会导致服务器内部错误，并应该通知客户端。</p><p>非空修饰符还可以用于查询变量的定义，如果不满足，返回验证错误信息： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># query</span><br><span class="line">query DroidById($id:ID!) &#123;</span><br><span class="line">    droid(id:$id) &#123;</span><br><span class="line">        name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># variables</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>:<span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;errors&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Variable \&quot;$id\&quot; of required type \&quot;ID!\&quot; was not provided.&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;locations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;line&quot;</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;column&quot;</span>: <span class="number">17</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>数组也是类似的，用方括号（List修饰符）标识数据的类型是 List,将会返回对象的数组。非空修饰符和List修饰符可以组合使用： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># List 本身可以为空，但 List 中的元素不可以为空</span><br><span class="line">myField: [String!]</span><br></pre></td></tr></table></figure> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myField: <span class="literal">null</span>                   <span class="comment">// valid</span></span><br><span class="line">myField:[]                      <span class="comment">// valid</span></span><br><span class="line">myField:[&#x27;a&#x27;, &#x27;b&#x27;]              <span class="comment">// valid</span></span><br><span class="line">myField:[&#x27;a&#x27;, <span class="literal">null</span>, &#x27;b&#x27;]        <span class="comment">// error</span></span><br></pre></td></tr></table></figure> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># List 本身不可空，List 中元素可为空</span><br><span class="line">myField: [String]!</span><br></pre></td></tr></table></figure> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myField: <span class="literal">null</span>                   <span class="comment">// error</span></span><br><span class="line">myField: []                     <span class="comment">// valid</span></span><br><span class="line">myField: [&#x27;a&#x27;, &#x27;b&#x27;]             <span class="comment">// valid</span></span><br><span class="line">myField: [&#x27;a&#x27;, <span class="literal">null</span>, &#x27;b&#x27;]       <span class="comment">// valid</span></span><br></pre></td></tr></table></figure></p><h2 id="interfaces">Interfaces</h2><p>就像其他的类型系统，GraphQL 也支持接口类型。<em>接口（Interface）</em> 是一个抽象类型，它包含数据域的定义，所有继承它的类型都必须 包含这些数据域： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 定义 Character 接口表示任何角色</span><br><span class="line">interface Character &#123;</span><br><span class="line">    id: ID!</span><br><span class="line">    name: String!</span><br><span class="line">    friends: [Character]</span><br><span class="line">    appearsIn: [Episode]!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>任何实现 <code>Character</code> 的类型都要包含这些数据域、参数和返回值类型： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Character 的子类，必须包含 Character 类型的所有数据域，同时增加自己的数据域</span><br><span class="line">type Human implements Character &#123;</span><br><span class="line">    id: ID!</span><br><span class="line">    name: String!</span><br><span class="line">    friends: [Character]</span><br><span class="line">    appearsIn: [Episode]!</span><br><span class="line">    starships: [Starship]</span><br><span class="line">    totalCredits: Int</span><br><span class="line">&#125;</span><br><span class="line">type Droid implements Character &#123;</span><br><span class="line">    id: ID!</span><br><span class="line">    name: String!</span><br><span class="line">    friends: [Character]</span><br><span class="line">    appearsIn: [Episode]！</span><br><span class="line">    primaryFunction: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 注意下边的查询会导致错误： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">query HeroForEpisode($ep: Episode) &#123;</span><br><span class="line">    hero(episode: $ep) &#123;</span><br><span class="line">        name</span><br><span class="line">        primaryFunction</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># variables</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;ep&quot;</span>: <span class="string">&quot;HEDI&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;errors&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Cannot query field \&quot;primaryFunction\&quot; on type \&quot;Character\&quot;. Did you mean to use an inline fragment on \&quot;Droid\&quot;?&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;locations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;line&quot;</span>: <span class="number">4</span>,</span><br><span class="line">          <span class="attr">&quot;column&quot;</span>: <span class="number">5</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 出错的原因是 hero 返回值类型是 <code>Character</code> ，根据 <code>episode</code> 参数的不同，可能是 <code>Human</code> 或 <code>Droid</code> 类型。但 <code>primaryFunction</code> 不是 <code>Character</code> 类型的数据域，所以会出错。你可以用内联（in-line）fragment 来实现目标： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">query HeroForEpisode($ep: Episode) &#123;</span><br><span class="line">    hero(episode: $ep)&#123;</span><br><span class="line">        name</span><br><span class="line">        ... on Droid &#123;</span><br><span class="line">            primaryFunction</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># variables</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;ep&quot;</span>: <span class="string">&quot;JEDI&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;hero&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;R2-D2&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;primaryFunction&quot;</span>: <span class="string">&quot;Astromech&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="union-types">Union types</h2><p>Union 与 接口类型类似，但是不能指定重复的数据类型。 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union SearchResuld = Human | Droid | Starship</span><br></pre></td></tr></table></figure></p><p>在返回 <code>SearchResult</code> 的时候，可能返回 <code>Human</code> <code>Droid</code> 或 <code>Starship</code> 类型。注意 union 的组成类型必须是具体的类型，不能是抽象类型（比如 interface）。在这种情况下，如果你的query可能返回这三种数据类型，那么你就需要额外的meta信息来区分返回的数据类型： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  search(text: <span class="string">&quot;an&quot;</span>) &#123;</span><br><span class="line">    __typename</span><br><span class="line">    ... on Character &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Human &#123;</span><br><span class="line">      height</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Droid &#123;</span><br><span class="line">      primaryFunction</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Starship &#123;</span><br><span class="line">      name</span><br><span class="line">      length</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> Note that name is still specified on Starship because otherwise it wouldn't show up in the results given that Starship is not a Character!</p><h2 id="input-types">Input types</h2><p>到目前为止，我们只讨论了传递标量值（枚举、字符串）的情况。GraphQL 也支持同时传递复杂类型，尤其在 Mutation 操作中更有益处。在 GraphQL Schema 中，输入类型与其他类型一样，但是使用 input 关键字来定义： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 定义输入类型</span><br><span class="line">input ReviewInput &#123;</span><br><span class="line">    stars： Int！</span><br><span class="line">    commentary： String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 使用输入</span><br><span class="line">mutation CreateReviewForEpisode($ep:Episode, $review: ReviewInput) &#123;</span><br><span class="line">    createReview（episode:$ep, review:$review） &#123;</span><br><span class="line">        stars</span><br><span class="line">        commentary</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># variables</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;ep&quot;</span>: <span class="string">&quot;JEDI&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;review&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;stars&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">&quot;commentary&quot;</span>: <span class="string">&quot;This is a great movie!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;createReview&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;stars&quot;</span>: <span class="number">5</span>,</span><br><span class="line">      <span class="attr">&quot;commentary&quot;</span>: <span class="string">&quot;This is a great movie!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> The fields on an input object type can themselves refer to input object types, but you can't mix input and output types in your schema. Input object types also can't have arguments on their fields.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文将讨论GraphQL的类型系统和如何定义数据类型（由于 GraphQL 是一种规范，你可以用任何编程语言实现它，这里的讨论将不涉及任何特定的编程语言，只讨论规范中的概念定义）。&lt;/p&gt;
&lt;h2 id=&quot;type-system&quot;&gt;Type system&lt;/h2&gt;
&lt;p&gt;G</summary>
      
    
    
    
    <category term="Graphql" scheme="https://www.zhangyuzheng.com/categories/Graphql/"/>
    
    
    <category term="Android" scheme="https://www.zhangyuzheng.com/tags/Android/"/>
    
    <category term="Graphql" scheme="https://www.zhangyuzheng.com/tags/Graphql/"/>
    
    <category term="Apollo-Android" scheme="https://www.zhangyuzheng.com/tags/Apollo-Android/"/>
    
  </entry>
  
  <entry>
    <title>N 个小时入门 Graphql</title>
    <link href="https://www.zhangyuzheng.com/Graphql/HowToGraphql/"/>
    <id>https://www.zhangyuzheng.com/Graphql/HowToGraphql/</id>
    <published>2020-03-14T04:03:00.000Z</published>
    <updated>2021-08-14T03:53:53.474Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是笔者学习 GraphQL 的笔记，参考了 GraphQL.org 的官方文档。本文仅做学习记录。</p></blockquote><h2 id="graphql-简介">GraphQL 简介</h2><p>Graphql 是一种面向 API 的查询语言，面向强类型数据查询的服务端运行环境。它不与任何数据库绑定，而是基于当前已有的数据、代码来支持它的运行。</p><p>GraphQL 服务需要定义数据类型和数据类型中的数据成员，并且为每个数据成员提供对应的数据处理函数： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 类型定义</span><br><span class="line">type Query &#123;</span><br><span class="line">    me: User</span><br><span class="line">&#125;</span><br><span class="line">type User &#123;</span><br><span class="line">    id: ID</span><br><span class="line">    name: String</span><br><span class="line">&#125;</span><br><span class="line"># 数据处理函数</span><br><span class="line">function Query_me(request) &#123;</span><br><span class="line">    return request.auth.user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function User_name(user) &#123;</span><br><span class="line">    return usere.getName()；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>GraphQL 服务在运行的时候，能够接收 GraphQL 查询，验证并执行。它会首先检查这个查询只使用了已定义的数据域，然后运行数据处理函数返回结果。 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询</span></span><br><span class="line">&#123;</span><br><span class="line">    me &#123;</span><br><span class="line">        name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;me&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Luke Skywalker&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="queries-and-mutations">Queries and mutations</h2><h3 id="fields">Fields</h3><p>简化来说，GraphQL 的功能就是从对象中获取数据成员（field）。 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Query JSON</span><br><span class="line">&#123;</span><br><span class="line">    # 这是 selection</span><br><span class="line">    hero &#123;</span><br><span class="line">        name</span><br><span class="line">        # 这是一个 sub-selection</span><br><span class="line">        friends &#123;</span><br><span class="line">            name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;hero&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;R2-D2&quot;</span>,</span><br><span class="line">            # 注意这里返回的是列表类型</span><br><span class="line">            <span class="attr">&quot;friends&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Luke Skywalker&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Hann Solo&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 可以直观的看出，查询的结果与查询本身包含相同的数据结构。</p><h3 id="arguments">Arguments</h3><p>在 GraphQL 中，你可以方便的传递参数，包括每个数据域、每个内嵌的数据对象都可以。甚至可以在服务端实现数据转换。 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查询</span><br><span class="line">&#123;</span><br><span class="line">    human(id:<span class="string">&quot;1000&quot;</span>) &#123;</span><br><span class="line">        name</span><br><span class="line">        height(unit:FOOT)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 结果</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;human&quot;</span>: <span class="string">&quot;Luke Skywalker&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;height&quot;</span>: <span class="number">5.6430448</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="aliases">Aliases</h3><p>在上边传递参数的例子中，你可以发现，同一个参数不能传递多个参数值。这就是使用 alias 的原因，他可以让你将结果的数据域重命名。在这个例子中，两个 <code>hero</code> 数据域会冲突，但是通过alias重命名，我们在同一个请求中就可以获取两份数据： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 译注：同一个query，但重命名了返回数据的名字</span><br><span class="line">&#123;</span><br><span class="line">    empireHero: hero(episode: EMPIRE) &#123;</span><br><span class="line">        name</span><br><span class="line">    &#125;</span><br><span class="line">    jediHero: hero(episode: JEDI) &#123;</span><br><span class="line">        name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;empireHero&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Luke Skywalker&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;hediHero&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;R2-D2&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### Fragments GraphQL 的可重用模块称为 <em>fragments</em>。Fragment 可以让你构造一数据域的集合，然后再任何query需要的地方包含它： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 两个 query 需要返回相同的数据</span><br><span class="line">&#123;</span><br><span class="line">    leftComparison: hero(episode: EMPIRE) &#123;</span><br><span class="line">        ...comparisonFields</span><br><span class="line">    &#125;</span><br><span class="line">    rightComparison: hero(episode: JEDI) &#123;</span><br><span class="line">        ...comparisonFields</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fragment comparisonFields on Character &#123;</span><br><span class="line">        name</span><br><span class="line">        appearsIn</span><br><span class="line">        friends &#123;</span><br><span class="line">            name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;leftComparison&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Luke Skywalker&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;appearsIn&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;NEWHOPE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;EMPIRE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;JEDI&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;friends&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Han Solo&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Leia Organa&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;C-3PO&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;R2-D2&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;rightComparison&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;R2-D2&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;appearsIn&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;NEWHOPE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;EMPIRE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;JEDI&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;friends&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Luke Skywalker&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Han Solo&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Leia Organa&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> fragment 主要用于将复杂的数据分割成小块数据，让你的工程更加易于维护。 #### Using variables inside fragments <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">query HeroComparison($first: Int = <span class="number">3</span>) &#123;</span><br><span class="line">    leftComparison: hero(episode: EMPIRE) &#123;</span><br><span class="line">        ...comparisonFields</span><br><span class="line">    &#125;</span><br><span class="line">    rightComparison: hero(episode: EMPIRE) &#123;</span><br><span class="line">        ...comparisonFields</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fragment comparisonFields on Character &#123;</span><br><span class="line">        name</span><br><span class="line">        friendsConnection(first:$first) &#123;</span><br><span class="line">            totalCount</span><br><span class="line">            edges &#123;</span><br><span class="line">                node &#123;</span><br><span class="line">                    name</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;leftComparison&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Luke Skywalker&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;friendsConnection&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;totalCount&quot;</span>: <span class="number">4</span>,</span><br><span class="line">        <span class="attr">&quot;edges&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;node&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Han Solo&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;node&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Leia Organa&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;node&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;C-3PO&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;rightComparison&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;R2-D2&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;friendsConnection&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;totalCount&quot;</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">&quot;edges&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;node&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Luke Skywalker&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;node&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Han Solo&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;node&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Leia Organa&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## Operation name 在上边的例子中我们一直使用的都是简化的语法，省略了 <code>query</code> 关键字和 query的名字。在实际的项目中，最好加上它们，降低代码的歧义，增强可读性。 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 增加query关键字和query的名字</span><br><span class="line">query HeroNameAndFriends &#123;</span><br><span class="line">    hero &#123;</span><br><span class="line">        name</span><br><span class="line">        friends &#123;</span><br><span class="line">            name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 返回值不变</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;hero&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;R2-D2&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;friends&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Luke Skywalker&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Han Solo&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Leia Organa&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 操作类型的关键字只有 <code>query</code>、<code>mutation</code>、<code>subscription</code>，说明你想要的操作类型。如果不使用简化的语法，操作类型关键是是必须的。</p><p>操作的名字明确表示了操作的名字，在多个操作的文档中是必须的。但是我们建议尽量的使用操作的名字，有助于源码调试和服务器端的日志。</p><h2 id="variables">Variables</h2><p>在上边的实例中，我们都是用了静态的 query 语句，但是在实际的项目中，query 中会使用动态的变量。但是让客户端在运行时动态拼接query语句并不是什么好办法，所以在GraphQL 中提供了传递动态变量的方法。你只要做下面的三步操作即可： 1. 将 query 中的静态值替换为 <code>$variableName</code> 2. 声明 query 可以接受 <code>$variableName</code> 这个参数 3. 在指定的变量字典中传递 variableName:value 参数</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">query HeroNameAndFriends($episode: Episode) &#123;</span><br><span class="line">  hero(episode: $episode) &#123;</span><br><span class="line">    name</span><br><span class="line">    friends &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># variables字典</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;episode&quot;</span>: <span class="string">&quot;JEDI&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;hero&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;R2-D2&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;friends&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Luke Skywalker&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Han Solo&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Leia Organa&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="variable-definitions">Variable definitions</h3><p>变量定义就是 <code>$</code>符号后跟变量名字和类型。比如上边例子中的 <code>$episode: Episode</code>。参数类型只能是标量、枚举或输入类型。如果在变量定义后增加 <code>!</code> 表示参数是必须的。</p><h3 id="default-variables">Default variables</h3><p>变量的默认值可以使用 <code>=</code> 指定。 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">query HeroNameAndFriends($episode: Episode = JEDI) &#123;</span><br><span class="line">  hero(episode: $episode) &#123;</span><br><span class="line">    name</span><br><span class="line">    friends &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="directives">Directives</h2><p>在上一节文章中我们使用 variable 避免了开发中动态拼凑 query 语句。然而在实际开发过程中我们可能还需要动态的改变 query 的结构，并通过变量来控制query结构的变化。假设以下的情况：有一个UI组件，它包含一个简介界面和一个详细页面，详细页面包含更多的信息。那么我们可以构造以下的 query： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># query</span><br><span class="line">query Hero($episode: Episode, $withFriends: Boolean!) &#123;</span><br><span class="line">  hero(episode: $episode) &#123;</span><br><span class="line">    name</span><br><span class="line">    friends @include(if: $withFriends) &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"># variables</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;episode&quot;</span>: <span class="string">&quot;JEDI&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;withFriends&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 返回的数据</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;hero&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;R2-D2&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在上边的query中，改变 <code>withFriends</code> 的值会改变 query 返回的结果的结构。</p><p>这是 GraphQL 的一个特性，称为 <em>directive</em> 。它可以被应用于数据域和 fragment 中，它会影响服务端对query的执行。GraphQL 核心规范只包含以下两个指令，任何与规范兼容的服务器都要支持这两个指令（服务器端可以自定义增加指令）： - <code>@include(if: Boolean)</code> 只在参数为 <code>true</code> 的时候包含这个数据域 - <code>@skip(if: Boolean)</code> 在参数为 <code>true</code> 的时候省略这个数据域</p><h2 id="mutations">Mutations</h2><p>简单来说，query是从服务器获取数据，mutation 是向服务器发送数据。与 query 相同，mutation 也可以返回数据。这对于你获取数据更新后的状态很有用： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) &#123;</span><br><span class="line">  createReview(episode: $ep, review: $review) &#123;</span><br><span class="line">    stars</span><br><span class="line">    commentary</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"># variables</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;ep&quot;</span>: <span class="string">&quot;JEDI&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;review&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;stars&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;commentary&quot;</span>: <span class="string">&quot;This is a great movie!&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;createReview&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;stars&quot;</span>: <span class="number">5</span>,</span><br><span class="line">      <span class="attr">&quot;commentary&quot;</span>: <span class="string">&quot;This is a great movie!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="multiple-fields-in-mutations">Multiple fields in mutations</h3><p>与query一样，一个query中可以包含多个数据域，一个 mutation 中也可以包含多个数据域。但是它们有一个不同点是 query 中的每个数据域都是并行执行的，而mutation中的多个数据域是串行依次执行的。只有前一个执行完成后下一个才能执行。</p><h2 id="inline-fragments">Inline fragments</h2><p>如果你的query返回的是接口或 union 类型，那么需要使用 <em>inline fragment</em> 来访问底层的数据，参考下边的例子： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># query</span><br><span class="line">query HeroForEpisode($ep: Episode!) &#123;</span><br><span class="line">    hero(episode: $ep) &#123;</span><br><span class="line">        name</span><br><span class="line">        ... on Droid &#123;</span><br><span class="line">            primaryFunction</span><br><span class="line">        &#125;</span><br><span class="line">        ... on Human &#123;</span><br><span class="line">            height</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># variables</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;ep&quot;</span>: <span class="string">&quot;HEDI&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;hero&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;R2-D2&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;primaryFunction&quot;</span>: <span class="string">&quot;Astromech&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在上边的例子中，<code>hero</code> 数据域返回值类型是 <code>Character</code>。根据参数的类型，它可能是 <code>Human</code> 或 <code>Droid</code> 中的一个。在老的查询中，你只能要求返回 <code>Character</code> 中存在的数据，比如 <code>name</code>。</p><p>为了请求底层具体的数据类型，你必须使用指定数据类型的 <code>inline fragment</code> 来实现。如果 <code>Character</code> 是 <code>Droid</code> 类型的，由于 <code>... on Droid</code> 的存在，会返回 <code>primaryFunction</code> 数据域；如果 <code>Character</code> 是 <code>Human类型</code>， 返回 <code>height</code> 数据域。</p><p>有自己命名的 fragment 也可以这样使用，因为fragment 永远都是类型明确的。</p><h3 id="meta-fields">Meta fields</h3><p>假设某些情况下，你无法预知 GraphQL 服务器端返回的数据的类型，为了处理返回的数据，你需要在客户打断判断数据的类型。 GraphQL 允许请求 <code>__typename</code> 这个 meta field 来获取对象的类型。 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  search(text: <span class="string">&quot;an&quot;</span>) &#123;</span><br><span class="line">    __typename</span><br><span class="line">    ... on Human &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Droid &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Starship &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;search&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;__typename&quot;</span>: <span class="string">&quot;Human&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Han Solo&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;__typename&quot;</span>: <span class="string">&quot;Human&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Leia Organa&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;__typename&quot;</span>: <span class="string">&quot;Starship&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;TIE Advanced x1&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 上边的例子中， <code>search</code> 返回一个 union 类型，这个 union 可能是三种数据类型中的一种。那么客户端就无法在没有 <code>__typename</code> 的情况下区分返回的数据类型。</p><p>GraphQL 服务提供一系列的 meta fields,参考 <a href="https://graphql.org/learn/introspection/">Introspection System</a>。</p><h2 id="graphql-vs-rest">GraphQL VS REST</h2><table><thead><tr class="header"><th>项目</th><th>GraphQL</th><th>REST</th></tr></thead><tbody><tr class="odd"><td>参数传递</td><td>每个数据域、内嵌对象都可以包含自己的参数，使一个GraphQL查询可以代替多个REST调用</td><td>只能在URL、查询参数中传递低</td></tr></tbody></table><h2 id="参考">参考</h2><p><a href="https://www.howtographql.com/">HOW TO GRAPHQL</a></p><p><a href="https://graphql.org/learn/">GraphQL</a></p><p>TO BE CONTINUED ...</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是笔者学习 GraphQL 的笔记，参考了 GraphQL.org 的官方文档。本文仅做学习记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;graphql-简介&quot;&gt;GraphQL 简介&lt;/h2&gt;
&lt;p&gt;Graphql 是一种面向 A</summary>
      
    
    
    
    <category term="Graphql" scheme="https://www.zhangyuzheng.com/categories/Graphql/"/>
    
    
    <category term="Android" scheme="https://www.zhangyuzheng.com/tags/Android/"/>
    
    <category term="Graphql" scheme="https://www.zhangyuzheng.com/tags/Graphql/"/>
    
    <category term="Apollo-Android" scheme="https://www.zhangyuzheng.com/tags/Apollo-Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 应用开发基础知识杂记</title>
    <link href="https://www.zhangyuzheng.com/%E9%87%8D%E5%AD%A6Android/AndroidAppFundamentals/"/>
    <id>https://www.zhangyuzheng.com/%E9%87%8D%E5%AD%A6Android/AndroidAppFundamentals/</id>
    <published>2020-03-11T15:40:00.000Z</published>
    <updated>2021-08-14T03:53:53.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="android-资源分类">Android 资源分类</h2><table><colgroup><col style="width: 37%" /><col style="width: 62%" /></colgroup><thead><tr class="header"><th>目录</th><th>资源类型</th></tr></thead><tbody><tr class="odd"><td>animator</td><td>定义<a href="https://developer.android.com/guide/topics/graphics/prop-animation">属性动画</a>的 XML 文件</td></tr><tr class="even"><td>anim</td><td>定义 <a href="https://developer.android.com/guide/topics/graphics/view-animation#tween-animation">tween 动画</a>的 XML 文件（属性动画的 XML 文件也可以放在这里，但最好把这两类动画区分开）</td></tr><tr class="odd"><td>color</td><td>定义颜色的 XML 文件，参考 <a href="https://developer.android.com/guide/topics/resources/color-list-resource">Color State List Resource</a></td></tr><tr class="even"><td>drawable</td><td>位图文件(.png .9.png .jpg .gif)，编译成以下drawable 子类型的 XML 文件: Bitmap、 9-pathes、 State lists、Shapes、Animation drawables 等,参考 <a href="https://developer.android.com/guide/topics/resources/drawable-resource">Drawable Resources</a></td></tr><tr class="odd"><td>mipmap</td><td>不同屏幕密度的启动图标定义，参考<a href="https://developer.android.com/tools/projects#mipmap">Managing Projects Overview</a></td></tr><tr class="even"><td>layout</td><td>界面布局 XML 文件，参考 <a href="https://developer.android.com/guide/topics/resources/layout-resource">Layout Resource</a></td></tr><tr class="odd"><td>menu</td><td>定义菜单的 XML 文件，例如 Option Menu、Context Menu、Sub Menu，参考 <a href="https://developer.android.com/guide/topics/resources/menu-resource">Menu Resources</a></td></tr><tr class="even"><td>raw</td><td>使用原始格式保存的任意文件。调用 Resources.openRawResource(R.raw.filename) 来打开此类文件的 InputStream 。如果你需要访问原始的文件和文件夹结构，那么你可以考虑把文件放到 <code>assets</code> 目录，而不是 <code>res/raw</code> 目录下。<code>assets</code> 目录下的文件是没有资源 ID 的，只能通过 <a href="https://developer.android.com/reference/android/content/res/AssetManager">AssetManager</a> 来访问</td></tr><tr class="odd"><td>values</td><td>保存简单数据的 XML 文件。在 res 目录下的各个 XML 文件都是用唯一的 ID 来标识一个文件的，。但是这里的一个 XML 文件会包含多个资源，每个资源的标签都会定义一个资源，比如 <string> 定义一个字符串，使用 R.string.xxx 访问，<color> 标签定义个 R.color.xx。通常为了代码结构清晰，根据惯例使用以下几个 XML 文件来定义对应类型的资源（你当然可以把所有资源的定义都放在一个 XML 中）： <a href="https://developer.android.com/guide/topics/resources/more-resources#TypedArray">arrays.xml</a> 、<a href="https://developer.android.com/guide/topics/resources/more-resources#Color">colors.xl</a>、 <a href="https://developer.android.com/guide/topics/resources/more-resources#Dimension">strings</a>、<a href="https://developer.android.com/guide/topics/resources/style-resource">styles.xml</a></td></tr><tr class="even"><td>xml</td><td>任意 XML 文件，通过 <a href="https://developer.android.com/reference/android/content/res/Resources#getXml(int)">Resources.getXML()</a> 来访问。</td></tr><tr class="odd"><td>font</td><td>字体文件和包含 <font-family> 的 XML 文件，参考 <a href="https://developer.android.com/preview/features/fonts-in-xml">Fonts in XML</a></td></tr></tbody></table><blockquote><p>关于资源的更多资料，参考 <a href="https://developer.android.com/guide/topics/resources/available-resources">Resource Types</a></p></blockquote><h2 id="configuration-qualifiers">Configuration qualifiers</h2><table><thead><tr class="header"><th>Configuration</th><th>Qualifier Values</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>MCC &amp; MNC</td><td>比如：mcc310、mcc310-mnc004</td><td>根据<a href="https://developer.android.com/reference/android/content/res/Configuration#mcc">国家</a>、<a href="https://developer.android.com/reference/android/content/res/Configuration#mnc">运营商</a>选择资源</td></tr><tr class="even"><td>语言与区域</td><td>比如：en、zh-CN、fr-rCA</td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;android-资源分类&quot;&gt;Android 资源分类&lt;/h2&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 37%&quot; /&gt;
&lt;col style=&quot;width: 62%&quot; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr cla</summary>
      
    
    
    
    <category term="重学Android" scheme="https://www.zhangyuzheng.com/categories/%E9%87%8D%E5%AD%A6Android/"/>
    
    
    <category term="Android" scheme="https://www.zhangyuzheng.com/tags/Android/"/>
    
    <category term="应用程序" scheme="https://www.zhangyuzheng.com/tags/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    
    <category term="基础" scheme="https://www.zhangyuzheng.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>MacOS 安装 Jdk11,并在多 Jdk 间切换</title>
    <link href="https://www.zhangyuzheng.com/DailyNotes/MacOS%E5%AE%89%E8%A3%85JDK11/"/>
    <id>https://www.zhangyuzheng.com/DailyNotes/MacOS%E5%AE%89%E8%A3%85JDK11/</id>
    <published>2020-02-12T04:03:00.000Z</published>
    <updated>2021-08-14T03:53:53.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="macos-安装-jdk11">MacOS 安装 Jdk11</h1><ol type="1"><li><p>在 <a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html">此处</a> 下载Jdk 11。这是此时最新的 LTS 版本。</p></li><li><p>解压缩安装 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -xvf jdk-11.0.6_osx-x64_bin.tar.gz -C /Library/Java/JavaVirtualMachines/</span><br></pre></td></tr></table></figure></p></li><li><p>查看是否安装成功 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行此命令</span></span><br><span class="line">java -version</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以看见系统默认的 java 已经切换到了新版本</span></span><br><span class="line">java version &quot;11.0.6&quot; 2020-01-14 LTS</span><br><span class="line">Java(TM) SE Runtime Environment 18.9 (build 11.0.6+8-LTS)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.6+8-LTS, mixed mode)</span><br></pre></td></tr></table></figure></p></li><li><p>查看系统所有已安装的 Jdk <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行此命令</span></span><br><span class="line">/usr/libexec/java_home -V</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出</span></span><br><span class="line">Matching Java Virtual Machines (2):</span><br><span class="line">    11.0.6, x86_64:&quot;Java SE 11.0.6&quot;/Library/Java/JavaVirtualMachines/jdk-11.0.6.jdk/Contents/Home</span><br><span class="line">    1.8.0_192, x86_64:&quot;Java SE 8&quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_192.jdk/Contents/Home</span><br><span class="line"></span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk-11.0.6.jdk/Contents/Home</span><br></pre></td></tr></table></figure></p></li><li><p>在不同的 Jdk 版本之间切换： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换到 Jdk1.8</span></span><br><span class="line">export JAVA_HOME=$(/usr/libexec/java_home -v 1.8)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证切换结果</span></span><br><span class="line">java -version</span><br><span class="line"><span class="meta">#</span><span class="bash"> 已切换到 Jdk1.8</span></span><br><span class="line">java version &quot;1.8.0_192&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_192-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.192-b12, mixed mode)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到 Jdk11</span></span><br><span class="line">export JAVA_HOME=$(/usr/libexec/java_home -v 11)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证切换结果</span></span><br><span class="line">java -version</span><br><span class="line"><span class="meta">#</span><span class="bash"> 已切换到 Jdk11</span></span><br><span class="line">java version &quot;11.0.6&quot; 2020-01-14 LTS</span><br><span class="line">Java(TM) SE Runtime Environment 18.9 (build 11.0.6+8-LTS)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.6+8-LTS, mixed mode)</span><br></pre></td></tr></table></figure></p></li></ol><blockquote><p>在第一步下载 Jdk 时网站会需要你登录。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;macos-安装-jdk11&quot;&gt;MacOS 安装 Jdk11&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;在 &lt;a href=&quot;https://www.oracle.com/technetwork/java/javase/downloads/jdk11-d</summary>
      
    
    
    
    <category term="DailyNotes" scheme="https://www.zhangyuzheng.com/categories/DailyNotes/"/>
    
    
    <category term="MacOS" scheme="https://www.zhangyuzheng.com/tags/MacOS/"/>
    
    <category term="Jdk" scheme="https://www.zhangyuzheng.com/tags/Jdk/"/>
    
    <category term="安装" scheme="https://www.zhangyuzheng.com/tags/%E5%AE%89%E8%A3%85/"/>
    
    <category term="Jdk切换" scheme="https://www.zhangyuzheng.com/tags/Jdk%E5%88%87%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Get Started with Express</title>
    <link href="https://www.zhangyuzheng.com/Express/GetStartedWithExpress/"/>
    <id>https://www.zhangyuzheng.com/Express/GetStartedWithExpress/</id>
    <published>2018-11-03T11:15:00.000Z</published>
    <updated>2018-11-06T11:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文参考 <a href="https://expressjs.com/en/guide/routing.html">https://expressjs.com/en/guide/routing.html</a> 。</p></blockquote><p>[TOC]</p><h1 id="routing">Routing</h1><h2 id="路由routing">路由（Routing）</h2><p>路由就是特定URL与其对应的请求处理函数的映射，一个URL可以对应多个处理函数（译注：就是一个URL可以对应一个或多个回调函数，下文将处理函数都称为回调函数）。在同一个URL对应多个回调函数的情况下，回调函数的参数就不仅仅是 <code>req</code> 和 <code>res</code>，还要增加一个 <code>next</code>，在回调函数中要在最后主动调用 <code>next()</code> 将请求交给下一个回调函数处理，比如： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line">app = express();</span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, req, next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="路由方式route-methods">路由方式（Route methods）</h2><p>路由的方式来自于 HTTP 协议的请求方式，包括 GET、POST、PUT、DELETE、HEAD等，具体参考 <a href="https://expressjs.com/en/4x/api.html#app.METHOD">app.METHOD</a>。 express 有个一特殊的路由方式 <code>all</code>， 他用来处理对某个URL的任意方式的请求（包括了所有的HTTP请求方式）。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.all(<span class="string">&#x27;/secret&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Accessing the secret session&#x27;</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="路由路径route-paths">路由路径（Route paths）</h2><p>路径与请求方式排列组合确定了哪些路径可以响应哪些请求。路径可以是字符串、字符串模式和正则表达式。<code>?+*()</code>这几个符号按照正则表达式规则来解析，<code>-.</code> 按照字面意思来解析。如果在路径中使用<code>$</code>符号，必须使用<code>[]</code> 扩上它来进行转义，比如 '/data/$book' 要写成 <code>/data/[\$]book</code>。 &gt; express 使用 <a href="https://www.npmjs.com/package/path-to-regexp">path-to-regexp</a> 进行路径匹配，可以查阅他的文档来确定路径的定义。<a href="http://forbeslindesay.github.io/express-route-tester/">Express Route Tester</a> 是一个非常好用的工具，用来测试 Express的基本路由。路径中的查询字符串不属于路径定义的范围。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1) 字符串匹配</span></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">&#x27;/hello.text&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;hello.text&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2) 字符串模式匹配</span></span><br><span class="line">app.get(<span class="string">&#x27;/ab?cd&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// acd, abcd</span></span><br><span class="line">    res.send(<span class="string">&#x27;ab?cd&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">&#x27;/ab+cd&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// abcd, abbcd,abbbcd,......</span></span><br><span class="line">    res.send(<span class="string">&#x27;ab+cd&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">&#x27;/ab*cd, fucntion(req, res)&#123;</span></span><br><span class="line"><span class="string">    // abcd, abxcd, abRANDOMcd,ab123cd,.....</span></span><br><span class="line"><span class="string">    res.send(&#x27;</span>ab*cd<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">&#125;&#x27;</span>);</span><br><span class="line">app.get(<span class="string">&#x27;/ab(cd)?e&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// abe, abcde</span></span><br><span class="line">    res.send(<span class="string">&#x27;ab(cd)e&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 正则表达式匹配</span></span><br><span class="line">app.get(<span class="regexp">/a/</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 任意包含a的路径</span></span><br><span class="line">    res.send(<span class="string">&#x27;/a/&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="regexp">/.*fly$/</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// butterfly, dragonfly, not butterflyman, dragonflyman</span></span><br><span class="line">    res.send(<span class="string">&#x27;/.*fly$/&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="路由参数route-parameters">路由参数（Route parameters）</h2><p>即URL中的动态部分（译注：不是query string），保存在 <code>req.params</code> 中，名字就是路由中定义的参数名字，参数的名字只能包括ASCII字母和数字，a-zA-Z0-9； <code>-</code> 和 <code>.</code> 不作特别处理，按照字面原意处理；参数后可以用 <code>()</code> 包含正则表达式。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 字符串参数</span><br><span class="line">Route path: /users/:userId/books/:bookId</span><br><span class="line">Request URL: http://localhost:3000/users/34/books/8989</span><br><span class="line">req.params: &#123; &quot;userId&quot;: &quot;34&quot;, &quot;bookId&quot;: &quot;8989&quot; &#125;</span><br><span class="line">// - 与 . 不作特别解析</span><br><span class="line">Route path: /flights/:from-:to</span><br><span class="line">Request URL: http://localhost:3000/flights/LAX-SFO</span><br><span class="line">req.params: &#123; &quot;from&quot;: &quot;LAX&quot;, &quot;to&quot;: &quot;SFO&quot; &#125;</span><br><span class="line">Route path: /plantae/:genus.:species</span><br><span class="line">Request URL: http://localhost:3000/plantae/Prunus.persica</span><br><span class="line">req.params: &#123; &quot;genus&quot;: &quot;Prunus&quot;, &quot;species&quot;: &quot;persica&quot; &#125;</span><br><span class="line">// 参数中增加正则表达式</span><br><span class="line">Route path: /user/:userId(\d+)</span><br><span class="line">Request URL: http://localhost:3000/user/42</span><br><span class="line">req.params: &#123;&quot;userId&quot;: &quot;42&quot;&#125;</span><br></pre></td></tr></table></figure></p><h2 id="路由回调route-handler">路由回调（Route handler）</h2><p>利用路由回调函数的 <code>next</code> 函数可以实现对某些请求的预处理，如果本回调不需要处理，可以直接调用 <code>next()</code>跳过当前回调。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最简单的回调</span></span><br><span class="line">app.get(<span class="string">&#x27;/example/a&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;Hello from A&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 多个回调处理同一个请求</span></span><br><span class="line">app.get(<span class="string">&#x27;/example/b&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;the response will be sent by next handler&#x27;</span>);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;Hello form B&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 回调数组处理同一个请求</span></span><br><span class="line"><span class="keyword">var</span> cb0 = <span class="function"><span class="keyword">function</span>(<span class="params">req,res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;CB0&#x27;</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cb1= <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    consol.log(<span class="string">&#x27;CB1&#x27;</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cb2 = <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;Hello from C&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">app.get(<span class="string">&#x27;/example/c&#x27;</span>, [cb0, cb1, cb2]);</span><br><span class="line"><span class="comment">// 回调数组与普通回调可以组合使用</span></span><br><span class="line"><span class="keyword">var</span> cb0 = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;CB0&#x27;</span>)</span><br><span class="line">    next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cb1 = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;CB1&#x27;</span>)</span><br><span class="line">    next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/example/d&#x27;</span>, [cb0, cb1], <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;the response will be sent by the next function ...&#x27;</span>)</span><br><span class="line">    next()</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;Hello from D!&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="响应方法response-methon">响应方法（Response methon）</h2><p>下面表中的函数可以向客户端发送响应，并结束一次请求响应的过程，如果不调用一下函数，客户断的请求将不会终止。 方法支持 说明 res.download() 提示客户端下载文件 res.end() 结束响应流程 res.json() 发送JSON响应 res.jsonp() 发送支持JSONP的JSON响应 res.redirect() 重定向请求 res.render() 渲染视图模板响应请求 res.send() 发送多种类型的响应 res.sendFile() 将文件作为octet stream响应发出去 res.sendStatus() 发送状态码，并将状态码的字符表示作为响应体发送</p><h2 id="app.route">app.route()</h2><p>使用 <code>app.route()</code> 来链式创建路由回调，可以减少冗余代码和避免拼写错误。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.route(<span class="string">&#x27;/book&#x27;</span>)</span><br><span class="line">    .get(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;Get a random book&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .post(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">        res.send(<span class="string">&#x27;Add a book&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .put(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">        res.send(<span class="string">&#x27;Update a book&#x27;</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><h2 id="express.router">express.Router()</h2><p>使用 <code>express.Router</code> 类可以创建模块化、可加载的路由回调函数。<code>Router</code> 实例是是完整的中间件和路由系统，因此它也经常被称为 "mini-app" 。 创建名为 <code>birds.js</code> 的路由文件： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义此路由的中间件</span></span><br><span class="line">router.use(<span class="function"><span class="keyword">function</span> <span class="title">timeLog</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Time:&#x27;</span>, <span class="built_in">Date</span>.now());</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 定义根页面路由</span></span><br><span class="line">router.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;bird home page&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">router.get(<span class="string">&#x27;/about&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;About birds&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure> 在app中载入路由模块： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> birds = <span class="built_in">require</span>(<span class="string">&#x27;./birds&#x27;</span>)</span><br><span class="line">app.use(<span class="string">&#x27;/birds&#x27;</span>, birds);</span><br></pre></td></tr></table></figure> 这样 app 就可以处理 <code>/birds</code> 和 <code>/birds/about</code> 的请求了。</p><h1 id="writing-middleware-for-use-in-express-apps">Writing middleware for use in Express apps</h1><h2 id="简介overview">简介（Overview）</h2><p>中间件能够在一次请求响应循环中访问所有 req、res 和 next 。在中间件中调用 next 函数表示当前中间件执行成功。中间件可以： - 执行任意代码 - 改变请求 req和响应res 对象 - 结束请求-响应循环 - 调用下一个中间件 中间件执行完毕必须调用 next 函数，交给下一个中间件继续处理请求，如果不调用 next 函数，the request will be left hanging （译注：翻译不好这句话，自己体会吧）。</p><p>中间件对应的请求方式，比如get、post、delete等 中间件需要处理的路径 中间件回调函数定义 下一个中间件的回调函数，按照传统，称为next 此中间件的HTTP响应参数，称为res 此中间件的HTTP请求参数，称为req</p><h2 id="实例example">实例（Example）</h2><p>本实例包括两个中间件，一个叫做 myLogger，打印一句简单的 log；另一个叫 requestTime，打印HTTP请求的时间戳。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;Hello world&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p><h3 id="mylogger-中间件">myLogger 中间件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myLogger =  <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;LOGGED&#x27;</span>);</span><br><span class="line">    <span class="comment">// 调用 next 函数将请求交给下一个中间件处理</span></span><br><span class="line">    next();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="requesttime-中间件">requestTime 中间件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestTime = <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    req.requestTime = <span class="built_in">Date</span>.now();</span><br><span class="line">    next();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(requestTime);</span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">`<span class="subst">$&#123;req.requestTime&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="可配置的中间件configurable-middleware">可配置的中间件（Configurable middleware）</h2><p>在使用时，传递参数给中间件。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> configurableMiddleware = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// whatever you do with options here</span></span><br><span class="line">        next();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 你也可以把中间件单独写在单独module中，通过 <code>module.exports</code> 供外界使用。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// configurableMiddleware.js</span></span><br><span class="line"><span class="keyword">var</span> configurableMiddleware = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// whatever you do with options here</span></span><br><span class="line">        next();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = configurableMiddleware;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line">cmw = <span class="built_in">require</span>(<span class="string">&#x27;./configurableMiddleware&#x27;</span>);</span><br><span class="line">app.user(cmw(&#123;<span class="attr">option1</span>: <span class="string">&#x27;o1 value&#x27;</span>&#125;));</span><br></pre></td></tr></table></figure><h1 id="使用中间件using-middleware">使用中间件（Using middleware）</h1><p>Express 自身功能很少，是依赖路由和中间件的 web 框架：一个 Express App基本上就是一个路由和中间件的集合。 如果当前中间件不想结束当前处理的请求-响应过程，它必须调用 <code>next()</code>，将请求交给下一个中间件处理。 Express App可以使用以下4类中间件： - 应用级中间件 - 路由级中间件 - 错误处理中间件 - 内置中间件 - 三方中间件</p><h2 id="应用级中间件application-level-middleware">应用级中间件（Application-level middleware）</h2><p>使用 <code>app.user()</code> 和 <code>app.METHOND()</code> 来将中间件绑定到application中。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="comment">// 与路径无关的中间件（middleware with no mount point）</span></span><br><span class="line">app.user(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;middleware with no mount point&#x27;</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 与路径相关的中间件</span></span><br><span class="line"><span class="comment">// 这种多个中间件一起称为middleware sub-stack</span></span><br><span class="line">app.user(<span class="string">&#x27;/user/:id&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;user mounted middleware 0&#x27;</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;, <span class="function"><span class="title">fucntion</span>(<span class="params">req, res, next</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;user mounted middleware 1&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure> 调用 <code>next('route')</code> 跳过middleware stack中的剩余中间件（只对app.METHOD和router.METHOD两类方法载入的中间件生效）。</p><h2 id="路由级中间件">路由级中间件</h2><p>路由级中间件与应用级中间件没有区别，只是路由级的中间件绑定到 <code>express.Router()</code> 对象。使用 <code>router.user()</code> 和 <code>router.METHOD()</code> 来绑定路由级中间件。使用 <code>next('router')</code> 跳过当前middleware substack的剩余中间件。 &gt; 路由级中间件与应用级中间件使用方法一致，此处跳过实例代码。</p><h2 id="错误处理中间件error-handling-middleware">错误处理中间件（Error-handling middleware）</h2><blockquote><p>错误处理中间件回调函数的参数是4个，必须提供4个参数的中间件回调函数来标识这是一个错误处理中间件。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line">app = express();</span><br><span class="line"><span class="comment">// 注意错误处理函数的形式（函数签名）：4个参数，第一个参数为error。</span></span><br><span class="line">app.user(<span class="function"><span class="keyword">function</span>(<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err.stack);</span><br><span class="line">    res.status(<span class="number">500</span>).send(<span class="string">&#x27;Somethind broken&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure> ## 内置中间件（Built-in middleware） Express 内置的中间件包括： - <code>express.static</code>：提供静态资源供访问。 - <code>express.json</code>：解析请求中包含的JSON数据。 - <code>express.urlencoded</code>：解析请求中URL-encoded 数据。</p></blockquote><h2 id="三方中间件third-party-middleware">三方中间件（Third-party middleware）</h2><p>安装第三方中间件并载入到 Express 应用中。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cookie-parser</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br><span class="line">var cookieParser = require(&#x27;cookie-parser&#x27;);</span><br><span class="line">app = express();</span><br><span class="line">app.use(cookieParser());</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文参考 &lt;a href=&quot;https://expressjs.com/en/guide/routing.html&quot;&gt;https://expressjs.com/en/guide/routing.html&lt;/a&gt; 。&lt;/p&gt;
&lt;/blockquot</summary>
      
    
    
    
    <category term="Express" scheme="https://www.zhangyuzheng.com/categories/Express/"/>
    
    
    <category term="Express" scheme="https://www.zhangyuzheng.com/tags/Express/"/>
    
  </entry>
  
  <entry>
    <title>启用math支持</title>
    <link href="https://www.zhangyuzheng.com/Hexo/hexo-enable-mathjax/"/>
    <id>https://www.zhangyuzheng.com/Hexo/hexo-enable-mathjax/</id>
    <published>2018-06-06T03:01:52.000Z</published>
    <updated>2021-08-14T03:53:53.478Z</updated>
    
    <content type="html"><![CDATA[<ol type="1"><li>Next 主题中启用Math支持,默认使用 Mathjax 渲染： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># theme/next/_config.yml</span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">engine:</span> <span class="string">mathjax</span></span><br></pre></td></tr></table></figure></li><li>使用 hexo-renderer-pandoc 渲染页面: <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line">npm i hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure></li><li>重新生成网站、部署： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure></li><li>使用： 在 Next 主题中，必须把 LaTeX 公式放在 <code>equation</code> 环境中，而不是 Markdown 标准的两个 <code>$</code> 符号中间，比如： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$\begin&#123;equation&#125;</span><br><span class="line">e=mc^2</span><br><span class="line">\end&#123;equation&#125;\label&#123;eq1&#125;$$</span><br></pre></td></tr></table></figure> 显示为： <span class="math display">\[\begin{equation}e=mc^2\end{equation}\label{eq1}\]</span></li></ol><p>在文章的其他地方，可以用 label 来引用公式，比如： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">著名的质能方程 $\eqref&#123;eq1&#125;$ 由爱因斯坦提出 ...</span><br><span class="line"></span><br></pre></td></tr></table></figure> 显示为： 著名的质能方程 <span class="math inline">\(\eqref{eq1}\)</span> 由爱因斯坦提出 ...</p><blockquote><p>参考官方文档 <a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/MATH.md">Math</a> 。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Next 主题中启用Math支持,默认使用 Mathjax 渲染： &lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/</summary>
      
    
    
    
    <category term="Hexo" scheme="https://www.zhangyuzheng.com/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://www.zhangyuzheng.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>A Tour of the Dart Language</title>
    <link href="https://www.zhangyuzheng.com/Dart/ATourofTheDartLanguage/"/>
    <id>https://www.zhangyuzheng.com/Dart/ATourofTheDartLanguage/</id>
    <published>2018-06-01T06:15:00.000Z</published>
    <updated>2020-01-09T11:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文见：<a href="https://www.dartlang.org/guides/language/language-tour">A Tour of the Dart Language</a></p></blockquote><p>本文将为你展示Dart语言的主要特性，包括从变量、操作符到类、库等一系列内容。本文默认你已经有了其他编程语言基础。</p><p>学习更多关于Dart核心库的内容可以参考<a href="https://www.dartlang.org/guides/libraries/library-tour">A Tour of the Dart Libraries</a>。关于Dart语言更多的详细内容可以参考<a href="https://www.dartlang.org/guides/language/spec">Dart Language Specification</a>。</p><h2 id="dart基本程序">Dart基本程序</h2><p>下面的代码展示了很多Dart语言最基础的特性：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define a function</span></span><br><span class="line">printInteger(<span class="built_in">int</span> aNumber) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;The number is <span class="subst">$aNumber</span>.&#x27;</span>); <span class="comment">// Print to console.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is where the app starts executing.</span></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> number = <span class="number">42</span>; <span class="comment">// Declare and initialize a variable.</span></span><br><span class="line">  printInteger(number); <span class="comment">// Call a function.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面解释下上方代码展示的特性（适用几乎所有的Dart 应用程序）：</p><p><code>// 注释</code></p><p>单行注释，Dart也支持多行注释和文档注释，参考<a href="https://www.dartlang.org/guides/language/language-tour#comments">Comments</a>。</p><p><code>int</code></p><p>一种数据类型，其他<a href="https://www.dartlang.org/guides/language/language-tour#built-in-types">内置数据类型</a>还有<code>String</code>，<code>List</code>和<code>bool</code>。</p><p><code>print()</code></p><p>显示输出的一种简单方式。</p><p><code>'...'</code>和<code>"..."</code></p><p>字符串常量。</p><p><code>$variableName</code>或<code>$&#123;expression&#125;</code></p><p>字符串插值：字符串常量内包含一个变量或表达式的字符串形式，参考 <a href="https://www.dartlang.org/guides/language/language-tour#strings">Strings</a>。</p><p><code>main()</code></p><p>可执行APP的入口，必需。参考 <a href="https://www.dartlang.org/guides/language/language-tour#the-main-function">The main() function</a>。</p><p><code>var</code></p><p>不指定类型声明变量的一种方式。</p><blockquote><p>本文代码风格遵守 <a href="https://www.dartlang.org/guides/language/effective-dart/style">Dart style guide</a>。</p></blockquote><h2 id="重要概念">重要概念</h2><p>学习 Dart 语言，要时刻牢记以下事实与概念：</p><ul><li>所有变量可以保存的内容都是<em>object</em>。所有的 object 都是 <em>class</em> 的实例。数字、函数、<code>null</code> 都是 object。所有的 object 都继承自 <a href="https://api.dartlang.org/dev/dart-core/Object-class.html">Object</a> 。</li><li>虽然 Dart 是强类型语言，但是类型声明是可选的，因为 Dart 可以推断类型。在上边的代码中，<code>number</code> 被推断为 <code>int</code> 类型。如果需要明确说明任何类型都不需要，可以使用特殊的类型 <a href="https://www.dartlang.org/guides/language/effective-dart/design#do-annotate-with-object-instead-of-dynamic-to-indicate-any-object-is-allowed">dynamic</a> 。</li><li>Dart 支持泛型，比如 <code>List&lt;int&gt;</code> 表示整数列表， <code>List&lt;Dynamic&gt;</code> 表示任何类型对象的列表。</li><li>Dart 支持顶层函数，比如 <code>main()</code> ，还支持与 类 、对象关联的函数（即static函数和实例方法）。还支持在函数中创建函数（嵌套函数或者本地函数）。</li><li>类似的，Dart 支持顶层变量，也支持类、对象关联变量（static 或实例变量）。实例变量也称为域或者属性。</li><li>与 Java 不同，Dart 没有 <code>public</code> 、<code>protected</code> 和 <code>private</code> 这些关键字，如果某个标识符以下杠 <code>_</code> 开头，那么那就是库私有的，详细信息参考<a href="https://www.dartlang.org/guides/language/language-tour#libraries-and-visibility">Libraries and visibility</a> 。</li><li><em>标识符</em> 可以以字母或者下杠开头，后边跟热议字符和数字。</li><li>有时候，某些东西究竟是 <em>expression</em> 还是 <em>statement</em> 很重要，他可以帮助精确的区分这两个单词。</li><li>Dart 工具可以报告两类问题：警告与错误。警告仅仅警示代码可能无法工作，但是不会妨碍你运行程序。错误包括编译时错误和运行时错误。编译错误倒是代码完全无法运行。运行时错误会在运行时抛出<a href="https://www.dartlang.org/guides/language/language-tour#exceptions">异常</a>。</li></ul><h2 id="关键字">关键字</h2><p>下面是 Dart 会特殊处理的关键字列表。</p><table><thead><tr class="header"><th>abstract 1</th><th>do</th><th>import 1</th><th>super</th></tr></thead><tbody><tr class="odd"><td>as 1</td><td>dynamic 1</td><td>in</td><td>switch</td></tr><tr class="even"><td>assert</td><td>else</td><td>interface 1</td><td>sync* 2</td></tr><tr class="odd"><td>async 2</td><td>enum</td><td>is</td><td>this</td></tr><tr class="even"><td>async* 2</td><td>export 1</td><td>library 1</td><td>throw</td></tr><tr class="odd"><td>await 2</td><td>external 1</td><td>mixin 1</td><td>true</td></tr><tr class="even"><td>break</td><td>extends</td><td>new</td><td>try</td></tr><tr class="odd"><td>case</td><td>factory 1</td><td>null</td><td>typedef 1</td></tr><tr class="even"><td>catch</td><td>false</td><td>operator 1</td><td>var</td></tr><tr class="odd"><td>class</td><td>final</td><td>part 1</td><td>void</td></tr><tr class="even"><td>const</td><td>finally</td><td>rethrow</td><td>while</td></tr><tr class="odd"><td>continue</td><td>for</td><td>return</td><td>with</td></tr><tr class="even"><td>covariant 1</td><td>get 1</td><td>set 1</td><td>yield 2</td></tr><tr class="odd"><td>default</td><td>if</td><td>static 1</td><td>yield* 2</td></tr><tr class="even"><td>deferred 1</td><td>implements 1</td><td></td><td></td></tr></tbody></table><p>上标为 <sup>1</sup> 的关键字是内置标识符，不要使用内置标识符作为标识符使用。如果使用内置标识符作为类名或类型名会造成编译时错误。</p><p>上标为 <sup>2</sup> 的关键字是 Dart1.0 之后增加的仅仅同步相关保留字。在任何被 <code>async</code> 、<code>async*</code>或 <code>sync*</code> 标记的函数中无法使用 <code>async</code> 、<code>await</code> 或者 <code>yield</code> 作为标识符。参考 <a href="https://www.dartlang.org/guides/language/language-tour#asynchrony-support">Asynchrony support</a> 。</p><p>上表中的其他关键字都是保留字，禁止把它们作为标识符使用。</p><h2 id="变量">变量</h2><p>下面的例子创建并初始化了一个变量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Bob&#x27;</span>;</span><br></pre></td></tr></table></figure><p>变量存储的是引用。名字为 <code>name</code> 的变量包含了一个值为"Bob" 的 <code>String</code> 对象的引用。</p><p><code>name</code> 的类型被推断为<code>String</code> 。不能通过指定类型类改变他的类型。如果对象的类型不限制为某一类型，那么根据<a href="https://www.dartlang.org/guides/language/effective-dart/design#do-annotate-with-object-instead-of-dynamic-to-indicate-any-object-is-allowed">设计指南</a>，可以将它的类型指定为 <code>Object</code> 或 <code>dynamic</code> 。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> name = <span class="string">&#x27;Bob&#x27;</span>;</span><br></pre></td></tr></table></figure><p>另一种方式是显示的声明它可以被推断出的类型：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> name = <span class="string">&#x27;Bob&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意，本文遵守<a href="https://www.dartlang.org/guides/language/effective-dart/design#types">style guide recommendation</a> 对本地变量使用 var 而不指定类型的建议。</p></blockquote><h3 id="默认值">默认值</h3><p>未经初始化的变量的默认值是 <code>null</code> 。即使数字类型也初始化为空，因为数字在 Dart 中也是对象。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> lineCount;</span><br><span class="line"><span class="keyword">assert</span>(lineCount == <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure><blockquote><p>在生产代码中，<code>assert()</code> 调用会被忽略掉。在开发中，<code>assert(condition)</code> 在<em>condition</em> 为非 <code>true</code> 时抛出异常。参考 <a href="https://www.dartlang.org/guides/language/language-tour#assert">Assert</a>。</p></blockquote><h3 id="final-与-const">final 与 const</h3><p>对于一个你永远都不会改变的变量，使用 <code>final</code> 或 <code>const</code> 来标识，可以用来它们来代替关键字 <code>var</code> 或者在指定的类型之前。一个 final 限定的变量只可以被赋值一次；使用const限定的变量是编译时常量（const限定的变量默认就是final的）。final限定的顶层或类变量在第一次被使用时初始化。</p><blockquote><p>注意：实例变量可以用final但是不能用const限定。</p></blockquote><p>下面的例子创建并设置 final 的变量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> name = <span class="string">&#x27;Bob&#x27;</span>； <span class="comment">// 无变量类型标识</span></span><br><span class="line"><span class="comment">// name = &#x27;Alice&#x27;; // 去掉注释，本行会引起错误</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> nickname = <span class="string">&#x27;Bobby&#x27;</span>；</span><br></pre></td></tr></table></figure><p>使用 <code>const</code> 来限定你需要的编译时常量（compile-time constants）。如果 const 变量是类级别的，将它标记为 <code>static const</code> 。在你声明变量并赋值为编译时常量比如数字、字符串或者数字运算的结果时，声明为 const 变量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="number">10000000</span>; <span class="comment">// 压力单元(dynes/cm2)</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">double</span> atm - <span class="number">1.01325</span> * bar; <span class="comment">//标准气压</span></span><br></pre></td></tr></table></figure><p><code>const</code> 关键字不仅仅能声明常量，你还可以用来创建常量值，也可以用来声明构造函数。任何变量都可以包含一个常量值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意: []创建空列表</span></span><br><span class="line"><span class="comment">// const [] 创建一个空、不可变的列表(empty,immutable list, EIL)</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">const</span> []; <span class="comment">// foo是一个 EIL</span></span><br><span class="line"><span class="keyword">final</span> bar = <span class="keyword">const</span> []; <span class="comment">// bar永远都是一个 EIL</span></span><br><span class="line"><span class="keyword">const</span> baz = <span class="keyword">const</span> []; <span class="comment">// baz是编译时的常量 EIL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以修改 非final、非const变量，即使它曾经被赋值一个const值；</span></span><br><span class="line">foo = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是无法修改final或const变量的值。</span></span><br><span class="line"><span class="comment">// bar = []; // Unhandled exception</span></span><br><span class="line"><span class="comment">// baz = []; // Unhandled exception</span></span><br></pre></td></tr></table></figure><p>使用 <code>const</code> 来创建常量值，参考 <a href="https://www.dartlang.org/guides/language/language-tour#lists">Lists</a> 、<a href="https://www.dartlang.org/guides/language/language-tour#maps">Maps</a> 和 <a href="https://www.dartlang.org/guides/language/language-tour#classes">Classes</a> 。</p><h2 id="内置类型">内置类型</h2><p>Dart 语言对以下类型有特别支持：</p><ul><li>numbers</li><li>strings</li><li>booleans</li><li>lists(也就是 arrays)</li><li>maps</li><li>runes(在字符串中展示 Unicode 字符)</li><li>symbols</li></ul><p>你可以用常量初始化以上任意类型的对象。比如 <code>this is a string</code> 是字符串常量， <code>true</code> 是布尔型常量。</p><p>由于 Dart 中任何的变量都引用一个对象，你可以使用构造函数来时初始化变量。一些内置类型也有它们自己的构造函数。比如你可以用 <code>Map()</code> 来创建一个map，代码可能是 <code>new Map()</code> 。</p><h3 id="数字">数字</h3><p>Dart 只有两种类型的数字：</p><p><a href="https://api.dartlang.org/dev/dart-core/int-class.html">int</a></p><p>依赖平台，不大于64 bit 长度 。在Dart VM上，数值范围：-2<sup>63</sup> - 2<sup>63</sup> - 1。</p><p><a href="https://api.dartlang.org/dev/dart-core/double-class.html">double</a>。</p><p>64位浮点数，符合IEEE754标准。</p><p><code>int</code> 和 <code>double</code> 都是<a href="https://api.dartlang.org/dev/dart-core/num-class.html">num</a> 的子类，基本的数学运算符+、-、*、/ 都适用这些数字类型，还包括 <code>abs()</code> 、<code>ceil()</code> 和 <code>floor()</code>方法（位操作运算符都定义在 <code>int</code> 类型中）。如果 num 及其子类不包含你需要的操作，可以看下 <code>dart:math</code> 库，可能会包含你需要的函数。</p><p>整数就是没有小数点的数字：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> hex = <span class="number">0xDEADBEEF</span>;</span><br></pre></td></tr></table></figure><p>double类型就是包含小数点的数字：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> y = <span class="number">1.1</span>;</span><br><span class="line"><span class="built_in">double</span> exponents = <span class="number">1.42e5</span>;</span><br></pre></td></tr></table></figure><p>下面的例子展示了如何在数字与字符串之间数据类型转换：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String -&gt; int</span></span><br><span class="line"><span class="keyword">var</span> one = <span class="built_in">int</span>.parse(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">assert</span>(one == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// String -&gt; double</span></span><br><span class="line"><span class="keyword">var</span> onePointOne = <span class="built_in">double</span>.parse(<span class="string">&#x27;1.1&#x27;</span>);</span><br><span class="line"><span class="keyword">assert</span>(ontPointOne == <span class="number">1.1</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// int -&gt; String</span></span><br><span class="line"><span class="built_in">String</span> oneAsString = <span class="number">1.</span>toString();</span><br><span class="line"><span class="keyword">assert</span>(oneAsString == <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// double -&gt; String</span></span><br><span class="line"><span class="built_in">String</span> piAsString = <span class="number">3.14159</span>.toStringAsFixed(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">assert</span>(piAsString == <span class="string">&#x27;3.14&#x27;</span>);</span><br></pre></td></tr></table></figure><p>整型制定了传统的位位移操作（&lt;&lt;, &gt;&gt;），与 (&amp;) 和或 (|)：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>((<span class="number">3</span> &lt;&lt; <span class="number">1</span>) == <span class="number">6</span>);  <span class="comment">// 0011 &lt;&lt; 1 = 0110</span></span><br><span class="line"><span class="keyword">assert</span>((<span class="number">3</span> &gt;&gt; <span class="number">1</span>) == <span class="number">1</span>);  <span class="comment">// 0011 &gt;&gt; 1 == 0001</span></span><br><span class="line"><span class="keyword">assert</span>((<span class="number">3</span> | <span class="number">4</span>) == <span class="number">7</span>);   <span class="comment">// 0011 | 0100 = 0111</span></span><br></pre></td></tr></table></figure><p>原始数字就是编译时常量。很多数学表达式只要他操作数都是编译时常量，那么它也是编译时常量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> msPerSecond = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> secondsUtilRetry = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> msUntilRetry = secondsUtilRetry * secondsUtilRetry;</span><br></pre></td></tr></table></figure><h3 id="strings">Strings</h3><p>Dart 语言中的字符串就是 UTF-16 编码的序列。可以使用单引号或双引号创建字符串：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&#x27;Single quotes work well for string literals.&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">&quot;Double quotes work just as well.&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s3 = <span class="string">&#x27;It\&#x27;s easy to escape the string delimiter.&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> s4 = <span class="string">&quot;It&#x27;s even easier to use the other delimiter.&quot;</span>;</span><br></pre></td></tr></table></figure><p>可以利用 <code>$&#123;expression&#125;</code> 将表达式的值放到字符串中。如果表达式是变量，可以省略 <code>&#123;&#125;</code> 符号。Dart 调用对象的 <code>toString()</code> 方法来获取对象的字符串表示。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;string interpolation&#x27;</span>;</span><br><span class="line"><span class="keyword">assert</span>(<span class="string">&#x27;Dart has <span class="subst">$s</span>, which is very handy.&#x27;</span> ==</span><br><span class="line">      <span class="string">&#x27;Dart has string interpolation,&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;which is very handy.&#x27;</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="string">&#x27;That deserves all caps. &#x27;</span> +</span><br><span class="line">       <span class="string">&#x27;<span class="subst">$&#123;s.toUpperCase()&#125;</span> is very handy!&#x27;</span> ==</span><br><span class="line">       <span class="string">&#x27;That deserves all caps. &#x27;</span> +</span><br><span class="line">       <span class="string">&#x27;STRING INTERPOLATION is very handy!&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>== 操作符用来比较两个对象是否相等。包含相同 UTF-16 码的序列的字符创是相等的。</p></blockquote><p>两个相邻的字符串会自动合并成一个字符串，也可以用 <code>+</code> 来合并字符串：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&#x27;String &#x27;</span></span><br><span class="line">  <span class="string">&#x27;concatenation&#x27;</span></span><br><span class="line">  <span class="string">&#x27; works event over line breaks.&#x27;</span>;</span><br><span class="line"><span class="keyword">assert</span> (s1 ==</span><br><span class="line">        <span class="string">&#x27;String concatenation works even over &#x27;</span></span><br><span class="line">        <span class="string">&#x27;line breaks.&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">&#x27;The + operator &#x27;</span> + <span class="string">&quot;works, as well.&quot;</span>;</span><br><span class="line"><span class="keyword">assert</span>(s2 == <span class="string">&#x27;The + operator works, as well.&#x27;</span>);</span><br></pre></td></tr></table></figure><p>使用三引号创建多行字符串：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">You can creat multi-line strings like this one.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">&quot;&quot;&quot; This is also a </span></span><br><span class="line"><span class="string">multi-line string.&quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><p>你可以使用 <code>r</code> 作为前缀生成 'raw'字符串（译注：指的是所见即所得的字符串，没有任何转义）：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">r&quot;In a raw string, event \n isn&#x27;t special.&quot;</span>;</span><br></pre></td></tr></table></figure><p>关于如何在字符串中显示 Unicode ，参考 <a href="https://www.dartlang.org/guides/language/language-tour#runes">Runes</a> 。</p><p>Literal strings are compile-time constants, as long as any interpolated expression is a compile-time constant that evaluates to null or a numeric, string, or boolean value.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Theses work in a const string.</span></span><br><span class="line"><span class="keyword">const</span> aConstNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> aConstBool = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">const</span> aConstStrng = <span class="string">&#x27;a constant string&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// These do NOT work in a const string</span></span><br><span class="line"><span class="keyword">var</span> aNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> aBool = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">var</span> sString = <span class="string">&#x27;a string&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> aConstList = <span class="keyword">const</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> validConstString = <span class="string">&#x27;<span class="subst">$aConstNum</span> <span class="subst">$aConstBool</span> <span class="subst">$aConstString</span>&#x27;</span>;</span><br><span class="line"><span class="comment">// const invalidConstString = &#x27;$aNum $aBool $aString $aConstList&#x27;;</span></span><br></pre></td></tr></table></figure><p>对String的更多用法，参考 <a href="https://www.dartlang.org/guides/libraries/library-tour#strings-and-regular-expressions">Strings and regular expressions</a>。</p><h3 id="booleans">Booleans</h3><p>为了表示布尔型，Dart 定义了数据类型 <code>bool</code> 。bool 类型只有两个常量对象 <code>true</code> 和 <code>false</code> ，都是编译时常量。</p><p>Dart 语言的类型安全指的是 你不能写这样的代码，比如 <code>if (nonbooleanValue)</code> 或者 <code>assert(nonbooleanValue)</code> 。相反，显示的检查变量的值：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check for an empty string.</span></span><br><span class="line"><span class="keyword">var</span> fullName = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">assert</span>(fullName.isEmpty);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for zero.</span></span><br><span class="line"><span class="keyword">var</span> hitPoints = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">assert</span>(hitPoints &lt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for null.</span></span><br><span class="line"><span class="keyword">var</span> unicorn;</span><br><span class="line"><span class="keyword">assert</span>(unicorn == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for NaN.</span></span><br><span class="line"><span class="keyword">var</span> iMeantToDoThis = <span class="number">0</span> / <span class="number">0</span>;</span><br><span class="line"><span class="keyword">assert</span>(iMeantToDoThis.isNaN);</span><br></pre></td></tr></table></figure><h3 id="lists">Lists</h3><p>几乎所有编程语言都包含的集合类型就是数组了。在Dart中，数组就是 <a href="https://api.dartlang.org/dev/dart-core/List-class.html">List</a> 对象，多数人称其为列表。</p><p>Dart 列表的字符表示与JavaScript的数组表示类似：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><blockquote><p>Dart 分析器会将上边的 list 类型推断为 List<int> 。如果尝试向其中添加非int类型数据，分析器或运行时会抛出错误。详细信息参考 <a href="https://www.dartlang.org/guides/language/sound-dart#type-inference">typr inference</a> 。</p></blockquote><p>List 的下标从0开始，下标为0的元素就是第一个元素，下标为 <code>list.length - 1</code> 的元素就最后一个。你可以与JavaScript语言一样获取列表的长度和获取列表中的元素：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">assert</span>(list.length == <span class="number">3</span>);</span><br><span class="line"><span class="keyword">assert</span>(list[<span class="number">1</span>] == <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">list[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">assert</span>(list[<span class="number">1</span>] == <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>在 list 的字符表示前增加 <code>const</code> 来创建编译时常量 list：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constantList = <span class="keyword">const</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// constantList[1] = 1;  // Uncommenting this cause an error</span></span><br></pre></td></tr></table></figure><p>List 类型有很多操作list的使用方法。更多用法参考 <a href="https://www.dartlang.org/guides/language/language-tour#generics">Generics</a> 和 <a href="https://www.dartlang.org/guides/libraries/library-tour#collections">Collections</a> 。</p><h3 id="maps">Maps</h3><p>通常，一个的映射就是一个相关联的键值的对象。key 和 value 可以是任意类型的对象。在一个映射中，每个key只能出现一次，但是value可以重复。Dart 对映射的支持是由 <a href="https://api.dartlang.org/dev/dart-core/Map-class.html">Map</a> 类型和 map 的字符形式提供的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;</span><br><span class="line">    <span class="comment">// Key:    Value</span></span><br><span class="line">    <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;partridge&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;second&#x27;</span>: <span class="string">&#x27;turtleedoves&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;fifth&#x27;</span>: <span class="string">&#x27;golden rings&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nobleGases = &#123;</span><br><span class="line">    <span class="number">2</span>: <span class="string">&#x27;helium&#x27;</span>,</span><br><span class="line">    <span class="number">10</span>: <span class="string">&#x27;neon&#x27;</span>,</span><br><span class="line">    <span class="number">18</span>: <span class="string">&#x27;argon&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>上边代码中，分析器会将 <code>gifts</code> 被推断为 <code>Map&lt;String, String&gt;</code> 类型。<code>bobleGases</code> 的类型被推断为 <code>Map&lt;int, String&gt;</code> 。如果你想向其中增加错误类型的数据，分析器或运行时会抛出错误。更多信息，参考 <a href="https://www.dartlang.org/guides/language/sound-dart#type-inference">type inference</a> 。</p></blockquote><p>你可以用Map的构造函数创建相同对象：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">gifts[<span class="string">&#x27;first&#x27;</span>] = <span class="string">&#x27;partridge&#x27;</span>;</span><br><span class="line">gifts[<span class="string">&#x27;second&#x27;</span>] = <span class="string">&#x27;turtledoves&#x27;</span>;</span><br><span class="line">gifts[<span class="string">&#x27;fifth&#x27;</span>] = <span class="string">&#x27;golden rings&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nobleGases = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">nobleGases[<span class="number">2</span>] = <span class="string">&#x27;helium&#x27;</span>;</span><br><span class="line">nobleGases[<span class="number">10</span>] = <span class="string">&#x27;neom&#x27;</span>;</span><br><span class="line">nobleGases[<span class="number">18</span>] = <span class="string">&#x27;argon&#x27;</span>;</span><br></pre></td></tr></table></figure><p>向已有map中添加新的键值对：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;<span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;partridges&#x27;</span>&#125;;</span><br><span class="line">gifts[<span class="string">&#x27;forth&#x27;</span>] = <span class="string">&#x27;calling birds&#x27;</span>;  <span class="comment">// Add a key-value pair</span></span><br></pre></td></tr></table></figure><p>从 map 中获取值：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;<span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;partridge&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">assert</span>(gifts[<span class="string">&#x27;first&#x27;</span>] == <span class="string">&#x27;partridge&#x27;</span>);</span><br></pre></td></tr></table></figure><p>如果从map中获取不存在的key的值，反馈 <code>null</code> ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;<span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;partridge&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">assert</span>(gifts[<span class="string">&#x27;fifth&#x27;</span>] == <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>使用 <code>.length</code> 获取map中键值对的数量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;<span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;partridge&#x27;</span>&#125;;</span><br><span class="line">gifts[<span class="string">&#x27;fourth&#x27;</span>] = <span class="string">&#x27;calling birds&#x27;</span>;</span><br><span class="line"><span class="keyword">assert</span>(gifts.length == <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>创建编译时常量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> constantMap = <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;helium&#x27;</span>,</span><br><span class="line">  <span class="number">10</span>: <span class="string">&#x27;neon&#x27;</span>,</span><br><span class="line">  <span class="number">18</span>: <span class="string">&#x27;argon&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constantMap[2] = &#x27;Helium&#x27;; // Uncommenting this causes an error.</span></span><br></pre></td></tr></table></figure><p>关于 map 的更多信息，参考 <a href="https://www.dartlang.org/guides/language/language-tour#generics">Generics</a> 和 <a href="https://www.dartlang.org/guides/libraries/library-tour#maps">Maps</a> 。</p><h3 id="runes">Runes</h3><blockquote><p>译注：此处的runes和符号指的是各类特殊符号，emoji等。</p></blockquote><p>Dart 中，各种符号都是字符串的 UTF-32 码。</p><p>Unicode 为全世界所有书写系统的字母、数字、符号都定义了唯一的数字值。由于 Dart 中使用 UTF-16 表示字符串，为了表示 UTF-32 的符号，需要使用特别的语法。</p><p>表示 Unicode 编码的常用方法是这样的：<code>\uXXXX</code> ， XXXX表示4个16进制数字。比如心形符号♥ 的Unicode是 <code>\u2665</code> 。为了表示多或少于4位16进制数字，把Unicode 放在大括号中，😆 是 <code>\u&#123;1f600&#125;</code> 。</p><p><code>String</code> 类的某些属性可以帮你获取关于符号的信息。<code>codeUnitAt</code> 和 <code>codeUnit</code> 这两个属性获取16位的unicode 码。使用 <code>runes</code> 属性获取字符串中的符号。</p><p>下面的代码展示了符号、16位码、32位码的关系：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> clapping = <span class="string">&#x27;\u&#123;1f44f&#125;&#x27;</span>;</span><br><span class="line">  <span class="built_in">print</span>(clapping);</span><br><span class="line">  <span class="built_in">print</span>(clapping.codeUnits);</span><br><span class="line">  <span class="built_in">print</span>(clapping.runes.toList());</span><br><span class="line"></span><br><span class="line">  Runes input = <span class="keyword">new</span> Runes(</span><br><span class="line">      <span class="string">&#x27;\u2665  \u&#123;1f605&#125;  \u&#123;1f60e&#125;  \u&#123;1f47b&#125;  \u&#123;1f596&#125;  \u&#123;1f44d&#125;&#x27;</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="keyword">new</span> <span class="built_in">String</span>.fromCharCodes(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用list运算符操作符号的时候要特别注意。这种处理方式很容易失败，它依赖于语言、字符集和具体的运算符。更多信息参考 <a href="http://stackoverflow.com/questions/21521729/how-do-i-reverse-a-string-in-dart">Hwo do I reverse a String in Dart?</a> 。</p></blockquote><h3 id="symbols">Symbols</h3><p><a href="https://api.dartlang.org/dev/dart-core/Symbol-class.html">Sumbol</a> 对象表示Dart中的一个操作符和标识符。你可能永远都不会用到 Symbol，因为对于使用名字应用的标识符来说，Symbol是没有值的。'because minification changes identifier names but not identifier symbols ' （译注：没懂什么意思）。</p><p>使用 <code>#</code> 来获取标识符的 symbol：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#radix</span><br><span class="line">#bar</span><br></pre></td></tr></table></figure><p>Symbol 的字面标识是编译时常量。</p><h2 id="functions">Functions</h2><p>Dart 是真正面向对象的语言，所以即使函数也是对象，并且属于 <a href="https://api.dartlang.org/dev/dart-core/Function-class.html">Function</a> 类型。这意味着函数可以用来赋值给变量或者作为参数传递给其他函数。对于函数类的对象，你可以直接调用这个对象，详细信息参考<a href="https://www.dartlang.org/guides/language/language-tour#callable-classes">Callable classes</a> 。</p><p>函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble(<span class="built_in">int</span> atomicNumber) &#123;</span><br><span class="line">    <span class="keyword">return</span> _nobleGases[atomicNumber] == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然Dart建议显示的标明函数的返回值类型，但是如果你省略返回值类型它依然可用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isNoble(atomicNumber) &#123;</span><br><span class="line">  <span class="keyword">return</span> _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于只有一个表达式的函数，可用使用一种简短的语法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble(<span class="built_in">int</span> atomicNumber) =&gt; _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p><code>=&gt;expr</code> 是 <code>return expr</code> 的简短写法。<code>=&gt;</code> 有事被称为胖箭头（<em>fat arrow</em>）语法。</p><blockquote><p>注意：只有表达式可以出现在胖箭头语句中，其他语句不可以。比如你不可以在其中编写 <a href="https://www.dartlang.org/guides/language/language-tour#if-and-else">if</a> 语句，但是可以使用<a href="https://www.dartlang.org/guides/language/language-tour#conditional-expressions">条件表达式</a>。</p></blockquote><h3 id="optional-parameters">Optional parameters</h3><p>可选参数可以通过位置或名字确定，但不能同时通过两者确定。</p><p>Optional named parameters</p><p>调用函数的的时候可以用 <code>paramName:value</code> 指定参数值：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enableFlags(bold: <span class="keyword">true</span>, hiden: <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>定义函数时。使用 <code>&#123;param1, param2&#125;</code> 来指定参数名字：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sets the [bold] and [hiden] flags ...</span></span><br><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold, <span class="built_in">bool</span> hiden&#125;) &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="optional-positional-parameters">Optional positional parameters</h4><p>使用 <code>[]</code> 包含的参数列表来标识 positional 参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg, [<span class="built_in">String</span> device]) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="string">&#x27;<span class="subst">$from</span> says <span class="subst">$msg</span>&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (device != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = <span class="string">&#x27;<span class="subst">$result</span> with a <span class="subst">$device</span>&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用上面的函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Without the optional parameter</span></span><br><span class="line"><span class="keyword">assert</span>(say(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Howdy&#x27;</span>) == <span class="string">&#x27;Bob says Howdy&#x27;</span>);</span><br><span class="line"><span class="comment">// With the optional parameter</span></span><br><span class="line"><span class="keyword">assert</span>(say(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Howdy&#x27;</span>, <span class="string">&#x27;smoke signal&#x27;</span>) == <span class="string">&#x27;Bob says Howdy with a smoke signal&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="default-parameter-values">Default parameter values</h4><p>使用 <code>=</code> 来为可选参数设置默认值。默认值必须是编译时常量。默认的默认值是 <code>null</code> ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">Sets the [bold] and [hidden] flags ...</span></span></span><br><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold = <span class="keyword">false</span>, <span class="built_in">bool</span> hidden = <span class="keyword">false</span>&#125;) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bold will be true; hidden will be false.</span></span><br><span class="line">enableFlags(bold: <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>可选参数的默认值可以如下设置：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg,</span><br><span class="line">    [<span class="built_in">String</span> device = <span class="string">&#x27;carrier pigeon&#x27;</span>, <span class="built_in">String</span> mood]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">&#x27;<span class="subst">$from</span> says <span class="subst">$msg</span>&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (device != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">&#x27;<span class="subst">$result</span> with a <span class="subst">$device</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mood != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">&#x27;<span class="subst">$result</span> (in a <span class="subst">$mood</span> mood)&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(say(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Howdy&#x27;</span>) ==</span><br><span class="line">    <span class="string">&#x27;Bob says Howdy with a carrier pigeon&#x27;</span>);</span><br></pre></td></tr></table></figure><p>也可以使用 list 和 map 作为参数默认值：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> doStuff(</span><br><span class="line">    &#123;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">const</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; gifts = <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;paper&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;second&#x27;</span>: <span class="string">&#x27;cotton&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;third&#x27;</span>: <span class="string">&#x27;leather&#x27;</span></span><br><span class="line">    &#125;&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;list:  <span class="subst">$list</span>&#x27;</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;gifts: <span class="subst">$gifts</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="the-main-function">The main() function</h3><p>每个APP都必须有个顶层的 <code>main()</code> 函数作为APP的入口。<code>main()</code> 函数默认返回 <code>void</code> , 参数为可选的 <code>List&lt;String&gt;</code> 类型。</p><p>下面是一个 web 应用的 <code>main()</code> 函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">querySelector</span>(<span class="string">&#x27;#sample_text_id&#x27;</span>)</span><br><span class="line">    ..text = <span class="string">&#x27;Click me&#x27;</span></span><br><span class="line">    ..onClick.listen(reverseText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面代码中的 <code>..</code> 语法称为 <a href="https://www.dartlang.org/guides/language/language-tour#cascade-notation-">cascade</a> （级联）。使用 cascade 你可以对某个对象的多个成员进行多个操作。</p></blockquote><p>下面是一个包含命令行参数的命令行程序：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run the app like this: dart args.dart 1 test</span></span><br><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; arguments) &#123;</span><br><span class="line">  <span class="built_in">print</span>(arguments);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assert</span>(arguments.length == <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">assert</span>(<span class="built_in">int</span>.parse(arguments[<span class="number">0</span>]) == <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">assert</span>(arguments[<span class="number">1</span>] == <span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以使用 <a href="https://pub.dartlang.org/packages/args">args library</a> 来定义和解析命令行参数。</p><h4 id="functions-as-first-class-objects">Functions as first-class objects</h4><p>函数可以作为参数传递给另一个函数，比如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> printElement(<span class="built_in">int</span> element) &#123;</span><br><span class="line">    <span class="built_in">print</span>(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 printElement 作为参数传递</span></span><br><span class="line">list.forEach(printElement);</span><br></pre></td></tr></table></figure><p>函数可以作为值分配给变量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> louldify = (msg) =&gt; <span class="string">&#x27;!!! <span class="subst">$&#123;msg&#125;</span>.toUpperCase() !!!&#x27;</span>;</span><br><span class="line">louldify(<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="anonymous-functions-匿名函数">Anonymous functions 匿名函数</h4><p>匿名函数也可以称为 <em>lambda</em> 或 <em>closure</em>。定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">([[Type] param1[, …]]) &#123; </span><br><span class="line">  codeBlock; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>与普通函数定义相似，0个或多个参数，可选的参数累心。如果函数只有一个语句，可以简写成 <code>([[Type] param1[, …]]) =&gt; oneLineCodeBlock;</code> 。</p><h4 id="lexical-scope-词法范围">Lexical Scope 词法范围</h4><p>Dart 语言变量的作用域是静态确定的，简单的说就是由你的代码结构决定的。花括号表示变量的作用域。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> topLevel = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> insideMain = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> myFunction() &#123;</span><br><span class="line">    <span class="keyword">var</span> insideFunction = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> nestedFunction() &#123;</span><br><span class="line">      <span class="keyword">var</span> insideNestedFunction = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">assert</span>(topLevel);</span><br><span class="line">      <span class="keyword">assert</span>(insideMain);</span><br><span class="line">      <span class="keyword">assert</span>(insideFunction);</span><br><span class="line">      <span class="keyword">assert</span>(insideNestedFunction);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：最内层嵌套的函数可以访问外层的所有变量。</p></blockquote><h4 id="lexical-closure">Lexical Closure</h4><p>闭包可以访问他的词法范围内的变量，即使闭包在他原始访问范围外访问也可以。</p><h4 id="test-functions-for-equality-函数比较">Test functions for equality 函数比较</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> foo() &#123;&#125;  <span class="comment">// 顶层函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> bar() &#123;&#125;    <span class="comment">// 类静态函数</span></span><br><span class="line">    <span class="keyword">void</span> baz() &#123;&#125;           <span class="comment">// 实例函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    <span class="comment">// 顶层函数比较</span></span><br><span class="line">    <span class="keyword">var</span> x = foo;</span><br><span class="line">    <span class="comment">// 同一个顶层函数，相等</span></span><br><span class="line">    <span class="keyword">assert</span>(x == foo);</span><br><span class="line">    <span class="comment">// 静态函数比较</span></span><br><span class="line">    <span class="comment">// 同一个静态函数，相等</span></span><br><span class="line">    x = A.bar;</span><br><span class="line">    <span class="keyword">assert</span>(x == A.bar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例函数比较</span></span><br><span class="line">    <span class="keyword">var</span> v = A();</span><br><span class="line">    <span class="keyword">var</span> w = A();</span><br><span class="line">    <span class="keyword">var</span> y = w;</span><br><span class="line">    x = w.baz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 都是实例w的函数，所以相等</span></span><br><span class="line">    <span class="keyword">assert</span>(y.bzd == x)</span><br><span class="line">    <span class="comment">// 非同一个实例的函数，不相等</span></span><br><span class="line">    <span class="keyword">assert</span>(v.baz != w.baz)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="return-values-返回值">Return values 返回值</h4><p>所有的函数都是返回值，如果代码不指定返回值，默认的 <code>return null;</code> 会被增加到函数的结尾。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo() &#123;&#125;</span><br><span class="line"><span class="keyword">assert</span>(foo() == <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h2 id="operators-操作符">Operators 操作符</h2><p>Dart 的多数运算符都可以<a href="https://www.dartlang.org/guides/language/language-tour#overridable-operators">覆写</a>。</p><table><thead><tr class="header"><th>描述</th><th style="text-align: left;">运算符</th></tr></thead><tbody><tr class="odd"><td>后缀一元运算符</td><td style="text-align: left;"><code>expr++ expr-- () [] . ?.</code></td></tr><tr class="even"><td>前缀一元运算符</td><td style="text-align: left;"><code>-expr !expr ~expr ++expr --expr</code></td></tr><tr class="odd"><td>乘法</td><td style="text-align: left;"><code>* / % ~/</code></td></tr><tr class="even"><td>加法</td><td style="text-align: left;"><code>+ -</code></td></tr><tr class="odd"><td>移位操作</td><td style="text-align: left;"><code>&lt;&lt; &gt;&gt;</code></td></tr><tr class="even"><td>按位与</td><td style="text-align: left;"><code>&amp;</code></td></tr><tr class="odd"><td>按位异或</td><td style="text-align: left;"><code>^</code></td></tr><tr class="even"><td>按位或</td><td style="text-align: left;"><code>|</code></td></tr><tr class="odd"><td>关系与类型比较</td><td style="text-align: left;"><code>&gt; &gt;= &lt;= &lt; as is is!</code></td></tr><tr class="even"><td>相等性比较</td><td style="text-align: left;"><code>== ！=</code></td></tr><tr class="odd"><td>逻辑与</td><td style="text-align: left;"><code>&amp;&amp;</code></td></tr><tr class="even"><td>逻辑或</td><td style="text-align: left;"><code>||</code></td></tr><tr class="odd"><td>if null</td><td style="text-align: left;"><code>??</code></td></tr><tr class="even"><td>条件运算符</td><td style="text-align: left;"><code>expr1?expr2:expr3</code></td></tr><tr class="odd"><td>cascade级联操作</td><td style="text-align: left;"><code>..</code></td></tr><tr class="even"><td>赋值</td><td style="text-align: left;"><code>=  *=  /=  ~/=  %=  +=  -=  &lt;&lt;=  &gt;&gt;=  &amp;=  ^=</code></td></tr><tr class="odd"><td></td><td style="text-align: left;"></td></tr></tbody></table><blockquote><p>表中上方操作符的优先级都高于下方操作符的优先级。如果运算符适用于两侧不同类型的数据，那么使用左侧数据类型的方式进行运算。</p></blockquote><h3 id="arithmetic-operators-算数运算符">Arithmetic operators 算数运算符</h3><table><thead><tr class="header"><th>运算符</th><th>意义</th></tr></thead><tbody><tr class="odd"><td><code>+</code></td><td>加法</td></tr><tr class="even"><td><code>-</code></td><td>减法</td></tr><tr class="odd"><td><code>-expr</code></td><td>负数</td></tr><tr class="even"><td><code>*</code></td><td>乘法</td></tr><tr class="odd"><td><code>/</code></td><td>除法</td></tr><tr class="even"><td><code>~/</code></td><td>除法，去整数结果</td></tr><tr class="odd"><td><code>%</code></td><td>取模</td></tr><tr class="even"><td><code>++var</code></td><td>var = var +1, 表达式的值是var+1</td></tr><tr class="odd"><td><code>var++</code></td><td>var = var + 1，表达式的值是var</td></tr><tr class="even"><td><code>--var</code></td><td>var = var - 1，表达式的值是var - 1</td></tr><tr class="odd"><td><code>var--</code></td><td>var = var - 1, 表达式的值是var</td></tr></tbody></table><h3 id="equality-and-relational-operators-相等与关系运算符">Equality and relational operators 相等与关系运算符</h3><table><colgroup><col style="width: 9%" /><col style="width: 90%" /></colgroup><thead><tr class="header"><th>运算符</th><th>意义</th></tr></thead><tbody><tr class="odd"><td><code>==</code></td><td>用来判断两个对象是否表示同一个事物（如果操作符两边的对象都是null，返回true，其中一个是null，返回false；如果都不是null，调用x.==(y)）</td></tr><tr class="even"><td><code>!=</code></td><td>不相等</td></tr><tr class="odd"><td><code>&gt;</code></td><td>大于</td></tr><tr class="even"><td><code>&lt;</code></td><td>小于</td></tr><tr class="odd"><td><code>&gt;=</code></td><td>大于等于</td></tr><tr class="even"><td><code>&lt;=</code></td><td>小于等于</td></tr></tbody></table><blockquote><p>如果判断x、y是否是同一个对象，使用 <code>identical()</code> 函数。</p></blockquote><h3 id="type-test-operators-类型检测运算符">Type test operators 类型检测运算符</h3><p><code>as</code>、 <code>is</code>、 <code>is!</code> 用来在运行时检查对象类型。</p><table><thead><tr class="header"><th>运算符</th><th>意义</th></tr></thead><tbody><tr class="odd"><td><code>as</code></td><td>类型转换（<code>(emp as Person).firstName = 'Bob'</code>）</td></tr><tr class="even"><td><code>as</code></td><td>True 如果对象是指定类型</td></tr><tr class="odd"><td><code>is!</code></td><td>False如果对象是指定类型</td></tr></tbody></table><h3 id="assignment-operators-赋值运算符">Assignment operators 赋值运算符</h3><blockquote><p><code>??=</code> 是一特殊的赋值符号，只有当被赋值的变量为null的时候 才会赋值。</p></blockquote><h3 id="logical-operators">Logical operators</h3><table><thead><tr class="header"><th>运算符</th><th>意义</th></tr></thead><tbody><tr class="odd"><td><code>!expr</code></td><td>非，取反</td></tr><tr class="even"><td><code>||</code></td><td>逻辑或</td></tr><tr class="odd"><td><code>&amp;&amp;</code></td><td>逻辑与</td></tr></tbody></table><h3 id="bitwise-and-shift-operators-位与移位操作符">Bitwise and shift operators 位与移位操作符</h3><table><thead><tr class="header"><th>运算符</th><th>意义</th></tr></thead><tbody><tr class="odd"><td><code>&amp;</code></td><td>按位与</td></tr><tr class="even"><td><code>|</code></td><td>按位或</td></tr><tr class="odd"><td><code>^</code></td><td>按位异或</td></tr><tr class="even"><td><code>~expr</code></td><td>按位取反</td></tr><tr class="odd"><td><code>&lt;&lt;</code></td><td>左移，右边用0补充</td></tr><tr class="even"><td><code>&gt;&gt;</code></td><td>右移，左边用0补充</td></tr></tbody></table><h3 id="conditional-expressions-条件表达式">Conditional Expressions 条件表达式</h3><p><code>condition ? expr1 : expr2</code>： 如果 condition 为 Ture，返回 expr1，否则返回 expr2。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> visibility = isPublic ? <span class="string">&#x27;public&#x27;</span>: private;</span><br></pre></td></tr></table></figure><p><code>expr1 ?? expr2</code>： 如果 expr1 非null，返回 expr1，否则返回 expr2 。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> playerName(<span class="built_in">String</span> name) =&gt; name ?? <span class="string">&#x27;Guest&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="cascade-notation-级联操作">Cascade notation (级联操作)</h3><p><code>..</code> 级联操作符允许开发者对同一个对象进项一系列操作，不仅仅可以调用对象的函数，还可以直接访问对象的数据成员。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> addressBook = (AddressBookBuilder()</span><br><span class="line">      ..name = <span class="string">&#x27;jenny&#x27;</span></span><br><span class="line">      ..email = <span class="string">&#x27;jenny@example.com&#x27;</span></span><br><span class="line">      ..phone = (PhoneNumberBuilder()</span><br><span class="line">            ..number = <span class="string">&#x27;415-555-0100&#x27;</span></span><br><span class="line">            ..label = <span class="string">&#x27;home&#x27;</span>)</span><br><span class="line">          .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h3 id="other-operators-其他运算符">Other Operators 其他运算符</h3><table><thead><tr class="header"><th>运算符</th><th>名字</th><th>意义</th></tr></thead><tbody><tr class="odd"><td><code>()</code></td><td>函数调用</td><td>表示一个函数调用</td></tr><tr class="even"><td><code>[]</code></td><td>列表访问</td><td>列表中指定下标的元素的值</td></tr><tr class="odd"><td><code>.</code></td><td>成员访问</td><td>访问表达试的属性</td></tr><tr class="even"><td><code>?.</code></td><td>条件成员访问</td><td>与 <code>.</code> 类似，当时左边的表达式可以为null</td></tr></tbody></table><h2 id="control-flow-statements-控制流语句">Control flow statements 控制流语句</h2><h3 id="if-and-else">If and else</h3><p>略。</p><h3 id="for-loops-for-循环">For loops For 循环</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>Iterable</code> 类型的对象，可以使用 <code>forEach()</code> 函数遍历。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condidates.forEach((candidate) =&gt; candidate.interview())</span><br></pre></td></tr></table></figure><p>Iterable 类也支持 <code>for-in</code> 循环。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> collection = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">in</span> collection) &#123;</span><br><span class="line">    <span class="built_in">print</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="while-and-do-while-while-循环">While and do-while while 循环</h3><p><code>while</code>循环在循环开始前评估循环的条件。 <code>do-while</code> 循环在一次循环结束后评估循环的条件。</p><h3 id="break-and-continue-语句">Break and continue 语句</h3><p>使用 <code>break</code> 来停止循环，使用 <code>continue</code> 来跳过循环之后的语句，继续下一个循环。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">candidates</span><br><span class="line">    .where((c) =&gt; c.yearsExperience &gt;= 5)</span><br><span class="line">        .forEach((c) =&gt; c.interview());</span><br></pre></td></tr></table></figure></p><h3 id="switch-and-case-语句">Switch and case 语句</h3><p>Dart 中的 switch 语句可以应用于整数、字符创、或对象编译时常量（使用 == 来比较，类不能覆写 == 函数）。每个非空的 case 语句都必须包含 break 结尾，或者用contine、return、throw 来结束case，否则编译报错。 对于空 case，执行其下边的case代码（译注：类似java）。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> command = <span class="string">&#x27;CLOSED&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span> (command) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;CLOSED&#x27;</span>:</span><br><span class="line">      executeClosed();</span><br><span class="line">      <span class="keyword">continue</span> nowClosed;</span><br><span class="line">        <span class="comment">// Continues executing at the nowClosed label.</span></span><br><span class="line"></span><br><span class="line">  nowClosed:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;NOW_CLOSED&#x27;</span>:</span><br><span class="line">    <span class="comment">// Runs for both CLOSED and NOW_CLOSED.</span></span><br><span class="line">    executeNowClosed();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure> ### Assert 断言 使用 <code>assert(condition)</code> 来中断正常执行的代码流程，在 <code>condition</code> 为 False 的时候中断正常流程，抛出 <code>AssertionError</code> 异常。 &gt; assert 语句在生产代码中是无效的,在 dart 和 dart2js 命令中增加 <code>--enable-asserts</code> 来启用 assert 。</p><h2 id="exceptions-异常">Exceptions 异常</h2><p>Dart 可以抛出和捕获异常，如果异常不被捕获，抛出异常的代码会被暂停，通常它所在的进程会被终止。 与 Java 不同，Dart 不要求函数声明抛出异常，也不要求调用者捕获函数可能抛出的异常。Dart 提供了 <code>Exception</code> 和 <code>Error</code> 两种异常类型，同时也支持抛出任意非null对象作为异常。</p><h3 id="throw">Throw</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> FormatException(<span class="string">&#x27;Expected at least 1 section&#x27;</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&#x27;Out of llamas&#x27;</span>;</span><br><span class="line"><span class="keyword">void</span> distanceTo(Point other) =&gt; <span class="keyword">throw</span> UnimplementedError();</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>通常代码都将 <code>Exception</code> 或 <code>Error</code> 的子类作为异常抛出。</p></blockquote><h3 id="catch">Catch</h3><p>捕获异常可以阻止异常继续传播，给开发者一个处理异常的机会。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breeMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">on</span> OutOfLlamasException&#123;</span><br><span class="line">  buyMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">on</span> Exception <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Exception details:\n<span class="subst">$e</span>&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e, s) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Exception details:\n<span class="subst">$e</span>&#x27;</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;StackTrace:\n<span class="subst">$s</span>&#x27;</span>);</span><br><span class="line">  <span class="comment">// 抛出异常给调用者</span></span><br><span class="line">  <span class="keyword">rethrow</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="finally">Finally</h3><p>保证无论是否抛出异常，<code>finally</code> 中的代码的代码都会执行。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Error: <span class="subst">$e</span>&#x27;</span>); <span class="comment">// Handle the exception first.</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  cleanLlamaStalls(); <span class="comment">// Then clean up.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="classes-类">Classes 类</h2><p>Dart 是面向对象的语言，同时支持混合继承。所有的对象都是某个类的实例，所有的类都继承自 <code>Object</code> 。混合继承的意思是虽然每个类都只有一个直接的父类，但是一个类可以在多个继承中使用。</p><h3 id="using-class-memebers-使用类成员">Using class memebers 使用类成员</h3><p>对象包含数据和函数成员，使用 <code>.</code> 来访问对象成员，使用 <code>?.</code> 来避免对象空指针的问题。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">p.y = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">assert</span>(p.y == <span class="number">3</span>);</span><br><span class="line"><span class="built_in">num</span> distance = p.distanceTo(Point(<span class="number">4</span>, <span class="number">4</span>));</span><br><span class="line">p.y? = <span class="number">4</span>;</span><br></pre></td></tr></table></figure></p><h3 id="using-constructors-构造函数">Using constructors 构造函数</h3><p>构造函数的名称可以是 <code>ClassName</code> 也可以是其他函数。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new 关键字是可选的</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point.fromJson(&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure> 为了创建编译时常量，有些类提供了常量构造函数，在调用构造函数之前增加 <code>const</code> 关键字就可以创建编译时常量了。</p><p>构造两个相同的编译时常量，编译器只会生成一个实例，两个常量引用这同一个实例。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> c = ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">assert</span>(identical(a, b)); <span class="comment">// a b 是同一个实例</span></span><br><span class="line"><span class="keyword">assert</span>(!identical(<span class="number">1</span>, c)); <span class="comment">// a c不是同一个实例</span></span><br></pre></td></tr></table></figure></p><p>在同一个 <code>const</code> 作用域范围内所有变量都是 <code>const</code> 的，不需要挨个指定。</p><h3 id="getting-an-objects-type-获取对象类型">Getting an object's type 获取对象类型</h3><p>使用对象的 <code>runtimeType</code> 属性在获取运行时获取对象的类型， 它返回一个 <code>Type</code> 类型的对象。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The type of a is <span class="subst">$&#123;a.runtimeType&#125;</span>&#x27;</span>);</span><br></pre></td></tr></table></figure></p><h3 id="instance-variables-实例变量">Instance variables 实例变量</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;    <span class="comment">// 声明实例变量，默认初始未 null</span></span><br><span class="line">  <span class="built_in">num</span> y;    <span class="comment">// 声明y，初始为 null</span></span><br><span class="line">  <span class="built_in">num</span> z = <span class="number">0</span>; <span class="comment">// 声明z，初始为 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有未初始化的数据成员为null。所有非 final 的数据成员会被默认创建 getter/setter函数。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> point = Point();</span><br><span class="line">  point.x = <span class="number">4</span>;              <span class="comment">// 使用setter函数设置x的值</span></span><br><span class="line">  <span class="keyword">assert</span>(point.x == <span class="number">4</span>);     <span class="comment">// 使用getter函数获取x的值</span></span><br><span class="line">  <span class="keyword">assert</span>(point.y == <span class="keyword">null</span>);  <span class="comment">// 默认值为 null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="constructors-构造函数">Constructors 构造函数</h3><p>默认使用与类型名字相同的函数作为构造函数，Dart 中构造函数是不被继承的，如果子类没有生命构造函数，它只有一个无参的默认构造函数，所有成员都是默认值。</p><h4 id="named-constructors-命名构造函数">Named constructors 命名构造函数</h4><p>使用命名的构造函数来实现多个构造函数，使代码更清晰： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 命名构造函数</span></span><br><span class="line">  Point.origin() &#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 子类如果想用父类的命名构造函数，也必须实现它。</p><h4 id="involing-a-non-default-superclass-constructor-调用父类非默认构造函数">Involing a non-default superclass constructor 调用父类非默认构造函数</h4><p>默认子类调用父类非命名无参构造函数。子类也可以在构造函数的开始调用父类的构造函数。如果指定初始化列表，初始化列表会在父类构造函数之前执行，构造函数的执行顺序如下： 1. 初始化列表 2. 父类的无参数构造函数 3. 主类的无参构造函数</p><p>如果父类没有无参非命名构造函数，开发者必须手动调用父类的构造函数，使用 <code>:</code> 在构造函数体之前指定父类构造函数。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> firstName;</span><br><span class="line"></span><br><span class="line">  Person.fromJson(<span class="built_in">Map</span> data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;in Person&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用父类指定构造函数</span></span><br><span class="line">  Employee.formJson(<span class="built_in">Map</span> data): <span class="keyword">super</span>.fromJson(data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;in Employee&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> emp = <span class="keyword">new</span> Employee.fromJson(&#123;&#125;);</span><br><span class="line">  <span class="keyword">if</span> (emp <span class="keyword">is</span> Person) &#123;</span><br><span class="line">    emp.firstName = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  (emp <span class="keyword">as</span> Person).firstName = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="initializer-list-初始化列表">Initializer list 初始化列表</h4><p>可以在初始化列表中初始化成员变量，在运行构造函数前初始化实例初始化成员，使用逗号分隔列表。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">num</span>&gt; json) : x = json[<span class="string">&#x27;x&#x27;</span>], y = json[<span class="string">&#x27;y&#x27;</span>] &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;In Point.fromJson(): (<span class="subst">$x</span>, <span class="subst">$y</span>)&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在初始化 <code>final</code> 数据成员的时候初始化列表格外有用。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:math&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> y;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> distanceFromOrigin;</span><br><span class="line"></span><br><span class="line">  Point(x, y) : x = x, y = y, distanceFromOrigin = sqrt(x * x + y * y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">print</span>(p.distanceFromOrigin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="redirecting-constructors-重定向构造函数">Redirecting constructors 重定向构造函数</h5><p>有时某些构造函数的作用就是调用其他构造函数。重定向构造函数的函数体是空的，使用 <code>:</code> 分隔。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"> <span class="built_in">num</span> x, y;</span><br><span class="line"> <span class="comment">// the main constructor</span></span><br><span class="line"> Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line"> Point.alongXAxis(<span class="built_in">num</span> x): <span class="keyword">this</span>(x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="constant-constructors-常量构造函数">Constant constructors 常量构造函数</h4><p>使用 <code>const</code> 构造函数来创建编译时常量，并且其中所有成员变量都是 <code>final</code> 类型的。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutablePoint</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ImmutablePoint origin = </span><br><span class="line">    <span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ImmutablePoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> &gt; 常量构造函数并非每次都创建常量。</p><h4 id="factory-constructors-工厂构造函数">Factory constructors 工厂构造函数</h4><p>使用 <code>factory</code> 关键字来实现工厂构造函数，工厂构造函数不需要每次都创建新的对象，比如它可以从cache中返回一个重用的对象或者返回一个子类的对象。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line"> <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line"> <span class="built_in">bool</span> mute = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 使用 _ 使成员变量编程私有成员</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>(<span class="built_in">String</span>, Logger) _cache =</span><br><span class="line">    &lt;<span class="built_in">String</span>, Logger&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Logger(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_cache.containsKey(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> _cache[name];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> logger = Logger._internal(name) &#123;</span><br><span class="line">        _cache[name] = logger;</span><br><span class="line">        <span class="keyword">return</span> logger;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Logger._internal(<span class="keyword">this</span>.name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> log(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mute) <span class="built_in">print</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> &gt; 工厂构造函数没有权限访问 <code>this</code> 。 工厂构造函数的使用与普通构造函数的使用一致。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = Logger(<span class="string">&#x27;UI&#x27;</span>);</span><br><span class="line">logger.log(<span class="string">&#x27;Button clicked&#x27;</span>);</span><br></pre></td></tr></table></figure></p><h3 id="methonds-函数">Methonds 函数</h3><h4 id="instance-methods-实例函数">Instance methods 实例函数</h4><p>实例函数可以访问类的成员变量和 <code>this</code> 。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:math&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="built_in">num</span> x, y;</span><br><span class="line">    Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">num</span> distanceTo(Point other) &#123;</span><br><span class="line">        <span class="keyword">var</span> dx = x - other.x;</span><br><span class="line">        <span class="keyword">var</span> dy = y - other.y;</span><br><span class="line">        <span class="keyword">return</span> sqrt(dx * dx + dy * dy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getters-and-setters">Getters and setters</h4><p>Getter 和 Setter 提供了对类成员读写的方式，你也可以使用 <code>get</code> 和 <code>set</code> 关键词实现自定义的 <code>getter</code> 和 <code>setter</code> 。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> left, top, width, height;</span><br><span class="line"></span><br><span class="line">  Rectangle(<span class="keyword">this</span>.lest, <span class="keyword">this</span>.top, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> right =&gt; left + width;</span><br><span class="line">  <span class="keyword">set</span> right(<span class="built_in">num</span> value) =&gt; left = value - width;</span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> bottom =&gt; top + height;</span><br><span class="line">  <span class="keyword">set</span> bottom(<span class="built_in">num</span> value) =&gt; top = value - height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> rec = Rectangle(<span class="number">3</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">15</span>);</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">3</span>);</span><br><span class="line">  rect.right = <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 你可以在初始的时候使用实例变量，如果之后改成函数的实现方式，你就不需要修改客户端的代码而直接使用了。 &gt; 无论是否明确定义了 <code>getter</code> 函数，运算符都可以按照预期工作。为了避免任何非预期的副作用，运算符都只调用 <code>getter</code> 一次，然后把值存在临时变量中。</p><h4 id="abstract-methods">Abstract methods</h4><p>Instance、getter 和 setter 方法都可以是抽象方法，定义好接口，然后把接口的实现留给其他类来做。只有抽象类才能包含抽象方法。</p><p>只要在函数体除使用分号（;）就可以定义抽象方法了。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// abstract method</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> doSomething();  <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EffectiveDoer</span> <span class="keyword">extends</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">    <span class="comment">// 在此具体实现此函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="abstract-classes">Abstract classes</h4><p>使用 <code>abstract</code> 来定义不能实例化的抽象类。抽象类主要用来定义接口，通常会包含某些实现。如果你希望抽象类可以被实例化，那么你可以定义一个工厂构造函数(<a href="https://dart.dev/guides/language/language-tour#factory-constructors">FactoryConstructor</a>)。</p><p>抽闲类通常包含抽象方法，例如： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明为抽象类，无法实例化的类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractContainer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="implicit-interface">Implicit Interface</h4><p>每个类都是一个包含了它所有实例成员和它实现的接口的隐式接口（译注：每个class都是一个interface，都可以被其他类implement）。如果你想创建一个类A，并让类A支持类B的 API，但又不想让A继承B，那么A应该实现（implement）B。</p><p>类可以通过 <code>implements</code> 语句来实现一个或多个接口，然后实现接口的方法，比如： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person 的类定义，隐含了接口 greet()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 包含在接口中，但是只对此类可见</span></span><br><span class="line">  <span class="keyword">final</span> _name;</span><br><span class="line">  <span class="comment">// 不包含在接口中，因为这是构造方法</span></span><br><span class="line">  Person(<span class="keyword">this</span>._name);</span><br><span class="line">  <span class="comment">// 包含在接口中</span></span><br><span class="line">  <span class="built_in">String</span> greet(<span class="built_in">String</span> who) =&gt; <span class="string">&#x27;Hello <span class="subst">$who</span>. I am <span class="subst">$_name</span>&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现了 Person 接口的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Impostor</span> <span class="keyword">implements</span> <span class="title">Persion</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> _name =&gt; <span class="string">&#x27;&#x27;</span>; <span class="comment">// 注意这，实现了 _name 接口</span></span><br><span class="line">  <span class="built_in">String</span> greet(<span class="built_in">String</span> who) =&gt; <span class="string">&#x27;Hi, <span class="subst">$who</span>. Do you know who I am?&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> greetBob(Person person) =&gt; person.greet(<span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(greetBob(Persion(<span class="string">&#x27;Kathy&#x27;</span>)));</span><br><span class="line">  <span class="built_in">print</span>(greetBob(Impostor()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> &gt; 译注： 上边代码输出如下： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, Bob. I am Kathy</span><br><span class="line">Hello, Bob. Do you know who I am ?</span><br></pre></td></tr></table></figure> 下边是实现多个接口的例子： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">implements</span> <span class="title">Comparable</span>, <span class="title">Location</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p><h4 id="extending-a-class">Extending a class</h4><p>使用 <code>extends</code> 关键字来实现类的继承， <code>super</code> 来引用父类。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    _illuminateDisplay();</span><br><span class="line">    _activateIrSensor();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartTelevision</span> <span class="keyword">extends</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    <span class="keyword">super</span>.turnOn();</span><br><span class="line">    _bootNetworkInterface();</span><br><span class="line">    _initializeMemory();</span><br><span class="line">    _upgradeApps();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="overriding-members">Overriding members</h4><p>子类可以覆写实例方法、getter 和 setter。使用 <code>@override</code> 标注来标识你是故意覆写一个成员方法： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartTelevision</span> <span class="keyword">extends</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;...&#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> To narrow the type of a method parameter or instance variable in code that is type safe, you can use the covariant keyword.（译注：暂时没看懂啥意思，明白了再来翻译）</p><h4 id="overridable-operators">Overridable operators</h4><p>以下运算符可以覆写： | &lt; | + | ^ | [] | |----|----|----|----| | &gt; | / | | | []=| | &lt;= | ~/ | &amp; | ~ | | &gt;= | * | &lt;&lt; | == | | - | % | &gt;&gt; | | &gt; 注意：<code>!=</code> 不是可覆写的运算符，因为 <code>e1 != e2</code> 只是 <code>!(e1 == e2)</code> 的语法糖。</p><p>下边的例子覆写了 <code>+ -</code> 两个运算符： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> x, y;</span><br><span class="line">  Vector(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">  Vector <span class="keyword">operator</span> +(Vector v) =&gt; Vector(x + v.x, y + v.y);</span><br><span class="line">  Vector <span class="keyword">operator</span> -(Vector v) =&gt; Vector(x - v.x, y - v.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> v = Vector(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">final</span> w = Vector(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assert</span>(v + w == Vector(<span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">  <span class="keyword">assert</span>(v - w == Vector(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 如果你覆写了 <code>==</code>，你需要同时覆写它的 <code>hashCode</code> getter，参考<a href="https://dart.dev/guides/libraries/library-tour#implementing-map-keys">Implementing map keys</a> 和 <a href="https://dart.dev/guides/language/language-tour#extending-a-class">Extending a class</a></p><h4 id="nosuchmethod">noSuchMethod()</h4><p>问了检测和响应代码对不存在的方法和数据成员的调用，你可以覆写 <code>noSuhMethod()</code> 方法： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果不覆写 noSuchMethod 方法，调用不存在的类成员会导致 NoSuchMethodError。</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> noSuchMethod(Invocation invocation) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;You tried to use a non-existing member:&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;<span class="subst">$&#123;invoation.memberName&#125;</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 除下列情况外，你是无法调用不存在的方法的： - 调用 <code>dynamic</code> 类型实例的方法 - 调用确定类型实例的未实现方法（比如抽象类的方法），并且实例的动态类型自己实现了 <code>noSuchMethod</code> 方法（译注：这句话有点绕，个人理解，比如你继承了一个抽象类，被继承的抽象类实现了 <code>noSuchMethod</code> 方法）。</p><p>更多信息参考 <a href="https://github.com/dart-lang/sdk/blob/master/docs/language/informal/nosuchmethod-forwarding.md">noSuchMethod forwarding specification</a>。</p><h4 id="extension-methods">Extension methods</h4><p>扩展方法是 Dart2.7 引入的新特性，是向已有库中增加功能的一种方法。在不知情的情况下，你看能已经使用了扩展方法。比如在你使用IDE编写代码的时候，它会不区分常规方法和扩展方法给你代码提示。</p><p>下边的例子，使用了 <code>string_api.dart</code> 中扩展的 <code>String</code> 类的 <code>parseInt</code> 方法。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;string_api.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;42&#x27;</span>.padLeft(<span class="number">5</span>));</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;42&#x27;</span>.parseInt());</span><br></pre></td></tr></table></figure> 关于扩展方法的使用与实现方式，参考 <a href="https://dart.dev/guides/language/extension-methods">extension methods page</a>。</p><h4 id="enumerated-types">Enumerated types</h4><p>枚举类型是特别的类，是用来表示一组固定常量。</p><h5 id="using-enums">Using enums</h5><p>使用 <code>enum</code> 关键字来声明枚举类型： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;red, green, blue&#125;</span><br></pre></td></tr></table></figure> &gt; 译注：注意上边Color的定义，必须在代码的顶层，并且代码没有以分号结束。</p><p>枚举中的每个值都包含一个叫 <code>index</code> 的 getter，它会返回枚举中定义的的这个值的下标（从0开始）： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(Color.red.index == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">assert</span>(Color.green.index == <span class="number">1</span>);</span><br><span class="line"><span class="keyword">assert</span>(Color.blue.index == <span class="number">2</span>);</span><br></pre></td></tr></table></figure> 使用枚举的 <code>values</code> 常量来获取枚举中定义的所有值： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;Color&gt; colors = Color.values;</span><br><span class="line"><span class="keyword">assert</span>(colors[<span class="number">2</span>] == Color.blue);</span><br></pre></td></tr></table></figure> 枚举值可以用作 switch 语句的 case 值，你必须处理枚举中的所有值，否则会产生一个警告： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aColor = Color.blue;</span><br><span class="line"><span class="keyword">switch</span> (aColor) &#123;</span><br><span class="line">  <span class="keyword">case</span> Color.red:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Red as roses&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Color.green:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Green as grass&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 没有此语句会产生警告</span></span><br><span class="line">    <span class="built_in">print</span>(aColor); <span class="comment">// 打印 Color.blue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 枚举值有以下限制： - 不能继承、实现、mix in 枚举类型 - 不能显示的实例化枚举类型</p><p>详细信息参考 <a href="https://dart.dev/guides/language/spec">Dart language specification</a>。</p><h4 id="adding-features-to-a-class-mixins">Adding features to a class: mixins</h4><p>Mixin是在多继承中复用代码的一种方式。 使用 <code>with</code> 关键字后面跟一个或多个 mixin 类型： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Musician</span> <span class="keyword">extends</span> <span class="title">Performer</span> <span class="title">with</span> <span class="title">Musical</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Maestro</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="title">with</span> <span class="title">Musical</span>, <span class="title">Aggressive</span>, <span class="title">Demented</span> </span>&#123;</span><br><span class="line">  Maestro(<span class="built_in">String</span> maestroName) &#123;</span><br><span class="line">    name = meastroName;</span><br><span class="line">    canConduct = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 为了实现一个 <em>mixin</em> 类型，你只要创建一个继承字 <code>Object</code> 的类并且不要声明构造方法即可。除非你希望 <em>mixin</em> 可以被当做普通的类来使用，否则都用 <code>mixin</code> 关键字代替 <code>class</code> 关键字既可: <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> Musical &#123;</span><br><span class="line">  <span class="built_in">bool</span> canPlayPiano = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canCompose = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canConduct = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">void</span> entertainMe() &#123;</span><br><span class="line">    <span class="keyword">if</span> (canPlayPiano) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;Playing piano&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (canConduct) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;Waving hands&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(Humming to self<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure> 为了限制mixin的使用范围，你可以使用 <code>on</code> 关键字来指定可以使用它的类，这样这个mixin就可以调用它没有定义的方法了。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> MusicalPerformer <span class="keyword">on</span> Musican &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="class-variables-and-methods">Class variables and methods</h4><p>使用 <code>static</code> 关键字来定义类变量和方法。</p><h5 id="static-variables">Static variables</h5><p>静态变量（类变量）适用于类型级别的状态和常量： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> initialCapacity = <span class="number">16</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(Queue.initialCapacity == <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 静态变量只有在使用的时候才会初始化。</p><h5 id="static-methods">Static methods</h5><p>静态方法（类方法）不能使用 <code>this</code> ，所以不能操作自己的实例成员。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:math&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">num</span> distanceBetween(Point a, Point b) &#123;</span><br><span class="line">    <span class="keyword">var</span> dx = a.x - b.x;</span><br><span class="line">    <span class="keyword">var</span> dy = a.y - b.y;</span><br><span class="line">    <span class="keyword">return</span> sqrt(dx * dx + dy * dy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> a = Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> b = Point(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">var</span> distance = Point.distanceBetween(a, b);</span><br><span class="line">  <span class="keyword">assert</span>(<span class="number">2.8</span> &lt; distance &amp;&amp; distance &lt; <span class="number">2.9</span>);</span><br><span class="line">  <span class="built_in">print</span>(distance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 你可以使用静态方法作为编译时常量。比如可以把静态方法作为常量构造函数的参数。</p><h2 id="generics">Generics</h2><p>如果你看过API文档中基本类型的定义，<code>List</code> 的定义是 <code>List&lt;E&gt;</code> , &lt;&gt; 符号将 List 标记为泛型，也就是包含类型参数的类型。根据惯例，多数的泛型使用单个字母作为类型名字，比如 E、T、S、K、V。</p><h3 id="why-use-generics">Why use generics？</h3><p>通常使用泛型是为了保证类型安全，除此外，还有以下益处： - 恰当明确的泛型有益于更好的代码质量 - 减少代码的重复</p><p>如果你只项想创建包含字符串类型的列表,那么你应该声明一个 <code>List&lt;String&gt;</code> 类型的列表。这样，你自己、你的同事和代码工具在你尝试分配非字符串类型给列表的时候可以发现这可能是一个错误： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([<span class="string">&#x27;Seth&#x27;</span>, <span class="string">&#x27;Kathy&#x27;</span>, <span class="string">&#x27;Lars&#x27;</span>]);</span><br><span class="line">names.add(<span class="number">42</span>);  <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure> 使用泛型的另一个原因是减少代码的重复。泛型可以让你在不影响使用代码静态分析工具的情况下，在多种不同类型之间共享同样的接口和接口实现，比如下边这个缓存的工具： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectCache</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span> getByKey(<span class="built_in">String</span> key);</span><br><span class="line">  <span class="keyword">void</span> setByKey(<span class="built_in">String</span> key, <span class="built_in">Object</span> value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 后来你发现需要上边接口的字符串版本，你可以创建另一个接口： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StringCache</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> getByKey(<span class="built_in">String</span> key);</span><br><span class="line">  <span class="keyword">void</span> setByKey(<span class="built_in">String</span> key, <span class="built_in">String</span> value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 过了一段时间，你发现你需要个数字类型的缓存版本。。。 使用泛型可以帮你省去每个需求都重新写代码的麻烦了。你只要创建同一个接口，并且接受类型参数即可： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  T getByKey(<span class="built_in">String</span> key);</span><br><span class="line">  <span class="keyword">void</span> setByKey(<span class="built_in">String</span> key, T value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在上边的代码中，T 只是一个类型的占位符。你可以认为他是你以后使用到的任何类型。</p><h3 id="using-collection-literals">Using collection literals</h3><p>列表、集合、映射类型的都可以使用泛型。类型参数化的常量就和和见过的其他常量一样，除了增加了 <code>&lt;type&gt;</code>(list、set) 、 <code>&lt;keyType, valueType&gt;</code> (map) 以外: <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;Seth&#x27;</span>, <span class="string">&#x27;Kathy&#x27;</span>, <span class="string">&#x27;Lars&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> uniqueNames = &lt;<span class="built_in">String</span>&gt;&#123;<span class="string">&#x27;Seth&#x27;</span>, <span class="string">&#x27;Kathy&#x27;</span>, <span class="string">&#x27;Lars&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> pages = &lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&#123;</span><br><span class="line">  <span class="string">&#x27;index.html&#x27;</span>:<span class="string">&#x27;HomePage&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;robots.txt&#x27;</span>:<span class="string">&#x27;Hits for web robots&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;humans.txt&#x27;</span>:<span class="string">&#x27;We are people, not machines&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### Using parameterized types with constructors To specify one or more types when using a constructor, put the types in angle brackets (&lt;...&gt;) just after the class name. For example: <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nameSet = <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt;.from(names);</span><br><span class="line"><span class="keyword">var</span> views = <span class="built_in">Map</span>&lt;<span class="built_in">int</span>, View&gt;();</span><br></pre></td></tr></table></figure></p><h3 id="generic-collections-and-the-types-they-contain">Generic collections and the types they contain</h3><p>Dart 的泛型是<em>具体的</em>(<em>reified</em>)，这意味着在运行时保存着它的类型信息。比如，你可以检测集合的类型： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([<span class="string">&#x27;Seth&#x27;</span>, <span class="string">&#x27;Kathy&#x27;</span>, <span class="string">&#x27;Lars&#x27;</span>]);</span><br><span class="line"><span class="built_in">print</span>(names <span class="keyword">is</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;); <span class="comment">// true</span></span><br></pre></td></tr></table></figure> &gt; 相反的，Java 中使用类型擦除，泛型的类型参数在运行时是不存在的。在 Java 中你可以确定一个对象是不是 List，但不能检测他是不是 <code>List&lt;String&gt;</code>。</p><h3 id="restricting-the-parameterized-type">Restricting the parameterized type</h3><p>在实现泛型类的时，你看能需要限制类型，你可以用 <code>extends</code> 来实现： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SomeBaseClass</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> toString() =&gt; <span class="string">&quot;Instace of &#x27;Foo&lt;<span class="subst">$T</span>&gt;&#x27;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extender</span> <span class="keyword">extends</span> <span class="title">SomeBaseClass</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 可以这样使用</span></span><br><span class="line"><span class="keyword">var</span> someBaseClassFoo = Foo&lt;SomeBaseClass&gt;();</span><br><span class="line"><span class="keyword">var</span> extenderFoo = Foo&lt;Extender&gt;();</span><br><span class="line"><span class="comment">// 你也可以不指定类型参数，使用默认类型</span></span><br><span class="line"><span class="keyword">var</span> foo = Foo();</span><br><span class="line"><span class="built_in">print</span>(foo);  <span class="comment">// Foo&lt;SomeBaseClass&gt; 的实例</span></span><br><span class="line"><span class="keyword">var</span> foo = Foo&lt;<span class="built_in">Object</span>&gt;();  <span class="comment">// 指定非 SomeBaseClass 的类型参数会引起错误</span></span><br></pre></td></tr></table></figure></p><h3 id="using-generic-methods">Using generic methods</h3><p>最开始，Dart 对泛型的支持仅限于泛型类。之后才加入了泛型方法，允许类型参数的方法和函数： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T first&lt;T&gt;(<span class="built_in">List</span>&lt;T&gt; ts) &#123;</span><br><span class="line">  T tmp = ts[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>泛型参数你可以用在多个地方： - 函数的返回类型（<code>T</code>） - 参数的类型(<code>List&lt;T&gt;</code>) - 局部变量的类型(<code>T tmp</code>)</p><h2 id="libraries-and-visibility">Libraries and visibility</h2><p><code>import</code> 和 <code>library</code> 指令可以帮你创建模块化可共享的代码。库不仅仅可以提供 API，而且还是一个隐私单元（a unit of privacy）:以下杠开头的标识符都只在库内可见。及时没有使用 <code>library</code> 指令，每个 Dart 应用程序也都是一个库。</p><p>库（Library） 可是通过 <a href="https://dart.dev/guides/packages">package</a> 分发出去。</p><h3 id="using-libraries">Using libraries</h3><p>使用 <code>import</code> 来在一个库中指定如果使用另一个库中的命名空间。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:html&#x27;</span>;</span><br></pre></td></tr></table></figure> <code>import</code> 只需要一个地址来确定使用的库。对于 Dart 内置的库，库地址的 scheme 是 <code>dart:</code>。对于其他库，你可以使用文件系统中路径或 <code>package:</code> 来指定。<code>package:</code> 用来指定包管理器（比如 pub 工具）提供的库： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> package:test/test.dart;</span><br></pre></td></tr></table></figure></p><h4 id="specifying-a-library-prefix">Specifying a library prefix</h4><p>如果你引入的两个包命名有冲突，那么你可以未其中一个或两个库都指定前缀。比如，library1 和 library2 都包含名为 Element 的类，那么你可以这样写代码： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib1/lib1.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib2/lib2.darr&#x27;</span> <span class="keyword">as</span> lib2;</span><br><span class="line"><span class="comment">// 使用 lib1 中的 Element</span></span><br><span class="line"><span class="built_in">Element</span> element1 = <span class="built_in">Element</span>();</span><br><span class="line"><span class="comment">// 使用 lib2 中的 Element</span></span><br><span class="line">lib2.<span class="built_in">Element</span> element2 = lib2.<span class="built_in">Element</span>();</span><br></pre></td></tr></table></figure></p><h4 id="importing-only-part-of-a-library">Importing only part of a library</h4><p>如果你只想使用某个库的一部分，你可以有选择性的导入库： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只导入 foo。</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib1/lib1.dart&#x27;</span> <span class="keyword">show</span> foo;</span><br><span class="line"><span class="comment">// 导出 foo 以外的其他所有内容</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib2/lib2.dart&#x27;</span> <span class="keyword">hide</span> foo;</span><br></pre></td></tr></table></figure></p><h4 id="lazily-loading-library">Lazily loading library</h4><p>延迟加载（懒加载） 使网页应用在需要的时候按需加载库。你可能在以下情况下使用延迟加载： - 降低网页初始的启动时间 - 执行 A/B 测试，比如测试对比同一个算法的不同实现方式 - 载入极少使用的功能，比如设置页面和对话框</p><blockquote><p>注意，只有 dart2js 支持延迟加载</p></blockquote><p>使用 <code>deferred as</code> 来指定延迟加载的库，然后在需要使用这个库的时候，调用他的 <code>loadLibrary()</code>方法： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> `package:greetings/hello.dart` deffered <span class="keyword">as</span> hello;</span><br><span class="line"></span><br><span class="line">Future greet)() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> hello.loadLibrary();</span><br><span class="line">  hello.printGreeting();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 上边的代码中， <code>await</code> 关键字暂停了代码的执行，直到库加载完毕。关于 <code>await</code> 和 <code>async</code> 的更多信息，参考 <a href="https://dart.dev/guides/language/language-tour#asynchrony-support">asynchrony</a> 。 你可以多次调用同一个库 <code>loadLibrary()</code>,这个库只会载入一次。 记住以下几条： - 延迟加载的库中的常量在导入的文件中不是常量，只有库载入了之后才会存在这些常量 - 在导入文件中，不能使用延迟加载的库中的数据类型。你可以把接口类型定义放到两个库都需要导入的第三个库中。 - Dart 会隐式的向你使用 <code>deferrred as namespace</code> 的namespace 中插入 <code>loadLibrary()</code> 方法。<code>loadLibrary()</code> 方法返回 <a href="https://dart.dev/guides/libraries/library-tour#future">Future</a> 对象。</p><h3 id="implementing-libraries">Implementing libraries</h3><p>关于如何创建库，参考<a href="https://dart.dev/guides/libraries/create-library-packages">Create Library Packages</a>,内容包括： - 库中源码的组织结构 - 如何使用 <code>export</code> 指令 - 何时使用 <code>part</code> 指令 - 何时使用 <code>library</code> 指令 - 如何使用条件导出和导入从而实现跨平台的库</p><h2 id="asynchrony-support">Asynchrony support</h2><p>Dart 的库中有无数的函数返回 <a href="https://api.dart.dev/stable/dart-async/Future-class.html">Future</a> 或 <a href="https://api.dart.dev/stable/dart-async/Stream-class.html">Stream</a> 类型的对象。这些函数都是 <em>异步的</em>。这些函数可能执行一些消耗时间的操作（比如 I/O 操作），但不用等到操作结束才返回。</p><p><code>async</code> 和 <code>await</code> 关键词支持异步编程，让你编写的异步代码看起来和同步代码很相似。</p><h3 id="handling-futures">Handling Futures</h3><p>当你需要获取执行完成的 Future 的结果的时候，你有两种做法： - 使用 <code>async</code> 和 <code>await</code> - 使用 Future API，如 <a href="https://dart.dev/guides/libraries/library-tour#future">这里</a> 所述</p><p>使用 <code>async</code> 和 <code>await</code> 的代码是异步的，但是看起来非常像同步代码。下面的代码使用 <code>await</code> 等待异步函数的执行结果： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> lookUpVersion();</span><br></pre></td></tr></table></figure> 如果使用了 <code>await</code> 关键字，它必须在 <code>async</code> 函数中才能使用： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future checkVersion() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> version = <span class="keyword">await</span> lookUpVersion();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在 <code>async</code> 函数中可以多次使用 <code>await</code>。比如下面的代码等待了三次： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entrypoint = <span class="keyword">await</span> findEntrypoint();</span><br><span class="line"><span class="keyword">var</span> exitCode = <span class="keyword">await</span> runExecutable(entrypoint, args);</span><br><span class="line"><span class="keyword">await</span> flushThenExit(exitCode);</span><br></pre></td></tr></table></figure> 在 <code>await</code> <em>expression</em> 中，<em>expression</em>的值通常是一个 Future；如果不是，<em>expression</em>的值会自动被包装成一个 Future。Future 对象表示一个返回对象的承诺。<code>await</code> <em>expression</em> 的值就是返回的对象。<code>await</code> 表达式使代码的执行暂停到返回值可用。</p><p>如果在使用 <code>await</code> 的过程中发生编译异常，收线要确定 <code>await</code> 是被包含在 <code>async</code> 函数中。如果在 <code>main()</code> 函数中使用 <code>await</code>,你需要先把 <code>main()</code> 标记成 <code>async</code>: <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future main() <span class="keyword">async</span> &#123;</span><br><span class="line">  checkVersion();</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;In main: version is <span class="subst">$&#123;await lookUpVersion()&#125;</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="declaring-async-functions">Declaring async functions</h4><p><code>async</code> 函数指的是函数体被 <code>async</code> 关键字标记的函数。 被 <code>async</code> 标记的函数的返回值类型是 Future 。比如下边的函数返回 String ： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> lookUpVersion() =&gt; <span class="string">&#x27;1.0.0&#x27;</span>;</span><br></pre></td></tr></table></figure> 如果把上边的函数改为 <code>async</code> 函数，由于 future 类型的的实现对时间的消耗较多，它的返回值类型是 Future: <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">String</span>&gt; lookUpVersion() <span class="keyword">async</span> =&gt; <span class="string">&#x27;1.0.0&#x27;</span>;</span><br></pre></td></tr></table></figure> 需要注意的是函数体本身并不需要使用 Future 的 API。Dart 会在必要时创建 Future 对象。如果函数没有返回值，就让他默认返回 <code>Future&lt;void&gt;</code> 类型。 对于 <code>async</code> 和 <code>await</code> 的交互式教程，参考 <a href="https://dart.dev/codelabs/async-await">asynchronous programming codelab</a>。</p><h4 id="handling-streams">Handling Streams</h4><p>当你需要从 Stream 中获取数据的时候，你有两种方法： - 使用 <code>async</code> 和异步的 for 循环(<code>await for</code>) - 使用 Stream API，描述见 <a href="https://dart.dev/guides/libraries/library-tour#stream">library tour</a></p><blockquote><p>在使用 <code>await for</code> 之前，一定要想清楚，<code>await for</code> 是否可以使你的代码更加整洁，你是否真的需要等待Stream 中的每个结果。比如，对于 UI 事件的监听，不应该使用 <code>await for</code> ,因为 UI 框架的事件流会发生无尽的事件。</p></blockquote><p>异步 for 循环代码如下： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">for</span> (varOrType identifier <span class="keyword">in</span> expression) &#123;</span><br><span class="line">  <span class="comment">// 流中每发生一次事件就会执行一次这里的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 上边代码中 <code>expression</code> 的值必须是 Stream 类型，代码的执行流程如下： 1. 等待流中发出事件。 2. 执行循环体的代码，事件被赋值给 identifier。 3. 重复以上两步，一直到 Stream 关闭。</p><p>可以使用 <code>break</code> 或 <code>return</code> 语句退出循环，来结束对 Stream 的监听。</p><p>如果在编写异步 for 循环代码时发生编译错误，你可以检查代码，确保 <code>await for</code> 语句是被包含在 <code>async</code> 函数中。比如为了在 <code>main()</code> 函数中使用异步 for 循环，<code>main()</code> 必须使用 <code>async</code> 标记： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future main() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> request <span class="keyword">in</span> requestServer) &#123;</span><br><span class="line">    handleRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 异步编程的更多信息吗，参考 <a href="https://dart.dev/guides/libraries/library-tour#dartasync---asynchronous-programming">dart:sync</a> 。</p><h2 id="generators">Generators</h2><p>在你需要懒生成（lazily produce）一系列的数据的时候，你可以考虑使用 <em>生成器函数</em> 来实现。Dart 内置了两种对生成器函数的支持： - 同步生成器：返回 <a href="https://api.dart.dev/stable/dart-core/Iterable-class.html">Iterable</a> 对象。 - 异步生成器：返回 <a href="https://api.dart.dev/stable/dart-async/Stream-class.html">Stream</a> 对象。</p><p>使用 <code>sync *</code> 标记函数体，并使用 <code>yield</code> 语句来输出数据，这样就定义了一个同步的生成器函数： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Iterable</span>&lt;<span class="built_in">int</span>&gt; naturalsTo(<span class="built_in">int</span> n) <span class="keyword">sync</span> * &#123;</span><br><span class="line">  <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; n) <span class="keyword">yield</span> k++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 使用 <code>async *</code> 来标记函数体，并用 <code>yield</code> 来输出数据，这样就定义了一个异步生成器： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Strng&lt;<span class="built_in">int</span>&gt; asynchronousNaturalsTo(<span class="built_in">int</span> n) <span class="keyword">async</span>* &#123;</span><br><span class="line">  <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; n) <span class="keyword">yield</span> k++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 如果你的生成器是一个递归函数，可以使用 <code>yield*</code> 来提升他的性能： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Iterable</span>&lt;<span class="built_in">int</span>&gt; naturalsDownFrom(<span class="built_in">int</span> n) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> n;</span><br><span class="line">    <span class="keyword">yield</span>* natutalsDownFrom(n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="callable-classes">Callable classes</h2><p>通过实现 <code>call()</code> 方法，可以让实例对象像函数一样被调用。 在下边的例子中，<code>WannableFunnctionn</code> 类定义了 call() 函数，接受3个字符串类型的参数以空格建个把他们连接在一起并增加一个感叹号结尾： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WannableFunction</span> </span>&#123;</span><br><span class="line">  call(<span class="built_in">String</span> a, <span class="built_in">String</span> b, <span class="built_in">String</span> c) =&gt; <span class="string">&#x27;<span class="subst">$a</span> <span class="subst">$b</span> <span class="subst">$c</span>!&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()  &#123;</span><br><span class="line">  <span class="keyword">var</span> wf = <span class="keyword">new</span> WannableFunction();</span><br><span class="line">  <span class="keyword">var</span> out = wf(<span class="string">&quot;Hi&quot;</span>, <span class="string">&quot;there&quot;</span>, <span class="string">&quot;gang&quot;</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$out</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="isolates">Isolates</h2><p>多数的计算机系统都有多核CPU。为了充分利用多核优势，开发者通常使用多线程共享内存来并行运行。然而，同步共享状态不仅仅容易发生错误，而且也让代码更加复杂，</p><p>与线程不同，Dart 代码运行在 <em>isolates</em> 中。每个 <em>isolate</em> 有它自己的内存栈区，保证从外部无法访问到 <em>isolate</em> 的内部。</p><p>更多信息参考： - <a href="https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a">Dart asynchronous programming: Isolates and event loops</a> - <a href="https://api.dart.dev/stable/dart-isolate">dart:isolate API reference</a> ，包括 <a href="https://api.dart.dev/stable/dart-isolate/Isolate/spawn.html">Isolate.spawn()</a> 和 <a href="https://api.dart.dev/stable/dart-isolate/TransferableTypedData-class.html">Transferable TypedData</a> - <a href="https://flutter.dev/docs/cookbook/networking/background-parsing">Background parsing</a> 指南 - <a href="https://github.com/flutter/samples/tree/master/isolate_example">Isolate sample app</a></p><h2 id="typedefs">Typedefs</h2><p>在 Dart 中，函数也是对象，是和字符串、数字等一样的对象。<em>typedef</em> 或者 <em>function-type alias</em>，给函数类型一个名字，你可以在声明数据、函数返回值时使用这个名字。当函数被赋值给变量时候， typedef 包含了函数类型信息。</p><p>看下边不使用 typedef 的代码： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedCollection</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Function</span> compare;</span><br><span class="line"></span><br><span class="line">  SortedCollection(<span class="built_in">int</span> f(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b)) &#123;</span><br><span class="line">    compare = f;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的实现</span></span><br><span class="line"><span class="built_in">int</span> sort(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b) =&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  SortedCollection coll = SortedCollection(sort);</span><br><span class="line">  <span class="comment">//我们只知道 compare 是一个函数，但函数的类型是什么？</span></span><br><span class="line">  <span class="keyword">assert</span>(coll.compare <span class="keyword">is</span> <span class="built_in">Function</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 上边的代码在把 <code>f</code> 赋值给 <code>compare</code> 的时候已经丢失了函数的类型信息。<code>f</code> 的类型是 <code>(Object, Object) → int</code> (→ 表示返回值)， <code>compare</code> 的类型是 Function。如果我们改变代码使用命名来保存类型信息，那么开发者和开发工具就都可以利用这个信息了： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Compare = <span class="built_in">int</span> <span class="built_in">Function</span>(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedCollection</span> </span>&#123;</span><br><span class="line">  Compare compare;</span><br><span class="line">  SortedColloection(<span class="keyword">this</span>.compare);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sort(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b) =&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  SortedCollection coll = SortedCollectionn(sort);</span><br><span class="line">  <span class="keyword">assert</span>(coll.compare <span class="keyword">is</span> <span class="built_in">Function</span>);</span><br><span class="line">  <span class="keyword">assert</span>(coll.compare <span class="keyword">is</span> Compare);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 由于 typedef 仅仅是别名而已，他们只是提供了检查对函数类型的检查： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Compare&lt;T&gt; = <span class="built_in">int</span> Functionn(T a, T b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sort(<span class="built_in">int</span> a, <span class="built_in">int</span> b) =&gt; a - b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(sort <span class="keyword">is</span> Compare&lt;<span class="built_in">int</span>&gt;); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="metadata">Metadata</h2><p>通过 metadata 来给出代码的更多信息。 metadata 使用 <code>@</code> 来标注，后面紧跟一个编译时常量（比如 <code>deprecated</code>） 或者调用一个常量构造函数。</p><p>有两个标注是适用于所有 Dart 代码的： <code>@deprecated</code> 和 <code>@override</code> 。关于 <code>@override</code> 的使用，参考 <a href="https://dart.dev/guides/language/language-tour#extending-a-class">Extending a class</a> 。下边是使用 <code>deprecated</code> 的例子： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown"><span class="emphasis">_Deprecated: Use [tuenOn] instead .</span></span></span></span><br><span class="line">  <span class="meta">@deprecated</span></span><br><span class="line">  <span class="keyword">void</span> activate() &#123;</span><br><span class="line">    turnOn();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// <span class="markdown"><span class="emphasis">Turns the TV&#x27;s power on.</span></span></span></span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 你也可以自定义标注，下边定义的 <span class="citation" data-cites="todo">@todo</span> 标注，它有两个参数： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span> todo;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> who;</span><br><span class="line">  finnal <span class="built_in">String</span> what;</span><br><span class="line">  <span class="keyword">const</span> Todo(<span class="keyword">this</span>.who, <span class="keyword">this</span>.what);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> Metadata 可以出现在 library, class, typedef, type parameter, constructor, factory, field, parameter 或 variable declaration 之前，也可以在 import 和 export 指令之前。你可以通过反射在运行时获取 metadata 。</p><h2 id="comments">Comments</h2><p>Dart 支持单行注释，多行注释和文档注释。</p><h3 id="single-line-commennts">Single-line commennts</h3><p>单行注释以 <code>//</code> 开头，在 <code>//</code> 到行尾的任何内容都会被 Dart 编译器忽略掉。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> refactor into an AbstractLlamaGreetingFacyoty?</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Welcome to my Llama farm!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="multi-linne-comments">Multi-linne comments</h3><p>多行注释以 <code>/*</code> 开头， 以 <code>*/</code> 结尾。Dart 编译器会忽略<code>/* */</code> 之间（文档注释除外，建下文）的所有内容。多行注释内部可能包含多行注释。 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * This is a lot of work. Consider raising chikens.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Llama larry = Llama();</span></span><br><span class="line"><span class="comment">   larry.feed();</span></span><br><span class="line"><span class="comment">   larry.exercise();</span></span><br><span class="line"><span class="comment">   larry.clean();</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="documentation-comments">Documentation comments</h3><p>文档注释可以是以 <code>///</code> 开头的单行注释或是以 <code>/**</code> 开头的多行注释。连续使用多行 <code>///</code> 与多行文档注释效果相同。</p><p>在文档注释中，Dart 编译器会忽略所有文字（在括号中间的除外）。你可以使用引号来引用类、方法、顶层变量、函数和参数。The names in brackets are resolved in the lexical scope of the documented program element. 下边的文档注释引用了其他类和参数： <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">A domesticated South Ameracan camelid (Lama glama).</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="markdown">Andean cultures have used llamas as meat and pack</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">animals since pre-Hispanic times.</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Llama</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Feeds yout llama [Food].</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">The typical llama eats one bale of hay per week.</span></span></span><br><span class="line">  <span class="keyword">void</span> feed(Food food) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在生成的文档中， <code>[Food]</code> 就变成了指向Food 类的API 文档的链接。</p><p>你可以使用 Dart SDK 中的<a href="https://github.com/dart-lang/dartdoc#dartdoc">文档工生成具</a>分析 Dart 代码来生成网页格式的文档。关于生成文档的例子，参考<a href="https://api.dart.dev/stable">Dart API documentation</a>。关于如何编写注释的指南，见 <a href="https://dart.dev/guides/language/effective-dart/documentation">Guildelines for Dart Doc Comments</a> 。</p><h2 id="summary">Summary</h2><p>本文简述了 Dart 语言中常用的特性。还有更多的特性正在实现中，我们希望新特性不会破坏与当前特性的兼容性。更多信息参考 <a href="https://dart.dev/guides/language/spec">Dart language specification</a> 和 <a href="https://dart.dev/guides/language/effective-dart">Effective Dart</a> 。</p><p>关于 Dart 核心库的更多内容，参考 <a href="https://dart.dev/guides/libraries/library-tour">A Tour of the Dart Libraries</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文见：&lt;a href=&quot;https://www.dartlang.org/guides/language/language-tour&quot;&gt;A Tour of the Dart Language&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文</summary>
      
    
    
    
    <category term="Dart" scheme="https://www.zhangyuzheng.com/categories/Dart/"/>
    
    
    <category term="Dart" scheme="https://www.zhangyuzheng.com/tags/Dart/"/>
    
    <category term="Flutter" scheme="https://www.zhangyuzheng.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>dart语言之旅</title>
    <link href="https://www.zhangyuzheng.com/Dart/dart%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%85/"/>
    <id>https://www.zhangyuzheng.com/Dart/dart%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%85/</id>
    <published>2018-05-28T10:01:38.000Z</published>
    <updated>2021-08-14T03:53:53.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="a-tour-of-the-dart-language">A Tour of the Dart Language</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;a-tour-of-the-dart-language&quot;&gt;A Tour of the Dart Language&lt;/h1&gt;
</summary>
      
    
    
    
    <category term="Dart" scheme="https://www.zhangyuzheng.com/categories/Dart/"/>
    
    
    <category term="Dart" scheme="https://www.zhangyuzheng.com/tags/Dart/"/>
    
  </entry>
  
  <entry>
    <title>Variables:Creation, Initialization, Saving, and Loading</title>
    <link href="https://www.zhangyuzheng.com/TensorFlow/TensorFlow%20Variables/"/>
    <id>https://www.zhangyuzheng.com/TensorFlow/TensorFlow%20Variables/</id>
    <published>2017-01-15T04:12:00.000Z</published>
    <updated>2021-08-14T03:53:53.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="variables-creation-initialization-saving-and-loading">Variables: Creation, Initialization, Saving, and Loading</h1><p>在训练模型的过程中，我们使用 <code>Variable</code> 来保存和更新参数。<code>Variable</code> 是用来保存 Tensor<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> 的内存缓冲区，你必须明确声明它们。无论是在训练的过程中或者之后，你都可以把它们保存到磁盘中。之后你可以从磁盘读取之前保存的内容来继续训练或者分析模型。</p><p>本文使用了下面的类，打开下面的链接查看详细文档：</p><ul><li><a href="https://www.tensorflow.org/api_docs/python/state_ops/variables#Variable">tf.Variable</a></li><li><a href="https://www.tensorflow.org/api_docs/python/state_ops/saving_and_restoring_variables#Saver">tf.train.Saver</a></li></ul><h2 id="creation">Creation</h2><p>创建 Variable 时你需要给它的构造函数 <code>tf.Variable()</code> 传递一个 Tensor<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> 作为它的初始值。TensorFlow 提供了一系列使用常量或随机值来生成 Tensor 的操作。</p><p>你要知道这些操作都需要你指定生成的 Tensor 的形状，这个形状就自动成为了生成的 Variable 的形状。一般 Variable 的形状都是固定的，但是 TensorFlow 提供了修改 Variable 形状的高级机制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create two variables.</span></span><br><span class="line">weights = tf.Variable(tf.random_normal([<span class="number">784</span>, <span class="number">200</span>], stddev=<span class="number">0.35</span>),</span><br><span class="line">                      name=<span class="string">&quot;weights&quot;</span>)</span><br><span class="line">biases = tf.Variable(tf.zeros([<span class="number">200</span>]), name=<span class="string">&quot;biases&quot;</span>)</span><br></pre></td></tr></table></figure><p>通过调用 <code>tf.Variable()</code> 函数，你对图添加了如下操作：</p><ul><li>一个 <code>variable</code> 操作，用来保存变量的值。</li><li>一个初始化操作，设置变量的初始值，实际上是使用 <code>tf.assign</code> 操作来实现的。</li><li>把所有初始化操作都添加到图中，比如上面例子中 <code>biases</code> 的 <code>zeros</code> 操作。</li></ul><p><code>tf.Variable()</code> 的返回值是 Python 的 <code>tf.Variable</code> 类型的实例。</p><h2 id="device-placement">Device placement</h2><p>创建变量时，可以使用 <code>with tf.device(...):</code> 为变量分配特定的设备。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pin a variable to CPU. 分配变量到CPU。</span></span><br><span class="line"><span class="keyword">with</span> tf.device(<span class="string">&quot;/cpu:0&quot;</span>):</span><br><span class="line">  v = tf.Variable(...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pin a variable to GPU.  分配变量到GPU。</span></span><br><span class="line"><span class="keyword">with</span> tf.device(<span class="string">&quot;/gpu:0&quot;</span>):</span><br><span class="line">  v = tf.Variable(...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pin a variable to a particular parameter server task. 分配变量到特定参数服务器任务。</span></span><br><span class="line"><span class="keyword">with</span> tf.device(<span class="string">&quot;/job:ps/task:7&quot;</span>):</span><br><span class="line">  v = tf.Variable(...)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 修改变量的操作(比如 <a href="https://www.tensorflow.org/api_docs/python/state#Variable.assign"><code>v.assign()</code></a>)和 参数更新(比如  <a href="https://www.tensorflow.org/api_docs/python/train/optimizers#Optimizer"><code>tf.train.Optimizer</code></a> ) 操作都必须与相应的变量运行在相同设备上，否则在创建这些操作时，错误的设备分配指令会被忽略掉。</p><p>在设置重复的代码中，设备分配尤其重要。参考<a href="https://www.tensorflow.org/api_docs/python/train/distributed_execution#replica_device_setter"><code>tf.train.replica_device_setter()</code></a> 查看详细信息。</p><h2 id="initialization">Initialization</h2><p>变量的初始化必须在你模型中任何其他操作运行之前明确(explicitly)的运行。最简单的办法就是增加一个初始化所有初始化函数的操作，并在你使用模型之前运行这个操作。</p><p>你还可以选择重 checkpoint 文件中恢复变量，这一点后文会详细介绍。</p><p>使用 <code>tf.global_variables_initializer()</code> 来增加运行初始化函数的操作，并在只在模型构造完成启动 Session 之后运行这个初始化操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create two variables.</span></span><br><span class="line">weights = tf.Variable(tf.random_normal([<span class="number">784</span>, <span class="number">200</span>], stddev=<span class="number">0.35</span>),</span><br><span class="line">                      name=<span class="string">&quot;weights&quot;</span>)</span><br><span class="line">biases = tf.Variable(tf.zeros([<span class="number">200</span>]), name=<span class="string">&quot;biases&quot;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="comment"># Add an op to initialize the variables.</span></span><br><span class="line">init_op = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Later, when launching the model</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">  <span class="comment"># Run the init operation.</span></span><br><span class="line">  sess.run(init_op)</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment"># Use the model</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h3 id="initialization-from-another-variable">Initialization from another Variable</h3><p>有时你需要使用一个变量来初始化另一个变量。由于 <code>tf.global_variables_initializer()</code> 添加的初始化操作是并行运行的，所以这时你要谨慎对待。</p><p>你需要使用一个变量的 <code>initialized_value()</code> 属性来初始化另一个变量。你既可以直接使用变量的值也可以把变量的值与其他 Tensor 做运算后的值作为新变量的初始值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a variable with a random value.</span></span><br><span class="line">weights = tf.Variable(tf.random_normal([<span class="number">784</span>, <span class="number">200</span>], stddev=<span class="number">0.35</span>),</span><br><span class="line">                      name=<span class="string">&quot;weights&quot;</span>)</span><br><span class="line"><span class="comment"># Create another variable with the same value as &#x27;weights&#x27;.</span></span><br><span class="line">w2 = tf.Variable(weights.initialized_value(), name=<span class="string">&quot;w2&quot;</span>)</span><br><span class="line"><span class="comment"># Create another variable with twice the value of &#x27;weights&#x27;</span></span><br><span class="line">w_twice = tf.Variable(weights.initialized_value() * <span class="number">2.0</span>, name=<span class="string">&quot;w_twice&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="custom-initialization">Custom Initialization</h3><p><code>tf.global_variables_initializer()</code> 这个方便的操作会向模型中增加初始化所有变量的操作。你也可以传递一个初始化列表来指定需要初始化的变量。参考<a href="https://www.tensorflow.org/api_docs/python/state_ops">Variables Documentation</a>， 其中也包含了如何检查变量是否已经初始化过。</p><h2 id="saving-and-restoring">Saving and Restoring</h2><p>保存和回复模型最简单的方法就是使用 <code>tf.train.Saver</code> 对象。它的构造函数会为图中多有变脸或指定的变量增加 <code>save</code> 和 <code>restore</code> 操作。<code>Saver</code> 对象提供了执行这些操作以及指定 checkpoint 文件的方法。</p><h3 id="checkpoint-files">Checkpoint Files</h3><p>变量保存在二进制文件中，这个文件基本包含了从变量名字到对应 Tensor 的映射。</p><p>创建 <code>Saver</code> 的时候，你可以指定需要存储的变量的名字，默认使用 <a href="https://www.tensorflow.org/api_docs/python/state_ops/variables#Variable.name"><code>Variable.name</code></a> 作为变量的名字。</p><p>你可以使用  <a href="https://www.tensorflow.org/code/tensorflow/python/tools/inspect_checkpoint.py"><code>inspect_checkpoint</code></a> 库中的 <code>print_tensors_in_checkpoint_file</code> 来获取 checkpoint 文件中包含的变量信息。</p><h3 id="saving-variables">Saving Variables</h3><p>使用 <code>tf.train.Saver()</code> 创建 <code>Saver</code> 对象来管理模型中的所有变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create some variables.</span></span><br><span class="line">v1 = tf.Variable(..., name=<span class="string">&quot;v1&quot;</span>)</span><br><span class="line">v2 = tf.Variable(..., name=<span class="string">&quot;v2&quot;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="comment"># Add an op to initialize the variables.</span></span><br><span class="line">init_op = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add ops to save and restore all the variables.</span></span><br><span class="line">saver = tf.train.Saver()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Later, launch the model, initialize the variables, do some work, save the</span></span><br><span class="line"><span class="comment"># variables to disk.</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">  sess.run(init_op)</span><br><span class="line">  <span class="comment"># Do some work with the model.</span></span><br><span class="line">  ..</span><br><span class="line">  <span class="comment"># Save the variables to disk.</span></span><br><span class="line">  save_path = saver.save(sess, <span class="string">&quot;/tmp/model.ckpt&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Model saved in file: %s&quot;</span> % save_path)</span><br></pre></td></tr></table></figure><h3 id="restoring-variables">Restoring Variables</h3><p>使用同一个 <code>Saver</code> 对象来恢复变量。注意，从文件中恢复变量时，你不需要事前先初始化这些变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create some variables.</span></span><br><span class="line">v1 = tf.Variable(..., name=<span class="string">&quot;v1&quot;</span>)</span><br><span class="line">v2 = tf.Variable(..., name=<span class="string">&quot;v2&quot;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="comment"># Add ops to save and restore all the variables.</span></span><br><span class="line">saver = tf.train.Saver()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Later, launch the model, use the saver to restore variables from disk, and</span></span><br><span class="line"><span class="comment"># do some work with the model.</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">  <span class="comment"># Restore variables from disk.</span></span><br><span class="line">  saver.restore(sess, <span class="string">&quot;/tmp/model.ckpt&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Model restored.&quot;</span>)</span><br><span class="line">  <span class="comment"># Do some work with the model</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h3 id="choosing-which-variables-to-save-and-restore">Choosing which Variables to Save and Restore</h3><p>如果你不向 <code>tf.train.Saver()</code> 传递任何参数，它会默认处理图中的所有变量。每个变量都保存在创建时指定的名字下。</p><p>有时明确指定保存在 checkpoint 文件中变量的名字是非常有用的。比如你训练的模型中包含一个叫 <code>weights</code> 的变量，而你想把它恢复到叫做 <code>params</code> 的新变量中。</p><p>在你只想保存和恢复现有变量的子集的时候页非常有用。比如你之前训练了一个五层的神经网络，现在你想训练一个六层的神经网络，那么你可以恢复之前训练好的的五层神经网络的参数到新模型的前五层。</p><p>你还可以传递一个字典给 <code>tf.train.Saver()</code> 来指定需要保存的变量名字和变量，字典的 key 是名字，value 是变量。</p><p>注意：</p><ul><li>你可以按需创建多个 <code>Saver</code> 对象，同一个变量可以被多个 <code>Saver</code> 操作，只有在调用 <code>saver.restore()</code> 的时候变量的值才会改变。</li><li>如果你只在 Session 开始的时候恢复模型中的部分变量，那么你必须运行初始化操作来初始化其他的变量。参考 <a href="https://www.tensorflow.org/api_docs/python/state_ops/exporting_and_importing_meta_graphs#initialize_variables"><code>tf.initialize_variables()</code></a> 。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create some variables.</span></span><br><span class="line">v1 = tf.Variable(..., name=<span class="string">&quot;v1&quot;</span>)</span><br><span class="line">v2 = tf.Variable(..., name=<span class="string">&quot;v2&quot;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="comment"># Add ops to save and restore only &#x27;v2&#x27; using the name &quot;my_v2&quot;</span></span><br><span class="line">saver = tf.train.Saver(&#123;<span class="string">&quot;my_v2&quot;</span>: v2&#125;)</span><br><span class="line"><span class="comment"># Use the saver object normally after that.</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><section class="footnotes"><hr /><ol><li id="fn1"><p><a href="https://www.wikiwand.com/zh-hans/%E5%BC%B5%E9%87%8F">张量</a><a href="#fnref1" class="footnote-back">↩</a></p></li><li id="fn2"><p><a href="https://www.wikiwand.com/zh-hans/%E5%BC%B5%E9%87%8F">张量</a><a href="#fnref2" class="footnote-back">↩</a></p></li></ol></section>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;variables-creation-initialization-saving-and-loading&quot;&gt;Variables: Creation, Initialization, Saving, and Loading&lt;/h1&gt;
&lt;p&gt;在训练模型的过程中，我们使</summary>
      
    
    
    
    <category term="TensorFlow" scheme="https://www.zhangyuzheng.com/categories/TensorFlow/"/>
    
    
    <category term="TensorFlow" scheme="https://www.zhangyuzheng.com/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>Git 删除 Submodule</title>
    <link href="https://www.zhangyuzheng.com/Git/GitRemoveSubmodule/"/>
    <id>https://www.zhangyuzheng.com/Git/GitRemoveSubmodule/</id>
    <published>2017-01-12T15:03:00.000Z</published>
    <updated>2021-08-14T03:53:53.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因">起因</h2><p>自己搞 Github pages 的时候用了 Git 的子模块 （submodule），后来删除的时候发现 git 的 submodule 命令根本就没有提供删除功能，于是 Google 、百度，发现只能手动删除，总结如下。 # 实践 - 从 <code>.gitmodules</code> 中删除你想要删除的子模块相关的配置，我这里想删掉的就是这两个子模块，如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[submodule &quot;output&quot;]</span><br><span class="line">       path = output</span><br><span class="line">       url = git@github.com:zhangyuz/zhangyuz.github.io.git</span><br><span class="line">[submodule &quot;zhangyuz.github.io&quot;]</span><br><span class="line">       path = zhangyuz.github.io</span><br><span class="line">       url = git@github.com:zhangyuz/zhangyuz.github.io.git</span><br></pre></td></tr></table></figure> - 暂存对 <code>.gitmodules</code> 的修改： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .gitmodules</span><br></pre></td></tr></table></figure> - 从 <code>.git/config</code> 中删除上面两个子模块相关配置： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[submodule &quot;output&quot;]</span><br><span class="line">url = git@github.com:zhangyuz/zhangyuz.github.io.git</span><br><span class="line">[submodule &quot;zhangyuz.github.io&quot;]</span><br><span class="line">url = git@github.com:zhangyuz/zhangyuz.github.io.git</span><br></pre></td></tr></table></figure> - 从仓库中删除相关记录: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached output</span><br><span class="line">git rm --cached zhangyuz.github.io</span><br></pre></td></tr></table></figure> &gt; 不要包含路径最后的斜杠 /。</p><ul><li><p>删除仓库文件： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rfv .git/modules/output/</span><br><span class="line">rm -rfv .git/modules/zhangyuz.github.io/</span><br></pre></td></tr></table></figure></p></li><li>现在这两个仓库变成了 untracked file， 删除即可： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf output/ zhangyuz.github.io/</span><br></pre></td></tr></table></figure></li><li><p>提交刚刚的修改： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --signoff</span><br></pre></td></tr></table></figure></p></li><li><p>最后查看下刚刚的修改： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">git show</span><br><span class="line">......</span><br><span class="line">diff --git a/.gitmodules b/.gitmodules</span><br><span class="line">index 8fabe85..297ff0b 100644</span><br><span class="line">--- a/.gitmodules</span><br><span class="line">+++ b/.gitmodules</span><br><span class="line">@@ -4,9 +4,3 @@</span><br><span class="line"> [submodule &quot;themes/pure&quot;]</span><br><span class="line">        path = themes/pure</span><br><span class="line">        url = https://github.com/PurePelicanTheme/pure.git</span><br><span class="line">-[submodule &quot;output&quot;]</span><br><span class="line">-       path = output</span><br><span class="line">-       url = git@github.com:zhangyuz/zhangyuz.github.io.git</span><br><span class="line">-[submodule &quot;zhangyuz.github.io&quot;]</span><br><span class="line">-       path = zhangyuz.github.io</span><br><span class="line">-       url = git@github.com:zhangyuz/zhangyuz.github.io.git</span><br><span class="line">Submodule output e4c24a3...0000000 (submodule deleted)</span><br><span class="line">Submodule zhangyuz.github.io 7a72305...0000000 (submodule deleted)</span><br></pre></td></tr></table></figure></p></li></ul><p>收工睡觉～～～</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;起因&lt;/h2&gt;
&lt;p&gt;自己搞 Github pages 的时候用了 Git 的子模块 （submodule），后来删除的时候发现 git 的 submodule 命令根本就没有提供删除功能，于是 Google 、百度，发现只能手动删除，总结如下。 # 实践</summary>
      
    
    
    
    <category term="Git" scheme="https://www.zhangyuzheng.com/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>Pelican Support LaTex How To</title>
    <link href="https://www.zhangyuzheng.com/Pelican/Pelican%20Support%20LaTex%20How%20To/"/>
    <id>https://www.zhangyuzheng.com/Pelican/Pelican%20Support%20LaTex%20How%20To/</id>
    <published>2017-01-02T02:35:00.000Z</published>
    <updated>2021-08-14T03:53:53.478Z</updated>
    
    <content type="html"><![CDATA[<p>最近在自学 Andrew Ng 的机器学习课程，使用MD记笔记的时候发现，默认 <code>Pelican</code> 并不支持 <code>LaTex</code> 的数学公式。原来 <code>Pelican</code> 中默认数学公式是使用 <code>render_math</code> 这个插件来实现的，遂安装插件，然并卵。看了下，应该是 <code>Pelican</code>更新升级后 <code>render_math</code> 没有同步更新造成的。于是google之，对比几个方案后决定使用 Python Markdown的 <a href="https://github.com/mitya57/python-markdown-math"><code>mdx_math</code></a> 扩展 + 修改页面模板来实现。这应该是最简单的方案。</p><p>“Shut the fuck up, show me the code”。</p><h2 id="安装mdx_math">安装mdx_math</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install python-markdown-math</span><br></pre></td></tr></table></figure><p>选择 <code>mdx_math</code> 的原因无外乎就是社区活跃。看了其他几个扩展，最近的更新都已经块2年前了。</p><h2 id="pelican-设置">Pelican 设置</h2><p>增加 <a href="https://github.com/mitya57/python-markdown-math"><code>mdx_math</code></a> 扩展，由于默认不支持行内两个 $ 符号之间的公式，根据官方文档启用即可。修改如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/pelicanconf.py b/pelicanconf.py</span><br><span class="line">index 649aa9f..aef29da 100644</span><br><span class="line">--- a/pelicanconf.py</span><br><span class="line">+++ b/pelicanconf.py</span><br><span class="line">@@ -37,6 +37,7 @@ MARKDOWN = &#123;</span><br><span class="line">         &#x27;markdown.extensions.headerid&#x27;:&#123;&#125;,</span><br><span class="line">         &#x27;markdown.extensions.meta&#x27;: &#123;&#125;,</span><br><span class="line">         &#x27;markdown.extensions.toc&#x27;: &#123;&#x27;title&#x27;: &#x27;ToC&#x27;&#125;,</span><br><span class="line">+        &#x27;mdx_math&#x27;: &#123;&#x27;enable_dollar_delimiter&#x27;: True&#125;,</span><br><span class="line">     &#125;,</span><br><span class="line">     &#x27;output_format&#x27;: &#x27;html5&#x27;,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure> ## 修改页面模板增加MathJax支持 <a href="https://www.mathjax.org/">MathJax</a>是支持浏览器页面显示数学公式的JavaScript引擎。</p><p>我使用 <a href="https://github.com/PurePelicanTheme/pure"><code>pure</code></a> 主题，其他主题应该也都包含 <code>base.html</code>， 修改也是大同小异。你也可以来<a href="https://github.com/zhangyuz/pure">这里</a>获取我修改好的版本。 修改如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/templates/base.html b/templates/base.html</span><br><span class="line">index e407f94..fa80727 100644</span><br><span class="line">--- a/templates/base.html</span><br><span class="line">+++ b/templates/base.html</span><br><span class="line">@@ -33,6 +33,16 @@</span><br><span class="line"> </span><br><span class="line">     &lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">     &#123;% block head_js %&#125;&#123;% endblock %&#125;</span><br><span class="line">+</span><br><span class="line">+    &lt;script type=&quot;text/x-mathjax-config&quot;&gt;</span><br><span class="line">+        MathJax.Hub.Config(&#123;</span><br><span class="line">+          config: [&quot;MMLorHTML.js&quot;],</span><br><span class="line">+          jax: [&quot;input/TeX&quot;, &quot;output/HTML-CSS&quot;, &quot;output/NativeMML&quot;],</span><br><span class="line">+          extensions: [&quot;MathMenu.js&quot;, &quot;MathZoom.js&quot;]</span><br><span class="line">+        &#125;);</span><br><span class="line">+      &lt;/script&gt;</span><br><span class="line">+    &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">+</span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;body&gt;</span><br></pre></td></tr></table></figure></p><p>所有的修改就是这些。Let's check it out !!!</p><p><span class="math inline">\(E=MC^2\)</span></p><p><span class="math display">\[\sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}\]</span></p><blockquote><p>部分官方文档： For inline math, use <code>\(...\)</code>. For standalone math, use <code>$$...$$</code>, <code>\[...\]</code> or <code>\begin...\end</code>. The single-dollar delimiter <code>($...$)</code> for inline math is disabled by default, but can be enabled by passing <code>enable_dollar_delimiter=True</code> in the extension configuration. If you want to render to span elements with inline math rather than script elements, so as to improve fallback when JavaScript is disabled or unavailable, use <code>render_to_span=True</code>.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在自学 Andrew Ng 的机器学习课程，使用MD记笔记的时候发现，默认 &lt;code&gt;Pelican&lt;/code&gt; 并不支持 &lt;code&gt;LaTex&lt;/code&gt; 的数学公式。原来 &lt;code&gt;Pelican&lt;/code&gt; 中默认数学公式是使用 &lt;code&gt;rende</summary>
      
    
    
    
    <category term="Pelican" scheme="https://www.zhangyuzheng.com/categories/Pelican/"/>
    
    
    <category term="Pelican" scheme="https://www.zhangyuzheng.com/tags/Pelican/"/>
    
  </entry>
  
  <entry>
    <title>逻辑回归</title>
    <link href="https://www.zhangyuzheng.com/MachineLearning/LogisticRegression/"/>
    <id>https://www.zhangyuzheng.com/MachineLearning/LogisticRegression/</id>
    <published>2016-12-31T11:48:00.000Z</published>
    <updated>2021-08-14T03:53:53.474Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.coursera.org/learn/machine-learning/home/week/3">原址</a> # Classification and Representation</p><p>逻辑回归是把数据分类为离散数据的一种方法。比如区分垃圾邮件。</p><h2 id="classification-分类">Classification 分类</h2><p>分类在本质上并不是线性回归。</p><p>分类问题与回归问题的的区别是我们要预测的值仅仅是有限的离散值。目前集中讨论二值分类的问题（比如分类的结果仅为1和0）。比如我们想构建一个垃圾邮件分配器，<span class="math inline">\(x^{(i)}\)</span>是邮件的一些特征，y=1表示垃圾邮件，y=0表示非垃圾邮件，因此y∈{0,1}。0也称为负类，1成为正类。有时使用"-"和"+"表示。对于指定的<span class="math inline">\(x^{(i)}\)</span>，<span class="math inline">\(y^{(i)}\)</span>也称为训练的标签（label）。</p><h2 id="hypothesis-representation-假设函数的表示">Hypothesis Representation 假设函数的表示</h2><figure><img src="%7Bfilename%7DHypothesisRepresentation01.png" alt="假设函数" /><figcaption>假设函数</figcaption></figure><p>我们想要的结果是 <span class="math inline">\(0≤h_θ≤1\)</span>。 <span class="math inline">\(g(z)=\frac{1}{1+e^{-z}}\)</span> 取值区间为0到1的S型曲线，称为SigmoidFunction或者LogisticFunction。如上图右下角图形所示。 逻辑回归的表达式为<span class="math inline">\(h_θ(x) = θ^Tx\)</span>，为了让<span class="math inline">\(h_θ\)</span>的值位于0到1之间，所以使<span class="math display">\[h_θ(x) = g(θ^Tx) = \frac{1}{1+e^{-θ^Tx}}\]</span> 接下来就是用参数θ来拟合我们的数据集。</p><p><img src="%7Bfilename%7DHypothesisRepresentation02.png" alt="对假设函数的解释" /> 上图是对假设函数的理解： <span class="math inline">\(h_θ(x)\)</span> 的意义是输入为x的时候y=1的概率。例如在某个情况下<span class="math inline">\(h_θ(x) = 0.7\)</span> 我们说在输入x为tumorSize的情况下，y为1的概率是0.7。 <span class="math inline">\(h_θ(x) = P(y=1|x;θ)\)</span></p><h2 id="decision-boundary">Decision Boundary</h2><p><img src="%7Bfilename%7DDecisionBoundary01.png" alt="假设函数使用" /> 假设函数的值大于等于0.5的时候我们预测y等于1，小于0.5预测y等于0。 观察S型曲线，发现： z大于等于0的时候，<span class="math inline">\(g(z)≥0.5\)</span>，y=1，既<span class="math inline">\(θ^Tx ≥ 0\)</span>. z小于0的时候，<span class="math inline">\(g(z)＜0.5\)</span>，y=0，既<span class="math inline">\(θ^Tx ＜ 0\)</span>.</p><h3 id="线性决策边界">线性决策边界</h3><p><img src="%7Bfilename%7DDecisionBoundary02.png" alt="DecisionBoundary" /> 假设<span class="math inline">\(h_θ(x) = g(θ_0 + θ_1x_1 + θ_2x_2)\)</span>，<span class="math inline">\(θ_0 = -3\)</span>,<span class="math inline">\(θ_1 = 1\)</span>, <span class="math inline">\(θ_2 =1\)</span>： 如果预测y=1，那么<span class="math inline">\(-3 + x_1 + x_2 ≥ 0\)</span> 既 <span class="math inline">\(x_1 + x_2 ≥3\)</span> 上图左上角坐标系，洋红色直线为<span class="math inline">\(h_θ(x) = 0.5\)</span>，是y预测为1或0的分界线。直线上方，y=1，直线下方y=1。这条直线就成为DecisionBoundary，决策边界。</p><p><strong>DecisionBoundary是假设函数的特性而不是数据集的属性。</strong></p><h3 id="非线性决策边界">非线性决策边界</h3><p><img src="%7Bfilename%7DDecisionBoundary03.png" alt="Non-LinearDecisionBoundary" /> 假设<span class="math inline">\(h_θ(x) = g(θ_0 + θ_1x_1 + θ_2x_2 + θ_3x_1^2 + θ_4x_2^2)\)</span>， <span class="math inline">\(θ_0=-1\)</span>,<span class="math inline">\(θ_1=0\)</span>,<span class="math inline">\(θ_2=0\)</span>,<span class="math inline">\(θ_3=1\)</span>,<span class="math inline">\(θ_4=1\)</span> 那么如果<span class="math inline">\(-1 + x_1^2 + x_2^2 ≥ 0\)</span> 预测为y=1。那么决策边界就是一个圆形。 假设<span class="math inline">\(h_θ(x) = g(θ_0 + θ_1x_1 + θ_2x_2 + θ_3x_1^2 + θ_4x_2^2 + θ_5x_1^3 + θ_6x_2^3 + ...)\)</span>，那么它的决策边界可能是各种奇形怪状的。</p><p>¹²³≈≡≠＝≤≥＜＞≮≯∷±∓＋－×÷／ ∫∮∝∞∧∨∑∏∪∩∈∵∴⊥∥∠⌒⊙≌∽√ αβγδεζηθικλμνξοπρστυφχψω ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩ §№☆★○●◎◇◆□℃‰■△▲※→←↑↓↖↗↘↙ 〓¤°＃＆＠＼︿＿￣―♂♀～Δ ㈠㈡㈢㈣㈤㈥㈦㈧㈨㈩①②③④⑤⑥⑦⑧⑨⑩</p><h1 id="logistic-regression-model">Logistic Regression Model</h1><h2 id="cost-function">Cost Function</h2><h2 id="simplified-cost-function-and-gradient-descent">Simplified Cost Function and Gradient Descent</h2><h2 id="advanced-optimization">Advanced Optimization</h2><h1 id="multiclass-classification">Multiclass Classification</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.coursera.org/learn/machine-learning/home/week/3&quot;&gt;原址&lt;/a&gt; # Classification and Representation&lt;/p&gt;
&lt;p&gt;逻辑回归是把数据分类为离散数据的一</summary>
      
    
    
    
    <category term="MachineLearning" scheme="https://www.zhangyuzheng.com/categories/MachineLearning/"/>
    
    
    <category term="MachineLearning" scheme="https://www.zhangyuzheng.com/tags/MachineLearning/"/>
    
    <category term="机器学习" scheme="https://www.zhangyuzheng.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="LogisticRegression" scheme="https://www.zhangyuzheng.com/tags/LogisticRegression/"/>
    
    <category term="逻辑回归" scheme="https://www.zhangyuzheng.com/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow基本使用</title>
    <link href="https://www.zhangyuzheng.com/TensorFlow/Tensorflow%20basic%20usage/"/>
    <id>https://www.zhangyuzheng.com/TensorFlow/Tensorflow%20basic%20usage/</id>
    <published>2016-12-25T07:01:00.000Z</published>
    <updated>2021-08-14T03:53:53.478Z</updated>
    
    <content type="html"><![CDATA[<p>本文为原文不完整翻译以及学习笔记。 <a href="https://www.tensorflow.org/get_started/basic_usage">原文点这里。</a></p><h1 id="tensorflow-basic-usage">TensorFlow Basic Usage</h1><p>使用TensorFlow之前，你需要理解TensorFlow是如何：</p><ul><li>使用图表示计算</li><li>在 <code>Sessions</code> 的上下文中执行图</li><li>使用 <code>Tensor</code> (张量)表示数据</li><li>使用 <code>Variables</code> (变量)维护状态的</li><li>在任意操作中使用 <code>feeds</code> 和 <code>fetches</code> 设置和获取数据</li></ul><h2 id="概述overview">概述(Overview)</h2><p>TensorFlow是一个使用图来表示计算的编程系统。图中的节点称为 <code>op</code>(译注: operations 的缩写)。<code>op</code> 的输入为0或多个 <code>Tensor</code>，进行计算，生成0或多个 <code>Tensor</code>。在TensorFlow的术语中，1个 <code>Tensor</code> 是一个包含类型约束的多维数组。例如你可以使用类似 <code>[batch, heigh, width, channels]</code> 的4维浮点数组表示一小批图片。</p><p>1个TensorFlow图就是==对计算的描述==。进行任何计算之前，都必须先在一个 <code>Session</code> 中生成图。<code>Session</code> 负责把图中的操作（<code>op</code>）分配给 <code>Devices</code>（比如CPU、GPU），并且提供执行这些操作的方法。这些方法返回操作（译注：<code>ops</code>）产生的张量（译注：<code>Tensor</code>）（比如 <code>numpy</code> 中的<code>ndarray</code> Python对象，C/C++中 <code>tensorflow::Tensor</code>实例）。</p><h2 id="计算图the-computation-graph">计算图(The computation graph)</h2><p>TensorFlow程序一般结构上分为两个阶段：构造阶段，生成图；执行阶段，使用 session 来执行图中的操作。 比如，通常在构造阶段创建图来表示、训练神经网络，然后在执行阶段重复的执行图中的一系列训练操作。 TensorFlow支持C/C++和Python。目前，使用Python库来生成图相对来说更方便，因为Python的各种库包含大量的帮助函数，这是C/C++的库所没有的。 Session库对于三种语言都提供了相同的功能。</p><h3 id="构造图building-the-graph">构造图(Building the graph)</h3><p>我们可以利用无需输入的操作 <code>ops</code> （比如 <code>Constant</code>）来从最开始构造一个图（译注：<code>graph</code>），并把这些操作的输出传递给其他可以进行计算的操作 <code>ops</code>。 使用 Python 库提供的操作(<code>ops</code>) 构造函数返回构造好的操作(<code>ops</code>)对象。你可以把这些构造好的操作 (<code>ops</code>)作为输入传递给其他的操作(<code>ops</code>)构造函数。 TensorFlow 的 Python 库包含一个默认的图， 操作(<code>ops</code>) 构造函数生成的节点默认添加到其中。对于多数应用，这个默认的图已经足够。关于如何手动管理多个图参考 <a href="https://www.tensorflow.org/api_docs/python/framework/core_graph_data_structures#Graph">Graph class</a>。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建生成1*2矩阵的常量操作。</span></span><br><span class="line"><span class="comment"># 这个操作作为一个节点（译注：node）被添加到默认图中。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 构造器的返回值表示常量操作的输出。</span></span><br><span class="line">matrix1 = tf.constant([[<span class="number">3.</span>, <span class="number">3.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建生成2*1矩阵的另一个常量。</span></span><br><span class="line">matrix2 = tf.constant([[<span class="number">2.</span>],[<span class="number">2.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Matmul操作，把 ‘matrix1’ 和 ‘matrix2’ 作为输入。</span></span><br><span class="line"><span class="comment"># 返回值 &#x27;product&#x27; 表示矩阵乘法的结果。</span></span><br><span class="line">product = tf.matmul(matrix1, matrix2)</span><br></pre></td></tr></table></figure> 现在默认的图包含了3个节点：两个 <code>contant()</code>操作和一个 <code>matmul()</code> 操作。为了实际进行矩阵乘法和获得乘法的结果，必须在 <code>session</code> 中启动图(<code>graph</code>)。</p><h3 id="在-session-中运行图launching-the-graph-in-a-session">在 Session 中运行图(Launching the graph in a session)</h3><p>在构造图之后就可以运行图了。运行图之前需要先创建 <code>Session</code> 对象。不需要参数的Session构造函数（译注：session constructor）就会运行默认图。 参考 <a href="https://www.tensorflow.org/api_docs/python/client#session_management">Session class</a>查看完整的Session API文档。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动默认图</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用session的run()函数并把 ‘product’（表示matmul操作的输出）作为传输传递给它来运行 matmul操作。</span></span><br><span class="line"><span class="comment"># 这表示我们想要 ‘matmul’ 操作的输出。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 操作所需的参数由 session 自动运算并传递。</span></span><br><span class="line"><span class="comment"># 通常这些运算是并行运行的。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 对 ‘run(product)’ 的调用使图中3个操作得以执行：2个常量和一个矩阵乘法。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 矩阵乘法的输出 ‘numpy’ 的 ‘ndarray’ 对象保存在 ‘result’ 中。</span></span><br><span class="line">result = sess.run(product)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># ==&gt; [[ 12.]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 完工，关闭session。</span></span><br><span class="line">sess.close()</span><br></pre></td></tr></table></figure> 使用完后关闭 Session 释放资源。也可以用 <code>with</code> 语句块进入 <code>Session</code>中执行。<code>Session</code> 会在 <code>with</code> 代码块结束后自动关闭。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">  result = sess.run([product])</span><br><span class="line">  <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure> TensorFlow把图定义翻译成可被分配到计算资源（CPU、GPU）的可执行操作。一般来说你不需要指定CPU或GPU。TensorFlow会使用你的第一个GPU进行尽可能多的操作。 如果你的机器包含不止一个GPU，为了使用其他的GPU，你必须手动分配操作到指定GPU。使用 <code>with...Device</code> 语句来为操作指定CPU或GPU设备： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">  <span class="keyword">with</span> tf.device(<span class="string">&quot;/gpu:1&quot;</span>):</span><br><span class="line">    matrix1 = tf.constant([[<span class="number">3.</span>, <span class="number">3.</span>]])</span><br><span class="line">    matrix2 = tf.constant([[<span class="number">2.</span>],[<span class="number">2.</span>]])</span><br><span class="line">    product = tf.matmul(matrix1, matrix2)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure> 设备是使用字符串指定。目前支持的设备包括：</p><ul><li><code>"/cpu:0"</code>：你机器的CPU。</li><li><code>"/gpu:0"</code>：你机器的GPU。</li><li><code>"/gpu:1"</code>：你机器的第二块GPU。</li></ul><p>参考<a href="https://www.tensorflow.org/how_tos/using_gpu/index">Using GPUs</a>查看TensorFlow使用GPU的更多信息。</p><h3 id="在分布式session中启动图launching-the-graph-in-a-distributed-session">在分布式Session中启动图(Launching the graph in a distributed session)</h3><p>为了创建 TensorFlow 集群，需要在集群中的每台机器上都启动 TensorFlow 服务器。在客户机上初始化 <code>Session</code> 的时候，把集群中某个机器的网络地址传递给 <code>Session()</code> 函数： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session(<span class="string">&quot;grpc://example.org:2222&quot;</span>) <span class="keyword">as</span> sess:</span><br><span class="line">  <span class="comment"># Calls to sess.run(...) will be executed on the cluster.</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure> 这台机器就成为这个 session 的控制者（译注：master）。Master把图分配到集群中的其它机器上，与本地把图分配到本地计算资源非常类似。 你可以使用 <code>with tf.device()</code> 语句来为图的特定部分直接指定计算资源： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.device(<span class="string">&quot;/job:ps/task:0&quot;</span>):</span><br><span class="line">  weights = tf.Variable(...)</span><br><span class="line">  biases = tf.Variable(...)</span><br></pre></td></tr></table></figure> 参考 <a href="https://www.tensorflow.org/how_tos/distributed/">Distributed TensorFlow How To</a> 查看分布式 Session 和集群的更多信息。</p><h2 id="交互式使用">交互式使用</h2><p>上面Python的例子使用 <code>Session</code> 构造图，使用 <code>Session.run()</code> 来执行操作。 为了方便在交互式环境中使用TensorFlow，比如IPython，你可以使用 <code>InteractiveSession</code>类和 <code>Tensor.eval()</code> 和 <code>Operation.run()</code> 函数。这样可以避免使用变量来保存 session。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enter an interactive TensorFlow Session.</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">sess = tf.InteractiveSession()</span><br><span class="line"></span><br><span class="line">x = tf.Variable([<span class="number">1.0</span>, <span class="number">2.0</span>])</span><br><span class="line">a = tf.constant([<span class="number">3.0</span>, <span class="number">3.0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize &#x27;x&#x27; using the run() method of its initializer op.</span></span><br><span class="line">x.initializer.run()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add an op to subtract &#x27;a&#x27; from &#x27;x&#x27;.  Run it and print the result</span></span><br><span class="line">sub = tf.sub(x, a)</span><br><span class="line"><span class="built_in">print</span>(sub.<span class="built_in">eval</span>())</span><br><span class="line"><span class="comment"># ==&gt; [-2. -1.]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Close the Session when we&#x27;re done.</span></span><br><span class="line">sess.close()</span><br></pre></td></tr></table></figure></p><h2 id="张量tensors">张量(Tensors)</h2><p>TensorFlow 程序使用张量数据结构表示所有的数据，在计算图的操作中只能传递张量数据类型。你可以把TensorFlow中的张量想象成一个n维数组或队列。一个张量使用固定的类型、行和形状。参考 <a href="https://www.tensorflow.org/resources/dims_types">Rank, Shape, and Type</a> 获取 TensorFlow 如何处理这些概念的信息。</p><h2 id="变量variables">变量(Variables)</h2><p>变量(Variables)在图的计算过程中维护状态。下面的例子展示作为计数器的变量。参考 <a href="https://www.tensorflow.org/how_tos/variables/index">Variables</a> 了解更多细节。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个变量，以后会被初始化为标量0。</span></span><br><span class="line">state = tf.Variable(<span class="number">0</span>, name=<span class="string">&quot;counter&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个操作，为 ‘state’ 增加1。</span></span><br><span class="line"></span><br><span class="line">one = tf.constant(<span class="number">1</span>)</span><br><span class="line">new_value = tf.add(state, one)</span><br><span class="line">update = tf.assign(state, new_value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须在初始化图后运行 ‘init’ 操作才能初始化变量。</span></span><br><span class="line"><span class="comment"># 首先必须把 ‘init’ 操作添加到图中。</span></span><br><span class="line">init_op = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Launch the graph and run the ops.</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">  <span class="comment"># Run the &#x27;init&#x27; op</span></span><br><span class="line">  sess.run(init_op)</span><br><span class="line">  <span class="comment"># Print the initial value of &#x27;state&#x27;</span></span><br><span class="line">  <span class="built_in">print</span>(sess.run(state))</span><br><span class="line">  <span class="comment"># Run the op that updates &#x27;state&#x27; and print &#x27;state&#x27;.</span></span><br><span class="line">  <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    sess.run(update)</span><br><span class="line">    <span class="built_in">print</span>(sess.run(state))</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure> 上面代码中的 <code>assign()</code> 操作与 <code>add()</code> 操作一天都是是图表达式的一部分，直到 <code>run()</code> 函数运行它的时候才会实际执行这个赋值操作。 &gt;==译注：所有的操作(op)都在run()中执行，变量都在初始化的时候初始化，用来生成图。==</p><p>典型的做法使用 <code>Variable</code> 的集合来表示静态模型的参数。例如，你应该把神经网络的权重参数作为张量保存在 <code>Variable</code>中。在训练过程中通过不断重复的训练这个图来更新这个张量。</p><h2 id="fetches">Fetches</h2><p>获取操作的输出，调用 <code>Session.run()</code> 方法，把希望获取的张量传递进来作为参数就可以。在上边的例子中我们获取了节点状态，我们还可以获取更多张量的值： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">input1 = tf.constant([<span class="number">3.0</span>])</span><br><span class="line">input2 = tf.constant([<span class="number">2.0</span>])</span><br><span class="line">input3 = tf.constant([<span class="number">5.0</span>])</span><br><span class="line">intermed = tf.add(input2, input3)</span><br><span class="line">mul = tf.mul(input1, intermed)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">  result = sess.run([mul, intermed])</span><br><span class="line">  <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># [array([ 21.], dtype=float32), array([ 7.], dtype=float32)]</span></span><br></pre></td></tr></table></figure> &gt; ==注意：所有需要产生请求结果的操作都只运行一次（译注：本例中intermed这个操作只运行了一次），而不是每次请求操作都运行一次。==</p><h2 id="feeds">Feeds</h2><p>上面所有例子中输入给计算图的张量都是使用 <code>Constants</code> 和 <code>Variables</code> 存储的。TensorFlow 同时提供 Feed(填充) ==（译注：feed，就是喂数据的意思）==机制来直接修改图中任何操作 <code>op</code> 的数据。 Feed 使用一个张量临时代替某个操作的输出。把填充数据作为参数传递给 <code>run()</code> 函数。填充数据仅仅用于当前传递的操作。最常见的例子就是使用 <code>tf.placeholder()</code> 来创建操作，并指定某个操作作为 Feed 操作。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">input1 = tf.placeholder(tf.float32)</span><br><span class="line">input2 = tf.placeholder(tf.float32)</span><br><span class="line">output = tf.mul(input1, input2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">  <span class="built_in">print</span>(sess.run([output], feed_dict=&#123;input1:[<span class="number">7.</span>], input2:[<span class="number">2.</span>]&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># [array([ 14.], dtype=float32)]</span></span><br></pre></td></tr></table></figure> 对于<code>placeholder()</code> 操作，如果不提供 Feed 运行时会产生错误。参考<a href="https://www.tensorflow.org/tutorials/mnist/tf/index">MNIST fully-connected feed tutorial</a> 查看更多种子的例子。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文为原文不完整翻译以及学习笔记。 &lt;a href=&quot;https://www.tensorflow.org/get_started/basic_usage&quot;&gt;原文点这里。&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;tensorflow-basic-usage&quot;&gt;TensorFlow </summary>
      
    
    
    
    <category term="TensorFlow" scheme="https://www.zhangyuzheng.com/categories/TensorFlow/"/>
    
    
    <category term="TensorFlow" scheme="https://www.zhangyuzheng.com/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>Git Submodules 学习笔记</title>
    <link href="https://www.zhangyuzheng.com/Git/Git%20Submodules/"/>
    <id>https://www.zhangyuzheng.com/Git/Git%20Submodules/</id>
    <published>2016-12-24T05:40:00.000Z</published>
    <updated>2021-08-14T03:53:53.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git-submodules">Git Submodules</h1><p>译自<a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">原文</a> ，有部分修改。</p><h2 id="子模块-submodules">子模块 Submodules</h2><p>在一个项目中使用其他的项目是一种常见的现象。或许是第三方开发的库或你自己为了在多个项目中使用而开发的单独的库。这些情况综合能够最常见的问题就是：你既想把他们作为两个独立的库对待又想在一个项目中使用例外一个。</p><p>假设你在开发一个网站，它包含Atom订阅功能。所以你决定使用第三方库而不是自己编写生成Atom订阅的代码。你的做法可能是使用CPAN、Ruby gem的共享库或是复制相应的代码到你的代码树中。直接使用共享库的问题你很难对库进行任何形式的定制，并且部署难度大，因为你要保证每个客户端都包含同样的库。把代码复制到自己的代码树的问题是你对它的任何修改定制都可能在上游代码修改后变得很难合并。</p><p>子模块就是为了解决这个问题。==子模块就是你可以在一个Git仓库的子目录中包含另一个Git仓库==。</p><h2 id="开始使用子模块-starting-with-submodules">开始使用子模块 Starting with Submodules</h2><p>我们简单分析下这个分割为主项目和若干子项目的简单项目。</p><p>首先我们把一个现有的Git仓库作为子模块添加到我们正在工作的项目中。使用 'git submodule add' 命令，把你想要跟踪的仓库的绝对或相对路径作为参数，来添加子模块。本例中，我们添加一个成为 “DbConnector” 的库。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule add  git@github.com:somename/somerepository.git</span><br><span class="line">Cloning into &#x27;somerepository&#x27;...</span><br><span class="line">Warning: Permanently added the RSA host key for IP address &#x27;192.30.253.113&#x27; to the list of known hosts.</span><br><span class="line">remote: Counting objects: 9, done.</span><br><span class="line">remote: Compressing objects: 100% (6/6), done.</span><br><span class="line">remote: Total 9 (delta 0), reused 3 (delta 0), pack-reused 0</span><br><span class="line">Receiving objects: 100% (9/9), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line"></span><br></pre></td></tr></table></figure> 默认，子模块被添加大与子项目同名的目录中，本例中名字为 “somerepository”。你也可以在名字末尾增加你想保存的子目录的路径。</p><p>这时运行 ‘git status’，你会发现入戏结果： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   .gitmodules</span><br><span class="line">new file:   somerepository</span><br></pre></td></tr></table></figure> 你首先会注意到新增的文件 '.gitmodules'。这是保存项目地址与本地子目录间映射关系的配置文件： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[submodule &quot;somerepository&quot;]</span><br><span class="line">    path = somerepository</span><br><span class="line">    url = git@github.com:somename/somerepository.git</span><br></pre></td></tr></table></figure> 如果你有多个子模块，配置文件中会包含多个这样的配置项。值得注意的是这个文件与其他文件比如 '.gitignore' 一样都是进行版本控制的。与项目中其他文件一样都会被 'push' 和 'pull'。这样别人使用这个仓库的时候就也知道去哪儿获得子模块了。</p><blockquote><p>由于 '.gitmodules' 中仓库的地址是其他人首先尝试clone/fetch的地址，尽量保证这个地址可以被其他人访问到。比如，如果你push的地址与其他人pull的地址不同，使用那个其他人也可以访问到的地址。你可以使用 <code>git config submodule.somerepository.url PRIVATE_URL</code> 来重写这个地址来供你自己使用。有些时候，使用相对地址非常有用。</p></blockquote><p><code>git status</code> 命令的另外一个输出是项目的目录项。如果对这个目录运行 <code>git diff</code>，你会发现一些有趣的结果： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached somerepository/</span><br><span class="line">diff --git a/somerepository b/somerepository</span><br><span class="line">new file mode 160000</span><br><span class="line">index 0000000..e4c24a3</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/somerepository</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+Subproject commit e4c24a3fb6a10c451730553402acaa27caf5f682</span><br><span class="line"></span><br></pre></td></tr></table></figure> 虽然 somerepository 是一个目录，Git把它作为子模块处理，并且不跟踪它内部的内容。相反Git把它作为一个特殊的 commit 。 如果你想要更好看的 diff 的输出，可以给 <code>git diff</code> 传递 <code>--submodule</code> 参数。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached --submodule</span><br><span class="line">diff --git a/.gitmodules b/.gitmodules</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..8291bcf</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/.gitmodules</span><br><span class="line">@@ -0,0 +1,3 @@</span><br><span class="line">+[submodule &quot;somerepository&quot;]</span><br><span class="line">+       path = somerepository</span><br><span class="line">+       url = git@github.com:somename/somerepository.git</span><br><span class="line">Submodule zhangyuz.github.io 0000000...e4c24a3 (new submodule)</span><br><span class="line"></span><br></pre></td></tr></table></figure> 提交commit的时候可以看见： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am &#x27;Add submodule somerepository&#x27;</span><br><span class="line">[master 435c587] Add submodule somerepository</span><br><span class="line"> 2 files changed, 4 insertions(+)</span><br><span class="line"> create mode 100644 .gitmodules</span><br><span class="line"> create mode 160000 somerepository</span><br></pre></td></tr></table></figure> ==注意 somerepository 的 mode 是 <code>160000</code>。这时Git中一种特殊的 mode ，基本意思就是以目录的形式记录commit，而不是记录为子目录或文件。==</p><h2 id="clone包含子模块的项目">Clone包含子模块的项目</h2><ol type="1"><li>方式1：<ol type="1"><li>克隆主项目：<code>git clone path/to/your/main/project</code> 克隆回本地的项目中会包含空的子模块，子模块中是空的。</li><li><code>git submodule init</code> 初始化本地配置。</li><li><code>git submodule update</code> fetch 子模块的所有文件，并且 checkout 合适的 commit。</li></ol></li><li>方式2：<ol type="1"><li><code>git clone --recursive path/to/your/main/project</code>，它会自动初始化和更新其中的每个子模块。</li></ol></li></ol><h2 id="使用包含子模块的项目">使用包含子模块的项目</h2><p>现在我们已经有了一个包含子模块的项目，我们在与团队成员合作开发主项目和子项目。</p><h3 id="拉取上游修改">拉取上游修改</h3><p>如果你只是一个子模块的消费者（既不对子模块贡献代码），并希望及时获得子模块的最新修改，你可以直接进入子模块的目录运行 <code>git fetch</code> 和 <code>git merge</code> 把上游代码合并到本地即可。 这时回到主项目，运行 <code>git diff</code>，你会发现主项目跟踪了子项目HEAD的commit的变化（有个名字叫submodule的子模块）： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/submodule b/submodule</span><br><span class="line">index a1f2285..6910783 160000</span><br><span class="line">--- a/submodule</span><br><span class="line">+++ b/submodule</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-Subproject commit a1f228568aafe016a3e06e69f14abf211c124d49</span><br><span class="line">+Subproject commit 6910783df605ced7860d8260dc87622c4904bba7</span><br><span class="line"></span><br></pre></td></tr></table></figure> 运行 <code>git diff --submodule</code>， 你可以看见具体子模块变更的commit。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --submodule</span><br><span class="line">Submodule submodule a1f2285..6910783:</span><br><span class="line">  &gt; Update readme</span><br></pre></td></tr></table></figure> 你可以设置 <code>git diff</code> 默认显示子模块的变化 <code>git config --global diff.submodule log</code>。 如果这时 commit 主项目的修改，那么别人更新代码后也会获得这个更新。</p><p><code>git submodule update --remote path/to/submodule</code> ：自动更新子模块。</p><p><code>git config -f .gitmodules submodule.asubmodule.branch stable</code> 设置子模块跟踪的分支。本例中设置 asubmodule 这个子模块默认跟踪 stable 这个分支。 <code>git submodule update --remote</code> 自动更新子模块。</p><p><code>git config status.submodulesummary 1</code> 设置 <code>git status</code> 显示子模块修改的摘要信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;git-submodules&quot;&gt;Git Submodules&lt;/h1&gt;
&lt;p&gt;译自&lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Tools-Submodules&quot;&gt;原文&lt;/a&gt; ，有部分修改。&lt;/p&gt;
&lt;h2 id=&quot;子模</summary>
      
    
    
    
    <category term="Git" scheme="https://www.zhangyuzheng.com/categories/Git/"/>
    
    
    <category term="git" scheme="https://www.zhangyuzheng.com/tags/git/"/>
    
    <category term="submodule" scheme="https://www.zhangyuzheng.com/tags/submodule/"/>
    
  </entry>
  
  <entry>
    <title>Pelican 入门</title>
    <link href="https://www.zhangyuzheng.com/Pelican/PelicanIntroduction/"/>
    <id>https://www.zhangyuzheng.com/Pelican/PelicanIntroduction/</id>
    <published>2016-12-18T03:58:00.000Z</published>
    <updated>2021-08-14T03:53:53.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pelican-入门">Pelican 入门</h1><p><a href="http://docs.getpelican.com/en/stable/index.html">http://docs.getpelican.com/en/stable/index.html</a></p><h2 id="pelican-安装">Pelican 安装</h2><p><code>pip install pelican markdown typogrify beautifulsoup4</code> 安装 <code>typogrify</code> 和 <code>beautifulsoup4</code>是为了后面使用 <code>render_math</code> 插件生成数学公式使用。 &gt; 后来发现 <code>render_math</code> 在最新版本的 Pelican 不工作。需要使用 <code>python-markdown-math</code> 来帮助实现。</p><p><code>pip install python-markdown-math</code> <a href="https://github.com/mitya57/python-markdown-math">参考</a></p><p><code>pip install ghp-import</code> 用于发布网页到github。</p><h2 id="使用pelican-quickstart快速生成网站框架">使用pelican-quickstart快速生成网站框架</h2><p>运行pelican-quickstart命令快速交互式创建网站框架。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ pelican-quickstart </span><br><span class="line">Welcome to pelican-quickstart v3.7.0.</span><br><span class="line"></span><br><span class="line">This script will <span class="built_in">help</span> you create a new Pelican-based website.</span><br><span class="line"></span><br><span class="line">Please answer the following questions so this script can generate the files</span><br><span class="line">needed by Pelican.</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&gt; Where <span class="keyword">do</span> you want to create your new web site? [.] </span><br><span class="line">&gt; What will be the title of this web site? Running Out of Memory   </span><br><span class="line">&gt; Who will be the author of this web site? Zhang Yuz</span><br><span class="line">&gt; What will be the default language of this web site? [en] zh</span><br><span class="line">&gt; Do you want to specify a URL prefix? e.g., http://example.com   (Y/n) </span><br><span class="line">&gt; What is your URL prefix? (see above example; no trailing slash) https://zhangyuz.github.io </span><br><span class="line">&gt; Do you want to <span class="built_in">enable</span> article pagination? (Y/n) </span><br><span class="line">&gt; How many articles per page <span class="keyword">do</span> you want? [10] 8</span><br><span class="line">&gt; What is your time zone? [Europe/Paris] Asia/Shanghai</span><br><span class="line">&gt; Do you want to generate a Fabfile/Makefile to automate generation and publishing? (Y/n) </span><br><span class="line">&gt; Do you want an auto-reload &amp; simpleHTTP script to assist with theme and site development? (Y/n) </span><br><span class="line">&gt; Do you want to upload your website using FTP? (y/N) </span><br><span class="line">&gt; Do you want to upload your website using SSH? (y/N) </span><br><span class="line">&gt; Do you want to upload your website using Dropbox? (y/N) </span><br><span class="line">&gt; Do you want to upload your website using S3? (y/N) </span><br><span class="line">&gt; Do you want to upload your website using Rackspace Cloud Files? (y/N) </span><br><span class="line">&gt; Do you want to upload your website using GitHub Pages? (y/N) y</span><br><span class="line">&gt; Is this your personal page (username.github.io)? (y/N) </span><br><span class="line">Done. Your new project is available at /home/yuz/YuZ/zhangyuz.github.io/running-out-of-memory</span><br></pre></td></tr></table></figure></p><h2 id="编写内容">编写内容</h2><h3 id="文章与页面">文章与页面</h3><p>Pelican把文章（articles）看做时间连续的内容，比如发布一篇blog，因此它和某个日期是相关的。 页面(pages)背后的意义是这样的：他们通常不是短期存在的，目的是保存那些不经常改变的内容（比如：About页面、Contact页面）。 ### 文件元信息（File metadata）</p><p>Pelican想尽可能只能的从你的文件系统（译注：此处文件系统是指文件，比如目录的名字）获取它需要的信息（比如，你文章的类别），但是你还是需要在你文件的内部以元信息的形式提供文章信息。 &gt;我本人使用 markdown 写作，所以下面只涉及 markdown 和 HTML 语法的元信息写法</p><p>使用 Markdown 写作的元信息语法： <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Title: My super title</span><br><span class="line">Date: 2010-12-03 10:20</span><br><span class="line">Modified: 2010-12-05 19:30</span><br><span class="line">Category: Python</span><br><span class="line">Tags: pelican, publishing</span><br><span class="line">Slug: my-super-post</span><br><span class="line">Authors: Alexis Metaireau, Conan Doyle</span><br><span class="line">Summary: Short version for index and feeds</span><br><span class="line"></span><br><span class="line">This is the content of my super blog post.</span><br></pre></td></tr></table></figure></p><p>使用HTML编写的元信息语法： <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>My super title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;tags&quot;</span> <span class="attr">content</span>=<span class="string">&quot;thats, awesome&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;date&quot;</span> <span class="attr">content</span>=<span class="string">&quot;2012-07-09 22:28&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;modified&quot;</span> <span class="attr">content</span>=<span class="string">&quot;2012-07-10 20:14&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;category&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yeah&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;authors&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Alexis Métaireau, Conan Doyle&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;summary&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Short version for index and feeds&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        This is the content of my super blog post.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>除了文章标题（title）以外的元信息都是可选的：如果没有指定日期（Date）并且 <code>DEFAULT_DATE</code>设置为 <code>fs</code> ，Pelican 就使用这个文件的 mtime 属性作为日期。文章的分类（Category）可以使用包含文章的目录来确定。如果你使用其他的方式组织你的文章目录结构，目录的名字不适合作为分类的名字，你可以设置 <code>USE_FOLDER_AS_CATEGORY</code> 为 <code>False</code> 。在解析元信息中的日期（Date）时，Pelican 支持的是 W3C 的 <a href="https://www.w3.org/TR/NOTE-datetime">ISO8601</a> 。</p><blockquote><p>在试验不同的设置（尤其涉及到元信息）时，缓存可能影响是修改使修改无法生效。在这种情况下，可以设置 <code>LOAD_CONTENT_CACHE = False</code> 来禁用缓存或者使用 <code>--ignore-cache</code> 命令行开关。</p></blockquote><p>modified 应该是你最后更新文章的时间，如果不指定，默认设为 date。除了在模板中显示 modified　时间以外，如果把 modified时间设置为当前时间，rss/atom订阅中文章的时间也会自动更新（译注：订阅者也会收到更新提醒）。</p><p>authors 是逗号分割的文章作者列表。如果只有一位作者，你可以使用 author 代替 authors。</p><p>如果不指定 summary 信息，<code>SUMMARY_MAX_LENGTH</code> 设置用来指定默认使用文章起始多少字作为文章的 summary。</p><p>你可以使用 <code>FILENAME_METADATA</code> 设置正则表达式，从文件名字中抽取出任何文章的元信息。任何符合正则表达式的命名字段都会被设置到元信息对象中。<code>FILENAME_METADATA</code> 的默认值仅仅从文件名字中获取<code>date</code>信息。例如，如果你想从文件名字中抽取 <code>date</code> 和 <code>slug</code>， 你可能需要把 <code>FILENAME_METADATA</code> 设置成 <code>'(?P&lt;date&gt;\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;)_(?P&lt;slug&gt;.*)'</code></p><p>注意，你文中设置的元信息比从文件名字中抽取的元信息优先级更高，会被优先使用。</p><h3 id="页面pages">页面（Pages）</h3><p>如果在 <code>content</code>　目录下创建名为 <code>pages</code>　的目录，其中的所有文件都会被用来创建静态页面，比如 <code>About</code>、<code>Contact</code>页面。</p><p>使用 <code>DISPLAY_PAGES_ON_MENU</code> 设置来控制是否所有静态页面都显示在导航菜单中（默认为 <code>True</code>）。</p><p>如果希望设置某个文件既无法被链接到也不在导航菜单中显示，可以在文中元信息增加 <code>status: hidden</code> 属性。这个属性在制作错误页的时候比较有用。</p><h3 id="内部资源链接">内部资源链接</h3><p>使用 <code>&#123;filename&#125;path/to/file</code> 来链接内部内容（==<strong>译注：指的是 <code>content</code> 目录中的内容</strong>==）。注意前面的<code>/</code> 是 <code>&#123;filename&#125;</code> 指令的所必须的分隔符。（译注：这里的内容指的你写作的文章，rst或md文件等）</p><p>例如，你的Pelican项目结构如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">website/</span><br><span class="line">├── content</span><br><span class="line">│   ├── category/</span><br><span class="line">│   │   └── article1.rst</span><br><span class="line">│   ├── article2.md</span><br><span class="line">│   └── pages</span><br><span class="line">│       └── about.md</span><br><span class="line">└── pelican.conf.py</span><br></pre></td></tr></table></figure></p><p><code>article1.rst</code> 中的内容可能如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">The first article</span><br><span class="line">#################</span><br><span class="line"></span><br><span class="line">:date: 2012-12-01 10:02</span><br><span class="line"></span><br><span class="line">See below intra-site link examples in reStructuredText format.</span><br><span class="line"></span><br><span class="line">`a link relative to the current file &lt;&#123;filename&#125;../article2.md&gt;`_</span><br><span class="line">`a link relative to the content root &lt;&#123;filename&#125;/article2.md&gt;`_</span><br></pre></td></tr></table></figure></p><p><code>article2.md</code> 中的内容： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Title: The second article</span><br><span class="line">Date: 2012-12-01 10:02</span><br><span class="line"></span><br><span class="line">See below intra-site link examples in Markdown format.</span><br><span class="line"></span><br><span class="line">[a link relative to the current file](&#123;filename&#125;category/article1.rst)</span><br><span class="line">[a link relative to the content root](&#123;filename&#125;/category/article1.rst)</span><br></pre></td></tr></table></figure> ==<strong>（译注：注意上面路径中相对于当前文件和相对于 <code>content</code> 目录文件路径的不同写法。）</strong>==</p><h4 id="静态文件链接">静态文件链接</h4><p>链接到非文章、非页面内容液使用前文提到的 <code>&#123;filename&#125;</code> 语法。重点是除非包含这些文件的目录被包含在项目配置文件 <code>pelicanconf.py</code> 的 <code>STATIC_PATHS</code>设置中，否则这些文件是不会自动被复制到 <code>output</code> 目录的。Pelican的默认设置包含 <code>images</code> 目录，但是其他目录必须手动添加。忘记添加设置将会导致链接无效。</p><p>例如，你项目的 content 目录结构如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">content</span><br><span class="line">├── images</span><br><span class="line">│   └── han.jpg</span><br><span class="line">├── pdfs</span><br><span class="line">│   └── menu.pdf</span><br><span class="line">└── pages</span><br><span class="line">    └── test.md</span><br></pre></td></tr></table></figure></p><p><code>test.md</code> 可能写作如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![Alt Text](&#123;filename&#125;/images/han.jpg)</span><br><span class="line">[Our Menu](&#123;filename&#125;/pdfs/menu.pdf)</span><br></pre></td></tr></table></figure></p><p><code>pelicanconf.py</code> 应该包含如下内容： <code>STATIC_PATHS = ['images', 'pdfs']</code></p><p>网站生成过程中，会把<code>han.jpg</code> 复制到 <code>output/images/han.jpg</code>， <code>menu.pdf</code> 复制到 <code>out/pdfs/mnu.pdf</code>, 并根据test.md生成合适的链接。</p><h4 id="在同一个目录中混合内容mixed-content-in-the-same-directory">在同一个目录中混合内容（Mixed content in the same directory）</h4><p>从 Pelican3.5 开始，静态文件和页面源码文件可以放在相同的目录中，无需担心会在生成的站点中暴漏源码。对于这种混合的目录，必须同时添加到 <code>STATIC_PATHS</code>和 <code>PAGE_PATHS</code>（或者 <code>STATIC_PATHS</code> 和 <code>ARTICLE_PATHS</code>），这样 Pelican 就可以正常处理其中的页面源码并且复制其他文件（就像他们在独立的目录中一样）。</p><p>注意：把静态文件和源码内容放在相同的目录并不能保证它们在生成的站点中仍然位于同一个目录。为了达到这样的效果，最简单的方法是使用 <code>attach</code>语法。作为一种选择， <code>STATIC_SAVE_AS</code>、<code>PAGE_SAVE_AS</code> 和 <code>ARTICLE_SAVE_AS</code> （连同相应的 <code>*_URL</code> 设置）这些设置实现把不同类型的内容放在相同的目录中的目的，这个与 Pelican 之前的版本是一致的。</p><h4 id="附件静态文件attaching-static-files">附件静态文件（Attaching static files）</h4><p>从 Pelican3.5开始，使用 <code>&#123;attach&#125;path/to/file</code> 语法可以（attached）静态文件到静态页面或文章中。这和 <code>&#123;fileneme&#125;</code> 语法效果类似，但是同时会把静态文件重定位到链接文件的输出目录。如果被链接的文件位于使用链接的文件的目录的下级目录中，那么也会在输出目录中保持相同的目录结构；否则，静态文件会被放到与链接它的文件相同的目录。</p><p>本语法仅适用于静态文件，并且他们位于 <code>STATIC_PATHS</code> 所设置的目录中。</p><p>例如，某个项目的 content 目录结构如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">content</span><br><span class="line">├── blog</span><br><span class="line">│   ├── icons</span><br><span class="line">│   │   └── icon.png</span><br><span class="line">│   ├── photo.jpg</span><br><span class="line">│   └── testpost.md</span><br><span class="line">└── downloads</span><br><span class="line">    └── archive.zip</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>`pelicanconf.py‘ 应该包含如下内容： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PATH = &#x27;content&#x27;</span><br><span class="line">STATIC_PATHS = [&#x27;blog&#x27;, &#x27;downloads&#x27;]</span><br><span class="line">ARTICLE_PATHS = [&#x27;blog&#x27;]</span><br><span class="line">ARTICLE_SAVE_AS = &#x27;&#123;date:%Y&#125;/&#123;slug&#125;.html&#x27;</span><br><span class="line">ARTICLE_URL = &#x27;&#123;date:%Y&#125;/&#123;slug&#125;.html&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p><code>testpost.md</code> 写作： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Title: Test Post</span><br><span class="line">Category: test</span><br><span class="line">Date: 2014-10-31</span><br><span class="line"></span><br><span class="line">![Icon](&#123;attach&#125;icons/icon.png)</span><br><span class="line">![Photo](&#123;attach&#125;photo.jpg)</span><br><span class="line">[Downloadable File](&#123;attach&#125;/downloads/archive.zip)</span><br></pre></td></tr></table></figure></p><p>那么生成的输出目录结构如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">output</span><br><span class="line">└── 2014</span><br><span class="line">    ├── archive.zip</span><br><span class="line">    ├── icons</span><br><span class="line">    │   └── icon.png</span><br><span class="line">    ├── photo.jpg</span><br><span class="line">    └── test-post.html</span><br></pre></td></tr></table></figure></p><p>对于比链接多次的静态文件，<code>&#123;attach&#125;</code> 只在第一次处理到它时生效一次，之后把它与 <code>&#123;filename&#125;</code> 做相同的处理。这样可以避免破坏已经存在的链接。</p><p>多个链接到同一个文件要格外注意：因为 Pelican在第一次处理 <code>&#123;attach&#125;</code> 标签的时候确定这个被链接文件重定位的为止，但是 Pelican 不保证每次处理文件的顺序都是相同的，所以多个链接到相同的静态文件可能在不同的编译结果中的位置也不一样（这个问题的出现和你的操作系统、文件系统、Pelican的版本、文件创建、修改和删除都有关系）。任何外部站点链接到旧的文件位置都可能因此链接无效。因此，建议只在所有使用相同链接的文档位于同一个目录使用 <code>&#123;attach&#125;</code>。这样，同一个文件的输出位置就不会改变了。对于这种前提条件不存在情况，建议使用 <code>&#123;filename&#125;</code> 代替 <code>&#123;attach&#125;</code>，让 <code>STATIC_SAVE_AS</code> 和 <code>STATIC_URL</code> 来确定被链接文件的生成位置（单个文件的 <code>save_as</code> 和 <code>url</code> 可以在 <code>EXTRA_PATH_METADATA</code> 中设置）。</p><h4 id="链接作者类别索引和标签">链接作者、类别、索引和标签</h4><p>使用 <code>&#123;author&#125;name</code> <code>&#123;category&#125;foobar</code> <code>&#123;index&#125;</code> <code>&#123;tag&#125;tagname</code> 链接到作者、类别、索引和标签。</p><h3 id="导入现有站点">导入现有站点</h3><p>参考 <a href="http://docs.getpelican.com/en/stable/importer.html#import">Importing an existing site</a> ，支持 WordPress,Tumblr, Dotclear, RSS.</p><h3 id="多语言translations">多语言（Translations）</h3><p>Pelican 支持多语言的文章。为了达到目的，你血药添加 <code>lang</code> 属性到文章(article)、页面(pages)的元信息，设置 <code>DEFAULT_LANG</code>（默认为en）。设置好后，默认语言的文章会被显示在列表中，其他翻译的版本会连同原文一起显示。 &gt; 注意：Pelican 不支持生成用于翻译子站点（比如：<code>example.com/de</code>）。参考<a href="http://github.com/getpelican/pelican-plugins/tree/master/i18n_subsites">i18n_subsites plugin</a> 来使用这种高级功能。</p><p>Pelican 使用 <code>slug</code> 来确定是否多篇文章之间具有翻译关系。用户可以在文章中手动设置<code>slug</code> 属性，否则 Pelican 根据文章标题自动生成<code>slug</code>。</p><p>例如下面英语和法语的两篇文章： 英语版： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Foobar is not dead</span><br><span class="line">##################</span><br><span class="line"></span><br><span class="line">:slug: foobar-is-not-dead</span><br><span class="line">:lang: en</span><br><span class="line"></span><br><span class="line">That&#x27;s true, foobar is still alive!</span><br></pre></td></tr></table></figure> 法语版： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Foobar n&#x27;est pas mort !</span><br><span class="line">#######################</span><br><span class="line"></span><br><span class="line">:slug: foobar-is-not-dead</span><br><span class="line">:lang: fr</span><br><span class="line"></span><br><span class="line">Oui oui, foobar est toujours vivant !</span><br></pre></td></tr></table></figure></p><p>尽管文章内容不同，但是它们两个仅有的共同点是 <code>slug</code>，功能是作为一个标识。如果你不想设置 <code>slug</code>，你就要保证它们的标题是完全一样，因为默认 <code>slug</code>是使用标题自动生成的。</p><p>如果不希望使用自动检测来确定哪一个是原始版本哪一个是翻译版，你可以用 <code>translation</code> 属性在元信息中指定。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Foobar is not dead</span><br><span class="line">##################</span><br><span class="line"></span><br><span class="line">:slug: foobar-is-not-dead</span><br><span class="line">:lang: en</span><br><span class="line">:translation: true</span><br><span class="line"></span><br><span class="line">That&#x27;s true, foobar is still alive!</span><br></pre></td></tr></table></figure> ### 语法高亮</p><p>Pelican 提供代码块的彩色高亮显示。使用下面的转换就可以实现此功能。 （译注：下面的翻译省略掉RST的部分，仅保留MD部分。）</p><p>Markdown中，Pelican 使用 <a href="http://pythonhosted.org/Markdown/extensions/code_hilite.html#syntax">CodeHilite extension</a> 提供语法高亮功能，你需要在代码块上面使用语言标识，缩进语言标识和代码： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">There are two ways to specify the identifier:</span><br><span class="line"></span><br><span class="line">    :::python</span><br><span class="line">    print(&quot;The triple-colon syntax will *not* show line numbers.&quot;)</span><br><span class="line"></span><br><span class="line">To display line numbers, use a path-less shebang instead of colons:</span><br><span class="line"></span><br><span class="line">    #!python</span><br><span class="line">    print(&quot;The path-less shebang syntax *will* show line numbers.&quot;)</span><br></pre></td></tr></table></figure></p><p>在<a href="http://pygments.org/docs/lexers/">这里</a> 查看支持的语言标识。</p><h3 id="发布草稿">发布草稿</h3><p>如果希望把文章作为草稿发布（在正式发布前请朋友审阅），你可以在元信息中添加 <code>Status: draft</code> 属性。这样这篇文章会被输出到 <code>draft</code> 目录，不想是在索引和分类、标签页中。</p><p>如果你的文章应该以草稿的方式自动发布出去（不是意外的发布未完成的文章），就在 <code>DEFAULT_METADATA</code> 设置中包含这个状态： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_METADATA = &#123;</span><br><span class="line">    &#x27;status&#x27;: &#x27;draft&#x27;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果想发布默认状态是 <code>draft</code> 的文章，设置文章的元信息 <code>Status: published</code> 即可。</p><h2 id="发布网站">发布网站</h2><h2 id="设置">设置</h2><h2 id="创建主题">创建主题</h2><h2 id="插件">插件</h2><p>##　pelican-themesd</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pelican-入门&quot;&gt;Pelican 入门&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://docs.getpelican.com/en/stable/index.html&quot;&gt;http://docs.getpelican.com/en/stable/index.</summary>
      
    
    
    
    <category term="Pelican" scheme="https://www.zhangyuzheng.com/categories/Pelican/"/>
    
    
    <category term="Pelican" scheme="https://www.zhangyuzheng.com/tags/Pelican/"/>
    
  </entry>
  
</feed>
